/*!
 * Pintura v8.88.3 - Test version
 * (c) 2018-2024 PQINA Inc. - All Rights Reserved
 * License: https://pqina.nl/pintura/license/
 * 
 * This version of Pintura is for testing purposes only.
 * Visit https://pqina.nl/pintura/ to obtain a commercial license.
 */
/* eslint-disable */

const e = [{value: 65504, name: "jfif"}, {value: 65498, name: "sos"}, {
    value: 65505,
    subvalue: 17784,
    name: "exif"
}, {value: 65505, subvalue: 26740, name: "xmp"}, {value: 65506, subvalue: 19792, name: "mpf"}, {
    value: 65506,
    name: "app2"
}];
var t = (t, o, i) => {
    if (!t) return;
    const n = new DataView(t), r = (t => {
        if (65496 !== t.getUint16(0)) return;
        const o = t.byteLength;
        let i, n = 2, r = void 0;
        for (; n < o && 255 === t.getUint8(n);) {
            i = t.getUint16(n);
            const o = e.find((e => e.value === i && (!e.subvalue || e.subvalue === t.getUint16(n + 2 + 2))));
            if (o) {
                const {name: e} = o;
                r || (r = {}), r[e] || (r[e] = {offset: n, size: t.getUint16(n + 2)})
            }
            if (65498 === i) break;
            n += 2 + t.getUint16(n + 2)
        }
        return r
    })(n);
    if (!r || !r.exif) return;
    const a = ((e, t) => {
        if (65505 !== e.getUint16(t)) return;
        const o = e.getUint16(t + 2);
        if (t += 4, 1165519206 !== e.getUint32(t)) return;
        t += 6;
        const i = e.getUint16(t);
        if (18761 !== i && 19789 !== i) return;
        const n = 18761 === i;
        if (t += 2, 42 !== e.getUint16(t, n)) return;
        t += e.getUint32(t + 2, n);
        const r = i => {
            const r = [];
            let a = t;
            const s = Math.min(e.byteLength, t + o - 16);
            for (; a < s; a += 12) {
                const t = a;
                e.getUint16(t, n) === i && r.push(t)
            }
            return r
        };
        return {
            read: t => {
                const o = r(t);
                if (o.length) return e.getUint16(o[0] + 8, n)
            }, write: (t, o) => {
                const i = r(t);
                return !!i.length && (i.forEach((t => e.setUint16(t + 8, o, n))), !0)
            }
        }
    })(n, r.exif.offset);
    return a ? void 0 === i ? a.read(o) : a.write(o, i) : void 0
};
var o = e => window.__pqina_webapi__ ? window.__pqina_webapi__[e] : window[e], i = (...e) => {
};
const n = {ArrayBuffer: "readAsArrayBuffer"};
var r = (e, t = i, r = {}) => new Promise(((i, a) => {
    const {dataFormat: s = n.ArrayBuffer} = r, l = new (o("FileReader"));
    l.onload = () => i(l.result), l.onerror = () => a(l.error), l.onprogress = t, l[s](e)
})), a = async (e, o) => {
    const i = await (async (e, t = [0, e.size], o) => await r(e.slice(...t), o))(e, [0, 262144], o);
    return t(i, 274) || 1
};
let s = null;
var l = () => (null === s && (s = "undefined" != typeof window && void 0 !== window.document), s);
let c = null;
var d = () => new Promise((e => {
    if (null === c) {
        const t = "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEASABIAAD/4QA6RXhpZgAATU0AKgAAAAgAAwESAAMAAAABAAYAAAEoAAMAAAABAAIAAAITAAMAAAABAAEAAAAAAAD/2wBDAP//////////////////////////////////////////////////////////////////////////////////////wAALCAABAAIBASIA/8QAJgABAAAAAAAAAAAAAAAAAAAAAxABAAAAAAAAAAAAAAAAAAAAAP/aAAgBAQAAPwBH/9k=";
        let o = l() ? new Image : {};
        return o.onload = () => {
            c = 1 === o.naturalWidth, o = void 0, e(c)
        }, void (o.src = t)
    }
    return e(c)
})), u = e => e.getContext("2d").getImageData(0, 0, e.width, e.height), h = e => "string" == typeof e;

function p(e, t) {
    t.split(";").forEach((t => {
        const [o, i] = t.split(":");
        if (!o.length || !i) return;
        const [n, r] = i.split("!important");
        e.style.setProperty(o, n, h(r) ? "important" : void 0)
    }))
}

var m = (e, t, o = []) => {
    const i = document.createElement(e), n = Object.getOwnPropertyDescriptors(i.__proto__);
    for (const e in t) "style" === e ? p(i, t[e]) : n[e] && n[e].set || /textContent|innerHTML/.test(e) || "function" == typeof t[e] ? i[e] = t[e] : i.setAttribute(e, t[e]);
    return o.forEach((e => i.appendChild(e))), i
};
const g = {
    1: () => [1, 0, 0, 1, 0, 0],
    2: e => [-1, 0, 0, 1, e, 0],
    3: (e, t) => [-1, 0, 0, -1, e, t],
    4: (e, t) => [1, 0, 0, -1, 0, t],
    5: () => [0, 1, 1, 0, 0, 0],
    6: (e, t) => [0, 1, -1, 0, t, 0],
    7: (e, t) => [0, -1, -1, 0, t, e],
    8: e => [0, -1, 1, 0, 0, e]
};
var $ = e => {
    e.width = 1, e.height = 1;
    const t = e.getContext("2d");
    t && t.clearRect(0, 0, 1, 1)
}, f = e => "data" in e, y = e => l() ? RegExp(e).test(window.navigator.userAgent) : void 0;
let b = null;
var x = () => (null === b && (b = y(/Android/)), b), v = (e, t) => {
    const o = m("canvas", {width: e.width, height: e.height});
    return o.getContext("2d", t).drawImage(e, 0, 0), o
}, w = async (e, t = 1) => {
    const o = await d(), [i, n] = o || t < 5 ? [e.width, e.height] : [e.height, e.width],
        r = m("canvas", {width: i, height: n}), a = r.getContext("2d", {willReadFrequently: !0});
    if (f(e) && !o && t > 1) {
        const t = m("canvas", {width: e.width, height: e.height});
        t.getContext("2d", {willReadFrequently: !0}).putImageData(e, 0, 0), e = t
    }
    if (!o && t > 1 && a.transform.apply(a, ((e, t, o = -1) => (-1 === o && (o = 1), g[o](e, t)))(e.width, e.height, t)), f(e)) {
        if (a.putImageData(e, 0, 0), x()) return v(r)
    } else a.drawImage(e, 0, 0);
    return e instanceof HTMLCanvasElement && $(e), r
}, S = async (e, t = 1) => 1 === t || await d() ? e : u(await w(e, t)), k = e => "object" == typeof e;
const C = e => e instanceof HTMLElement ? e : k(e) ? T(e) : e, T = e => {
    let t;
    return Array.isArray(e) ? (t = [], e.forEach(((e, o) => {
        t[o] = C(e)
    }))) : (t = {}, null !== e && Object.keys(e).forEach((o => {
        const i = e[o];
        t[o] = C(i)
    }))), t
};
var M = e => "function" == typeof e, P = (e, t) => new Promise(((o, i) => {
        const n = () => o(((e, {width: t, height: o, canvasMemoryLimit: i, contextOptions: n}) => {
            let r = t || e.naturalWidth, a = o || e.naturalHeight;
            r || a || (r = 300, a = 150);
            const s = r * a;
            if (i && s > i) {
                const e = Math.sqrt(i) / Math.sqrt(s);
                r = Math.floor(r * e), a = Math.floor(a * e)
            }
            const l = m("canvas");
            return l.width = r, l.height = a, l.getContext("2d", n).drawImage(e, 0, 0, r, a), l
        })(e, t));
        e.complete && e.width ? n() : (e.onload = n, e.onerror = () => i(new Error("Failed to load image")))
    })), R = () => "createImageBitmap" in window, I = e => /svg/.test(e.type),
    E = () => Math.random().toString(36).substring(2, 9);
const A = new Map;
var L = (e, t, o) => new Promise(((i, n) => {
    const r = e.toString();
    let a = A.get(r);
    if (!a) {
        const t = (e => `function () {self.onmessage = function (message) {(${e.toString()}).apply(null, message.data.content.concat([function (err, response) {\n    response = response || {};\n    const transfer = 'data' in response ? [response.data.buffer] : 'width' in response ? [response] : [];\n    return self.postMessage({ id: message.data.id, content: response, error: err }, transfer);\n}]))}}`)(e),
            o = URL.createObjectURL((e => new Blob(["(", "function" == typeof e ? e.toString() : e, ")()"], {type: "application/javascript"}))(t)),
            i = new Map, n = new Worker(o);
        a = {
            url: o, worker: n, messages: i, terminationTimeout: void 0, terminate: () => {
                clearTimeout(a.terminationTimeout), a.worker.terminate(), URL.revokeObjectURL(o), A.delete(r)
            }
        }, n.onmessage = function (e) {
            const {id: t, content: o, error: n} = e.data;
            if (clearTimeout(a.terminationTimeout), a.terminationTimeout = setTimeout((() => {
                i.size > 0 || a.terminate()
            }), 500), !i.has(t)) return;
            const r = i.get(t);
            i.delete(t), null != n ? r.reject(n) : r.resolve(o)
        }, A.set(r, a)
    }
    const s = E();
    a.messages.set(s, {resolve: i, reject: n}), a.worker.postMessage({id: s, content: t}, o)
}));
let F = null;
var z = () => (null === F && (F = y(/Firefox/)), F);
const D = async (e, t) => {
    const o = await (async (e, t) => {
        const o = m("img", {src: URL.createObjectURL(e)}), i = await P(o, t);
        return URL.revokeObjectURL(o.src), i
    })(e, {canvasMemoryLimit: t, contextOptions: {willReadFrequently: !0}}), i = u(o);
    return $(o), i
};
var B = async (e, t) => {
    if (x() && !z()) return await D(e, t);
    let o;
    if (R() && !I(e) && "OffscreenCanvas" in window) try {
        o = await L(((e, t, o) => {
            createImageBitmap(e).then((e => {
                let i = e.width, n = e.height;
                const r = i * n;
                if (t && r > t) {
                    const e = Math.sqrt(t) / Math.sqrt(r);
                    i = Math.floor(i * e), n = Math.floor(n * e)
                }
                const a = new OffscreenCanvas(i, n), s = a.getContext("2d", {willReadFrequently: !0});
                s.drawImage(e, 0, 0, i, n);
                const l = s.getImageData(0, 0, a.width, a.height);
                o(null, l)
            })).catch((e => {
                o(e)
            }))
        }), [e, t])
    } catch (e) {
    }
    return o && o.width ? o : await D(e, t)
}, O = (e, t, o) => new Promise(((i, n) => {
    try {
        e.toBlob((e => {
            if (!e) return n(new Error("Failed to create blob"));
            i(e)
        }), t, o)
    } catch (e) {
        n(e)
    }
})), W = async (e, t, o) => {
    const i = await w(e), n = await O(i, t, o);
    return $(i), n
};
const V = {matroska: "mkv"};
var _ = e => {
    const t = (e.match(/\/([a-z0-9]+)/) || [])[1];
    if (/^x/.test(t)) {
        const [, t = ""] = e.split("/x-");
        return V[t]
    }
    return t
}, N = e => e.substring(0, e.lastIndexOf(".")) || e;
const H = /avif|bmp|gif|jpg|jpeg|jpe|jif|jfif|png|svg|tiff|webp/;
var j = e => {
    return e && (t = (o = e, o.split(".").pop()).toLowerCase(), H.test(t) ? "image/" + (/jfif|jif|jpe|jpg/.test(t) ? "jpeg" : "svg" === t ? "svg+xml" : t) : "");
    var t, o
}, U = (e, t, i) => {
    const n = (new Date).getTime(), r = e.type.length && !/null|text/.test(e.type), a = r ? e.type : i, s = ((e, t) => {
        const o = j(e);
        if (o === t) return e;
        const i = _(t) || o;
        return `${N(e)}.${i}`
    })(t, a);
    try {
        return new (o("File"))([e], s, {lastModified: n, type: r ? e.type : a})
    } catch (t) {
        const o = r ? e.slice() : e.slice(0, e.size, a);
        return o.lastModified = n, o.name = s, o
    }
}, G = (e, t) => e / t, Z = e => e;
const X = Math.PI, Y = Math.PI / 2, q = Y / 2;
var K = e => {
    const t = Math.abs(e) % Math.PI;
    return t > q && t < Math.PI - q
};
const J = {
    Top: "t",
    Right: "r",
    Bottom: "b",
    Left: "l",
    TopLeft: "tl",
    TopRight: "tr",
    BottomRight: "br",
    BottomLeft: "bl"
}, {Top: Q, Right: ee, Bottom: te, Left: oe, TopLeft: ie, TopRight: ne, BottomRight: re, BottomLeft: ae} = J;
var se = {
    [Q]: [.5, 0],
    [ee]: [1, .5],
    [te]: [.5, 1],
    [oe]: [0, .5],
    [ie]: [0, 0],
    [ne]: [1, 0],
    [re]: [1, 1],
    [ae]: [0, 1]
}, le = (e, t = 12) => parseFloat(e.toFixed(t));
const ce = (e, t, o) => o + (e - o) * t,
    de = e => ({x: e.x + .5 * e.width, y: e.y + .5 * e.height, rx: .5 * e.width, ry: .5 * e.height}),
    ue = () => he(0, 0), he = (e, t) => ({x: e, y: t}), pe = e => he(e.pageX, e.pageY), me = e => he(e.x, e.y),
    ge = e => (e.x = -e.x, e.y = -e.y, e), $e = (e, t, o = ue()) => {
        const i = Math.cos(t), n = Math.sin(t), r = e.x - o.x, a = e.y - o.y;
        return e.x = o.x + i * r - n * a, e.y = o.y + n * r + i * a, e
    }, fe = e => Math.sqrt(e.x * e.x + e.y * e.y), ye = e => {
        const t = Math.sqrt(e.x * e.x + e.y * e.y);
        return 0 === t ? ue() : (e.x /= t, e.y /= t, e)
    }, be = (e, t) => Math.atan2(t.y - e.y, t.x - e.x), xe = (e, t) => e.x === t.x && e.y === t.y,
    ve = (e, t) => (e.x = t(e.x), e.y = t(e.y), e), we = (e, t) => (e.x += t.x, e.y += t.y, e),
    Se = (e, t) => (e.x -= t.x, e.y -= t.y, e), ke = (e, t) => (e.x /= t, e.y /= t, e),
    Ce = (e, t) => (e.x *= t, e.y *= t, e), Te = (e, t) => e.x * t.x + e.y * t.y, Me = (e, t) => e.x * t.y - e.y * t.x,
    Pe = (e, t = ue()) => {
        const o = e.x - t.x, i = e.y - t.y;
        return o * o + i * i
    }, Re = (e, t = ue()) => Math.sqrt(Pe(e, t)), Ie = (e, t, o) => (e.x = ce(e.x, t, o.x), e.y = ce(e.y, t, o.y), e),
    Ee = e => {
        let t = 0, o = 0;
        return e.forEach((e => {
            t += e.x, o += e.y
        })), he(t / e.length, o / e.length)
    }, Ae = (e, t, o, i, n) => (e.forEach((e => {
        e.x = t ? i - (e.x - i) : e.x, e.y = o ? n - (e.y - n) : e.y
    })), e), Le = (e, t, o, i) => {
        const n = Math.sin(t), r = Math.cos(t);
        return e.forEach((e => {
            e.x -= o, e.y -= i;
            const t = e.x * r - e.y * n, a = e.x * n + e.y * r;
            e.x = o + t, e.y = i + a
        })), e
    }, Fe = (e, t) => ({width: e, height: t}), ze = e => Fe(e.width, e.height), De = e => Fe(e.width, e.height),
    Be = e => Fe(e.width, e.height), Oe = e => Fe(e[0], e[1]), We = e => {
        return /img/i.test(e.nodeName) ? Fe((t = e).naturalWidth, t.naturalHeight) : De(e);
        var t
    }, Ve = (e, t) => Fe(e, t), _e = (e, t, o = Z) => o(e.width) === o(t.width) && o(e.height) === o(t.height),
    Ne = (e, t) => (e.width *= t, e.height *= t, e), He = e => he(.5 * e.width, .5 * e.height), je = (e, t) => {
        const o = Math.abs(t), i = Math.abs(Math.cos(o)), n = Math.abs(Math.sin(o)), r = i * e.width + n * e.height,
            a = n * e.width + i * e.height;
        return e.width = r, e.height = a, e
    }, Ue = (e, t) => e.width >= t.width && e.height >= t.height,
    Ge = (e, t) => (e.width = t(e.width), e.height = t(e.height), e), Ze = (e, t) => ({start: e, end: t}),
    Xe = e => Ze(me(e.start), me(e.end)), Ye = (e, t) => {
        if (0 === t) return e;
        const o = he(e.start.x - e.end.x, e.start.y - e.end.y), i = ye(o), n = Ce(i, t);
        return e.start.x += n.x, e.start.y += n.y, e.end.x -= n.x, e.end.y -= n.y, e
    }, qe = [he(-1, -1), he(-1, 1), he(1, 1), he(1, -1)], Ke = (e, t, o, i) => ({x: e, y: t, width: o, height: i}),
    Je = e => Ke(e.x, e.y, e.width, e.height), Qe = () => Ke(0, 0, 0, 0), et = e => Ke(0, 0, e.width, e.height),
    tt = e => Ke(e[3], e[0], e[1] - e[3], e[2] - e[0]), ot = e => Ke(e.x || 0, e.y || 0, e.width || 0, e.height || 0),
    it = e => {
        let t = e[0].x, o = e[0].x, i = e[0].y, n = e[0].y;
        return e.forEach((e => {
            t = Math.min(t, e.x), o = Math.max(o, e.x), i = Math.min(i, e.y), n = Math.max(n, e.y)
        })), Ke(t, i, o - t, n - i)
    }, nt = e => at(e.x - e.rx, e.y - e.ry, 2 * e.rx, 2 * e.ry),
    rt = (e, t) => Ke(e.x - .5 * t.width, e.y - .5 * t.height, t.width, t.height), at = (e, t, o, i) => Ke(e, t, o, i),
    st = e => he(e.x + .5 * e.width, e.y + .5 * e.height), lt = (e, t) => (e.x += t.x, e.y += t.y, e),
    ct = (e, t, o) => (o = o || st(e), e.x = t * (e.x - o.x) + o.x, e.y = t * (e.y - o.y) + o.y, e.width = t * e.width, e.height = t * e.height, e),
    dt = (e, t, o, i) => {
        const n = (i.x - e.x) / e.width, r = (i.y - e.y) / e.height;
        let a = Math.max(t.width, e.width), s = Math.max(t.height, e.height);
        return a = Math.min(o.width, a), s = Math.min(o.height, s), e.x = i.x - n * a, e.y = i.y - r * s, e.width = a, e.height = s, e
    }, ut = (e, t) => {
        const [o, i] = se[t], n = o * e.width, r = i * e.height;
        return he(e.x + n, e.y + r)
    }, ht = (e, t) => (e.x *= t, e.y *= t, e.width *= t, e.height *= t, e),
    pt = (e, t, o = Z) => o(e.x) === o(t.x) && o(e.y) === o(t.y) && o(e.width) === o(t.width) && o(e.height) === o(t.height),
    mt = e => G(e.width, e.height), gt = (e, t, o, i, n) => (e.x = t, e.y = o, e.width = i, e.height = n, e),
    $t = (e, t) => (e.x = t.x, e.y = t.y, e.width = t.width, e.height = t.height, e),
    ft = (e, t, o) => (o || (o = st(e)), St(e).map((e => $e(e, t, o)))),
    yt = (e, t) => Ke(.5 * e.width - .5 * t.width, .5 * e.height - .5 * t.height, t.width, t.height),
    bt = (e, t) => !(t.x < e.x) && (!(t.y < e.y) && (!(t.x > e.x + e.width) && !(t.y > e.y + e.height))),
    xt = (e, t, o = ue()) => {
        if (0 === e.width || 0 === e.height) return Qe();
        const i = mt(e);
        t || (t = i);
        let n = e.width, r = e.height;
        return t > i ? n = r * t : r = n / t, Ke(o.x + .5 * (e.width - n), o.y + .5 * (e.height - r), n, r)
    }, vt = (e, t = mt(e), o = ue()) => {
        if (0 === e.width || 0 === e.height) return Qe();
        let i = e.width, n = i / t;
        return n > e.height && (n = e.height, i = n * t), Ke(o.x + .5 * (e.width - i), o.y + .5 * (e.height - n), i, n)
    },
    wt = e => [Math.min(e.y, e.y + e.height), Math.max(e.x, e.x + e.width), Math.max(e.y, e.y + e.height), Math.min(e.x, e.x + e.width)],
    St = e => [he(e.x, e.y), he(e.x + e.width, e.y), he(e.x + e.width, e.y + e.height), he(e.x, e.y + e.height)],
    kt = (e, t) => {
        if (e) return e.x = t(e.x), e.y = t(e.y), e.width = t(e.width), e.height = t(e.height), e
    }, Ct = (e, t, o = st(e)) => St(e).map(((e, i) => {
        const n = qe[i];
        return he(ce(e.x, 1 + n.x * t.x, o.x), ce(e.y, 1 + n.y * t.y, o.y))
    })), Tt = e => (e.x = 0, e.y = 0, e), Mt = e => {
        const t = e[0], o = e[e.length - 1];
        e = xe(t, o) ? e : [...e, t];
        const i = t.x, n = t.y;
        let r, a, s, l = 0, c = 0, d = 0, u = 0;
        const h = e.length;
        for (; c < h; c++) r = e[c], a = e[c + 1 > h - 1 ? 0 : c + 1], s = (r.y - n) * (a.x - i) - (a.y - n) * (r.x - i), l += s, d += (r.x + a.x - 2 * i) * s, u += (r.y + a.y - 2 * n) * s;
        return s = 3 * l, he(i + d / s, n + u / s)
    }, Pt = (e, t) => Rt(e.start, e.end, t.start, t.end), Rt = (e, t, o, i) => {
        const n = (i.y - o.y) * (t.x - e.x) - (i.x - o.x) * (t.y - e.y);
        if (0 === n) return;
        const r = ((i.x - o.x) * (e.y - o.y) - (i.y - o.y) * (e.x - o.x)) / n,
            a = ((t.x - e.x) * (e.y - o.y) - (t.y - e.y) * (e.x - o.x)) / n;
        return r < 0 || r > 1 || a < 0 || a > 1 ? void 0 : he(e.x + r * (t.x - e.x), e.y + r * (t.y - e.y))
    }, It = (e, t, {ignoreIdenticalLines: o = !1, breakOnIntersection: i = !1} = {}) => {
        const n = t.length, r = [];
        for (let a = 0; a < n - 1; a++) {
            if (o && (xe(e.start, t[a]) || xe(e.start, t[a + 1]) || xe(e.end, t[a]) || xe(e.end, t[a + 1]))) continue;
            const n = Rt(e.start, e.end, t[a], t[a + 1]);
            if (n) {
                if (i) return [n];
                r.push(n)
            }
        }
        return r.length ? r : void 0
    }, Et = (e, t) => {
        let o = 0, i = 0, n = !1;
        const r = t.length;
        for (o = 0, i = r - 1; o < r; i = o++) t[o].y > e.y != t[i].y > e.y && e.x < (t[i].x - t[o].x) * (e.y - t[o].y) / (t[i].y - t[o].y) + t[o].x && (n = !n);
        return n
    }, At = (e, t, o, i) => ({
        x: (1 - i) * (1 - i) * e.x + 2 * (1 - i) * i * t.x + i * i * o.x,
        y: (1 - i) * (1 - i) * e.y + 2 * (1 - i) * i * t.y + i * i * o.y
    }), Lt = (e, t, o, i, n) => {
        const r = ((e, t, o, i) => {
            let n = (t.x - e.x) * i, r = (t.y - e.y) * i;
            return Re(o, t) < Re(t, e) && (n *= .15, r *= .15), {x: t.x + n, y: t.y + r}
        })(e, t, o, n), a = [];
        for (let e = 0; e <= i; e++) {
            const n = e / i;
            a.push(At(t, r, o, n))
        }
        return a
    }, Ft = e => {
        const t = [];
        for (let o = 0; o < e.length; o++) {
            let i = o + 1;
            i === e.length && (i = 0), t.push(Ze(me(e[o]), me(e[i])))
        }
        return t
    }, zt = (e, t = 0) => Ft(e).map((e => Ye(e, t))), Dt = (e, t, o, i = 0, n = !1, r = !1, a = 12) => {
        const s = [];
        for (let i = 0; i < a; i++) s.push(he(e.x + t * Math.cos(i * (2 * Math.PI) / a), e.y + o * Math.sin(i * (2 * Math.PI) / a)));
        return (n || r) && Ae(s, n, r, e.x, e.y), i && Le(s, i, e.x, e.y), s
    }, Bt = (e, t, o, i) => {
        const n = he(e.x - o.x, e.y - o.y), r = he(i.x - o.x, i.y - o.y), a = Te(r, r);
        let s = Te(n, r) / a;
        s = s < 0 ? 0 : s, s = s > 1 ? 1 : s;
        const l = he(r.x * s + o.x - e.x, r.y * s + o.y - e.y);
        return Te(l, l) <= t * t
    }, Ot = (e, t, o) => {
        const i = o.length;
        for (let n = 0; n < i - 1; n++) if (Bt(e, t, o[n], o[n + 1])) return !0;
        return !1
    }, Wt = (e, t, o) => !!Et(e, o) || (!!Ot(e, t, o) || Bt(e, t, o[0], o[o.length - 1])),
    Vt = (e, t, o, i, n) => Wt(e, t, ft(o, i, n || st(o)));
var _t = (e, t) => {
        const o = et(e), i = st(o), n = ft(o, t, i);
        return Tt(it(n))
    }, Nt = (e, t) => e instanceof HTMLElement && (!t || new RegExp(`^${t}$`, "i").test(e.nodeName)),
    Ht = e => e instanceof File, jt = async (e, t, o) => {
        const i = await O(e, t, o);
        return U(i, "canvas")
    }, Ut = e => e.split("/").pop().split(/\?|\#/).shift();
const Gt = l() && !!Node.prototype.replaceChildren ? (e, t) => e.replaceChildren(t) : (e, t) => {
    for (; e.lastChild;) e.removeChild(e.lastChild);
    void 0 !== t && e.append(t)
}, Zt = l() && m("div", {
    class: "PinturaMeasure",
    style: "position:absolute;left:0;top:0;width:99999px;height:0;pointer-events:none;contain:strict;margin:0;padding:0;"
});
let Xt;
var Yt = e => (Gt(Zt, e), Zt.parentNode || document.body.append(Zt), clearTimeout(Xt), Xt = setTimeout((() => {
    Zt.remove()
}), 500), e);
let qt = null;
var Kt = () => (null === qt && (qt = l() && /^((?!chrome|android).)*(safari|iphone|ipad)/i.test(navigator.userAgent)), qt),
    Jt = e => new Promise(((t, o) => {
        let i = !1;
        !e.parentNode && Kt() && (i = !0, e.style.cssText = "position:absolute;visibility:hidden;pointer-events:none;left:0;top:0;width:0;height:0;", Yt(e));
        const n = () => {
            const o = e.naturalWidth, n = e.naturalHeight;
            o && n && (i && e.remove(), clearInterval(r), t({width: o, height: n}))
        };
        e.onerror = e => {
            clearInterval(r), o(e)
        };
        const r = setInterval(n, 1);
        n()
    })), Qt = e => new Promise(((t, o) => {
        const i = () => {
            t({width: e.videoWidth, height: e.videoHeight})
        };
        if (e.readyState >= 1) return i();
        e.onloadedmetadata = i, e.onerror = () => o(e.error)
    })), eo = e => /^image/.test(e.type), to = e => new Promise((t => {
        const o = h(e) ? e : URL.createObjectURL(e), i = () => {
            const e = new Image;
            e.src = o, t(e)
        };
        if (e instanceof Blob && eo(e)) return i();
        const n = document.createElement("video");
        n.preload = "metadata", n.onloadedmetadata = () => t(n), n.onerror = i, n.src = o
    })), oo = e => "VIDEO" === e.nodeName, io = async e => {
        let t, o;
        t = e.src ? e : await to(e);
        try {
            o = oo(t) ? await Qt(t) : await Jt(t)
        } finally {
            Ht(e) && URL.revokeObjectURL(t.src)
        }
        return o
    };
var no = async e => {
        const t = await io(e), o = await (e => new Promise(((t, o) => {
            if (e.complete) return t(e);
            e.onload = () => t(e), e.onerror = () => o(new Error("Failed to load image"))
        })))(e), i = m("canvas", t);
        i.getContext("2d", {willReadFrequently: !0}).drawImage(o, 0, 0);
        const n = await O(i);
        return U(n, Ut(o.src))
    }, ro = (e = 0, t = !0) => new (o("ProgressEvent"))("progress", {loaded: 100 * e, total: 100, lengthComputable: t}),
    ao = (e, t, o = (e => e)) => e.getAllResponseHeaders().indexOf(t) >= 0 ? o(e.getResponseHeader(t)) : void 0,
    so = e => {
        if (!e) return null;
        const t = e.split(/filename=|filename\*=.+''/).splice(1).map((e => e.trim().replace(/^["']|[;"']{0,2}$/g, ""))).filter((e => e.length));
        return t.length ? decodeURI(t[t.length - 1]) : null
    };
const lo = "URL_REQUEST";

class co extends Error {
    constructor(e, t, o) {
        super(e), this.name = "EditorError", this.code = t, this.metadata = o
    }
}

var uo = (e, t) => {
    const {headers: o = {}, credentials: i} = t || {};
    Object.entries(o).forEach((([t, o]) => e.setRequestHeader(t, o))), i && (e.withCredentials = "omit" !== i)
}, ho = (e, t, o) => /^data:/.test(e) ? (async (e, t = "data-uri", o = i) => {
    o(ro(0));
    const n = await fetch(e);
    o(ro(.33));
    const r = await n.blob();
    let a;
    eo(r) || (a = "image/" + (e.includes(",/9j/") ? "jpeg" : "png")), o(ro(.66));
    const s = U(r, t, a);
    return o(ro(1)), s
})(e, void 0, t) : ((e, t, o) => new Promise(((i, n) => {
    const r = () => n(new co("Error fetching image", lo, a)), a = new XMLHttpRequest;
    a.onprogress = t, a.onerror = r, a.onload = () => {
        if (!a.response || a.status >= 300 || a.status < 200) return r();
        const t = ao(a, "Content-Type"), o = ao(a, "Content-Disposition", so) || Ut(e);
        i(U(a.response, o, t || j(o)))
    };
    const {willRequest: s} = o;
    Promise.resolve(s && s(e, {resourceType: "image"})).then((t => {
        if (!1 === t) return n("Image load rejected");
        a.open("GET", e, !0), uo(a, t), a.responseType = "blob", a.send()
    })).catch(console.error)
})))(e, t, o), po = e => e instanceof Blob && !(e instanceof File), mo = e => "close" in e, go = async (e, t, o) => {
    if (Ht(e) || po(e)) return e;
    if (h(e)) return await ho(e, t, o);
    if (Nt(e, "canvas")) return await jt(e);
    if (Nt(e, "img")) return await no(e);
    if (f(e) || mo(e)) return await jt(await w(e));
    throw new co("Invalid image source", "invalid-image-source")
};
let $o = null;
var fo = () => (null === $o && ($o = l() && /^mac/i.test(navigator.platform)), $o);
let yo = null;
var bo = () => (null === yo && (yo = l() && (y(/iPhone|iPad|iPod/) || fo() && navigator.maxTouchPoints >= 1)), yo),
    xo = async (e, t = 1) => await d() || bo() || t < 5 ? e : Ve(e.height, e.width), vo = e => /jpeg/.test(e.type),
    wo = e => {
        return "object" != typeof (t = e) || t.constructor != Object ? e : JSON.stringify(e);
        var t
    }, So = (e, t = 0, o) => (0 === t || (e.translate(o.x, o.y), e.rotate(t), e.translate(-o.x, -o.y)), e),
    ko = (e, t, o) => (e.scale(t, o), e), Co = async (e, t = {}) => {
        const {flipX: o, flipY: i, rotation: n, crop: r} = t, a = De(e), s = o || i, l = !!n,
            c = r && (r.x || r.y || r.width || r.height), d = c && pt(r, et(a)), u = c && !d;
        if (!s && !l && !u) return e;
        let h, p = m("canvas", {width: e.width, height: e.height});
        if (p.getContext("2d", {willReadFrequently: !0}).putImageData(e, 0, 0), s) {
            const e = m("canvas", {width: p.width, height: p.height}).getContext("2d", {willReadFrequently: !0});
            ko(e, o ? -1 : 1, i ? -1 : 1), e.drawImage(p, o ? -p.width : 0, i ? -p.height : 0), e.restore(), $(p), p = e.canvas
        }
        if (l) {
            const e = Ge(Be(it(ft(ot(p), n))), Math.floor),
                t = m("canvas", {width: r.width, height: r.height}).getContext("2d", {willReadFrequently: !0});
            ((e, t, o) => {
                e.translate(t, o)
            })(t, -r.x, -r.y), So(t, n, He(e)), t.drawImage(p, .5 * (e.width - p.width), .5 * (e.height - p.height)), t.restore(), $(p), p = t.canvas
        } else if (u) {
            return h = p.getContext("2d", {willReadFrequently: !0}).getImageData(r.x, r.y, r.width, r.height), $(p), h
        }
        return h = p.getContext("2d", {willReadFrequently: !0}).getImageData(0, 0, p.width, p.height), $(p), h
    }, To = (e, t) => {
        const {imageData: o, width: i, height: n} = e, r = o.width, a = o.height, s = Math.round(i), l = Math.round(n),
            c = o.data, d = new Uint8ClampedArray(s * l * 4), u = r / s, h = a / l, p = Math.ceil(.5 * u),
            m = Math.ceil(.5 * h);
        for (let e = 0; e < l; e++) for (let t = 0; t < s; t++) {
            const o = 4 * (t + e * s);
            let i = 0, n = 0, a = 0, l = 0, g = 0, $ = 0, f = 0;
            const y = (e + .5) * h;
            for (let o = Math.floor(e * h); o < (e + 1) * h; o++) {
                const e = Math.abs(y - (o + .5)) / m, s = (t + .5) * u, d = e * e;
                for (let e = Math.floor(t * u); e < (t + 1) * u; e++) {
                    let t = Math.abs(s - (e + .5)) / p;
                    const u = Math.sqrt(d + t * t);
                    if (u < -1 || u > 1) continue;
                    if (i = 2 * u * u * u - 3 * u * u + 1, i <= 0) continue;
                    t = 4 * (e + o * r);
                    const h = c[t + 3];
                    f += i * h, a += i, h < 255 && (i = i * h / 250), l += i * c[t], g += i * c[t + 1], $ += i * c[t + 2], n += i
                }
            }
            d[o] = l / n, d[o + 1] = g / n, d[o + 2] = $ / n, d[o + 3] = f / a
        }
        t(null, {data: d, width: s, height: l})
    }, Mo = e => {
        if (e instanceof ImageData) return e;
        let t;
        try {
            t = new ImageData(e.width, e.height)
        } catch (o) {
            t = m("canvas").getContext("2d").createImageData(e.width, e.height)
        }
        return t.data.set(e.data), t
    }, Po = async (e, t = {}, o) => {
        const {width: i, height: n, fit: r, upscale: a} = t;
        if (!i && !n) return e;
        let s = i, l = n;
        if (i ? n || (l = i) : s = n, "force" !== r) {
            const t = s / e.width, o = l / e.height;
            let i = 1;
            if ("cover" === r ? i = Math.max(t, o) : "contain" === r && (i = Math.min(t, o)), i > 1 && !1 === a) return e;
            s = Math.round(e.width * i), l = Math.round(e.height * i)
        }
        return s = Math.max(s, 1), l = Math.max(l, 1), e.width === s && e.height === l ? e : o ? o(e, s, l) : (e = await L(To, [{
            imageData: e,
            width: s,
            height: l
        }], [e.data.buffer]), Mo(e))
    }, Ro = (e, t) => {
        const {imageData: o, matrix: i} = e;
        if (!i) return t(null, o);
        const n = o.data, r = n.length, a = i[0], s = i[1], l = i[2], c = i[3], d = i[4], u = i[5], h = i[6], p = i[7],
            m = i[8], g = i[9], $ = i[10], f = i[11], y = i[12], b = i[13], x = i[14], v = i[15], w = i[16], S = i[17],
            k = i[18], C = i[19];
        let T = 0, M = 0, P = 0, R = 0, I = 0, E = 0, A = 0, L = 0, F = 0, z = 0, D = 0, B = 0;
        for (; T < r; T += 4) M = n[T] / 255, P = n[T + 1] / 255, R = n[T + 2] / 255, I = n[T + 3] / 255, E = M * a + P * s + R * l + I * c + d, A = M * u + P * h + R * p + I * m + g, L = M * $ + P * f + R * y + I * b + x, F = M * v + P * w + R * S + I * k + C, z = Math.max(0, E * F) + (1 - F), D = Math.max(0, A * F) + (1 - F), B = Math.max(0, L * F) + (1 - F), n[T] = 255 * Math.max(0, Math.min(1, z)), n[T + 1] = 255 * Math.max(0, Math.min(1, D)), n[T + 2] = 255 * Math.max(0, Math.min(1, B)), n[T + 3] = 255 * I;
        t(null, {data: n, width: o.width, height: o.height})
    }, Io = (e, t) => {
        const {imageData: o, matrix: i} = e;
        if (!i) return t(null, o);
        let n = i.reduce(((e, t) => e + t));
        n = n <= 0 ? 1 : n;
        const r = o.width, a = o.height, s = o.data;
        let l = 0, c = 0, d = 0;
        const u = Math.round(Math.sqrt(i.length)), h = Math.floor(u / 2);
        let p = 0, m = 0, g = 0, $ = 0, f = 0, y = 0, b = 0, x = 0, v = 0, w = 0;
        const S = new Uint8ClampedArray(r * a * 4);
        for (d = 0; d < a; d++) for (c = 0; c < r; c++) {
            for (p = 0, m = 0, g = 0, $ = 0, y = 0; y < u; y++) for (f = 0; f < u; f++) b = d + y - h, x = c + f - h, b < 0 && (b = a - 1), b >= a && (b = 0), x < 0 && (x = r - 1), x >= r && (x = 0), v = 4 * (b * r + x), w = i[y * u + f], p += s[v] * w, m += s[v + 1] * w, g += s[v + 2] * w, $ += s[v + 3] * w;
            S[l] = p / n, S[l + 1] = m / n, S[l + 2] = g / n, S[l + 3] = $ / n, l += 4
        }
        t(null, {data: S, width: r, height: a})
    }, Eo = (e, t) => {
        let {imageData: o, strength: i} = e;
        if (!i) return t(null, o);
        const n = o.width, r = o.height, a = o.data, s = (e, t) => (l = e - v, c = t - w, Math.sqrt(l * l + c * c));
        let l, c, d, u, h, p, m, g, $, f, y, b = 0, x = 0, v = .5 * n, w = .5 * r, S = s(0, 0);
        for (i > 0 ? (d = 0, u = 0, h = 0) : (i = Math.abs(i), d = 1, u = 1, h = 1), x = 0; x < r; x++) for (b = 0; b < n; b++) k = 4 * (b + x * n), C = a, T = a, M = s(b, x) * i / S, p = C[k] / 255, m = C[k + 1] / 255, g = C[k + 2] / 255, $ = C[k + 3] / 255, f = 1 - M, y = f * $ + M, T[k] = (f * $ * p + M * d) / y * 255, T[k + 1] = (f * $ * m + M * u) / y * 255, T[k + 2] = (f * $ * g + M * h) / y * 255, T[k + 3] = 255 * y;
        var k, C, T, M;
        t(null, {data: a, width: o.width, height: o.height})
    }, Ao = (e, t) => {
        const {imageData: o, level: i, monochrome: n = !1} = e;
        if (!i) return t(null, o);
        const r = o.data, a = r.length;
        let s, l, c, d = 0;
        const u = () => 255 * (2 * Math.random() - 1) * i, h = n ? () => {
            const e = u();
            return [e, e, e]
        } : () => [u(), u(), u()];
        for (; d < a; d += 4) [s, l, c] = h(), r[d] = r[d] + s, r[d + 1] = r[d + 1] + l, r[d + 2] = r[d + 2] + c;
        t(null, {data: r, width: o.width, height: o.height})
    }, Lo = (e, t) => {
        const {imageData: o, level: i} = e;
        if (!i) return t(null, o);
        const n = o.data, r = n.length;
        let a, s, l, c = 0;
        for (; c < r; c += 4) a = n[c] / 255, s = n[c + 1] / 255, l = n[c + 2] / 255, n[c] = 255 * Math.pow(a, i), n[c + 1] = 255 * Math.pow(s, i), n[c + 2] = 255 * Math.pow(l, i);
        t(null, {data: n, width: o.width, height: o.height})
    }, Fo = async (e, t = {}) => {
        const {colorMatrix: o, convolutionMatrix: i, gamma: n, noise: r, vignette: a} = t, s = [];
        if (i && s.push([Io, {matrix: i.clarity}]), n > 0 && s.push([Lo, {level: 1 / n}]), o && !(e => {
            const t = e.length;
            let o;
            const i = t >= 20 ? 6 : t >= 16 ? 5 : 3;
            for (let n = 0; n < t; n++) {
                if (o = e[n], 1 === o && n % i != 0) return !1;
                if (0 !== o && 1 !== o) return !1
            }
            return !0
        })(o) && s.push([Ro, {matrix: o}]), (r > 0 || r < 0) && s.push([Ao, {level: r}]), (a > 0 || a < 0) && s.push([Eo, {strength: a}]), !s.length) return e;
        const l = (e, t) => `(err, imageData) => {\n            (${e[t][0].toString()})(Object.assign({ imageData: imageData }, filterInstructions[${t}]), \n                ${e[t + 1] ? l(e, t + 1) : "done"})\n        }`,
            c = `function (options, done) {\n        const filterInstructions = options.filterInstructions;\n        const imageData = options.imageData;\n        (${l(s, 0)})(null, imageData)\n    }`;
        return e = await L(c, [{imageData: e, filterInstructions: s.map((e => e[1]))}], [e.data.buffer]), Mo(e)
    }, zo = e => "number" == typeof e,
    Do = e => h(e) && null !== e.match(/(?:[\u2700-\u27bf]|(?:\ud83c[\udde6-\uddff]){2}|[\ud800-\udbff][\udc00-\udfff]|[\u0023-\u0039]\ufe0f?\u20e3|\u3299|\u3297|\u303d|\u3030|\u24c2|\ud83c[\udd70-\udd71]|\ud83c[\udd7e-\udd7f]|\ud83c\udd8e|\ud83c[\udd91-\udd9a]|\ud83c[\udde6-\uddff]|\ud83c[\ude01-\ude02]|\ud83c\ude1a|\ud83c\ude2f|\ud83c[\ude32-\ude3a]|\ud83c[\ude50-\ude51]|\u203c|\u2049|[\u25aa-\u25ab]|\u25b6|\u25c0|[\u25fb-\u25fe]|\u00a9|\u00ae|\u2122|\u2139|\ud83c\udc04|[\u2600-\u26FF]|\u2b05|\u2b06|\u2b07|\u2b1b|\u2b1c|\u2b50|\u2b55|\u231a|\u231b|\u2328|\u23cf|[\u23e9-\u23f3]|[\u23f8-\u23fa]|\ud83c\udccf|\u2934|\u2935|[\u2190-\u21ff])/g),
    Bo = (e, t) => e.hasOwnProperty(t), Oo = e => Array.isArray(e);
let Wo = 64, Vo = 102, _o = 112, No = !1;
var Ho = (e, t) => (!No && l() && (/^win/i.test(navigator.platform) && (Vo = 103), (bo() || fo()) && (Wo = 63.5, Vo = 110, _o = 123), No = !0), `<svg${t ? ` aria-label="${t}"` : ""} width="128" height="128" viewBox="0 0 128 128" preserveAspectRatio="xMinYMin meet" xmlns="http://www.w3.org/2000/svg"><text x="${Wo}" y="${Vo}" alignment-baseline="text-top" dominant-baseline="text-top" text-anchor="middle" font-size="${_o}px">${e}</text></svg>`),
    jo = e => e instanceof Blob, Uo = (e, t) => e / t * 100 + "%",
    Go = e => `rgba(${Math.round(255 * e[0])}, ${Math.round(255 * e[1])}, ${Math.round(255 * e[2])}, ${zo(e[3]) ? e[3] : 1})`,
    Zo = e => Object.values(e).join("_");
const Xo = async (e, t = 0) => {
    const o = m("canvas", {width: 80, height: 80}).getContext("2d");
    return await ((e = 0) => new Promise((t => {
        setTimeout(t, e)
    })))(t), o.drawImage(e, 0, 0, 80, 80), !((e => !new Uint32Array(e.getImageData(0, 0, e.canvas.width, e.canvas.height).data.buffer).some((e => 0 !== e)))(o) && t <= 256) || await Xo(e, t + 16)
}, Yo = new Map;
var qo = e => new Promise(((t, o) => {
    const i = new FileReader;
    i.onerror = () => o(i.error), i.onload = () => t(i.result), i.readAsDataURL(e)
})), Ko = () => {
    let e = [];
    return {
        sub: (t, o) => (e.push({
            event: t,
            callback: o
        }), () => e = e.filter((e => e.event !== t || e.callback !== o))), pub: (t, o) => {
            e.filter((e => e.event === t)).forEach((e => e.callback(o)))
        }
    }
};
const Jo = 32, Qo = ({
                         color: e = [0, 0, 0],
                         fontSize: t = 16,
                         fontFamily: o = "sans-serif",
                         fontVariant: i = "normal",
                         fontWeight: n = "normal",
                         fontStyle: r = "normal",
                         textAlign: a = "left",
                         letterSpacing: s = "normal",
                         lineHeight: l = 20
                     }, c = 1) => `font-size:${t * c}px;font-style:${r};font-weight:${n};font-family:${o};font-variant:${i};line-height:${l * c}px;text-align:${a};letter-spacing:${zo(s) ? s + "px" : "normal"};color:${Go(e)};`,
    ei = (e, t, o = 1) => {
        const {width: i, height: n, disableNewline: r} = t, a = !i,
            s = !1 === r ? ((e = "") => e.split("\n").length)(e) : void 0, l = a ? "normal" : "break-word",
            c = a && !s ? "nowrap" : "pre-line";
        return `max-width:none;min-width:auto;width:${a ? "auto" : i * o + "px"};height:${n ? n * o + "px" : "auto"};margin-top:0;margin-bottom:0;padding-top:${(({
                                                                                                                                                                      fontSize: e = 16,
                                                                                                                                                                      lineHeight: t = 20
                                                                                                                                                                  } = {}) => .5 * Math.max(0, e - t))(t) * o}px;word-break:${l};word-wrap:normal;white-space:${c};`
    }, ti = new Map, oi = e => {
        const t = [];
        for (const o of Array.from(e.childNodes)) o.nodeType === Node.TEXT_NODE ? t.push(ni(o)) : t.push(...oi(o));
        return t
    }, ii = "pointer-events:none;visibility:hidden;position:absolute;left:0;top:0;", ni = e => {
        const t = e.nodeValue;
        if (!t) return [];
        const o = t.length, i = document.createRange();
        i.selectNodeContents(e);
        const n = [];
        for (let r = 0; r < o; r++) {
            i.setStart(e, 0), i.setEnd(e, r + 1);
            const o = i.getClientRects().length - 1, a = t.charAt(r);
            n[o] ? n[o] += a : n.push(a)
        }
        const r = i.getClientRects();
        return n.map(((e, t) => ({rect: r[t], text: e})))
    }, ri = new Map, ai = (e = "", t) => {
        const {width: o = 0, height: i = 0} = t;
        if (o && i) return Ve(o, i);
        let {
            fontSize: n = 16,
            fontFamily: r,
            lineHeight: a = 20,
            fontWeight: s,
            fontStyle: l,
            fontVariant: c,
            letterSpacing: d
        } = t;
        const u = Zo({
            text: e,
            fontFamily: r,
            fontWeight: s,
            fontStyle: l,
            fontVariant: c,
            fontSize: n,
            letterSpacing: d,
            lineHeight: a,
            width: o
        });
        let h = ri.get(u);
        if (h) return h;
        let p = 1;
        n > 1e3 && z() && (p = n / 1e3, n = 1e3, a /= p);
        const g = Yt(m("pre", {
            contenteditable: "true",
            spellcheck: "false",
            style: `${ii}${Qo({...t, fontSize: n, lineHeight: a})};${ei(e, t)}"`,
            innerHTML: e
        })).getBoundingClientRect();
        return h = De(g), h = Ge(h, (e => e * p)), o && (h.width = o), ri.set(u, h), h
    }, si = new Map, li = (e, t) => new Promise(((o, i) => {
        let n = si.get(e);
        void 0 === n && (n = ((e, t) => {
            const {sub: o, pub: i} = Ko();
            let n, r;
            return Promise.resolve(t && t(e, {resourceType: "stylesheet"})).then((t => {
                if (!1 === t) return r = "requestPrevented", i("error", r);
                const {headers: o, credentials: a} = t || {};
                fetch(e, {headers: o, credentials: a}).then((e => e.text())).then((e => {
                    n = e, i("load", n)
                })).catch((e => {
                    r = e, i("error", r)
                }))
            })), {sub: (e, t) => "load" === e && n ? t(n) : "error" === e && r ? t(r) : void o(e, t)}
        })(e, t), si.set(e, n)), n.sub("load", o), n.sub("error", i)
    })), ci = async (e, t, o) => {
        let i;
        try {
            i = await li(e, t)
        } catch (e) {
            return []
        }
        const n = {innerHTML: i, id: E()};
        o && (n.nonce = o);
        const r = m("style", n);
        document.head.append(r);
        const a = Array.from(document.styleSheets).find((e => e.ownerNode.id === r.id));
        return r.remove(), Array.from(a.cssRules)
    }, di = new Map, ui = async (e, t, o) => {
        if (di.has(e.href)) return di.get(e.href);
        let i;
        try {
            i = Array.from(e.cssRules);
            for (const e of (e => e.filter((e => e instanceof CSSImportRule)))(i)) {
                const n = e.href;
                if (di.has(n)) {
                    const e = di.get(n);
                    i = [...i, ...e];
                    continue
                }
                const r = await ci(n, t, o);
                di.set(n, r), i = [...i, ...r]
            }
        } catch (n) {
            const r = e.href;
            i = await ci(r, t, o), di.set(r, i)
        }
        return (e => e.filter((e => e instanceof CSSFontFaceRule)))(i)
    }, hi = (e, t) => e.style.getPropertyValue(t), pi = (e, t) => {
        if (!e.style) return !1;
        return hi(e, "font-family").replace(/^"|"$/g, "") == t
    }, mi = async (e, t, o) => {
        const i = ((e, t) => {
            const o = [];
            for (const i of e) pi(i, t) && o.push(i);
            return o
        })(await (async (e, t) => {
            const o = Array.from(document.styleSheets).map((o => ui(o, e, t))), i = await Promise.all(o), n = [];
            return i.forEach((e => n.push(...e))), n
        })(t, o), e);
        return i.length ? i.map((e => {
            const t = e.parentStyleSheet && e.parentStyleSheet.href && new URL(e.parentStyleSheet.href),
                o = t ? t.origin + (e => e.pathname.split("/").slice(0, -1).join("/"))(t) + "/" : "",
                i = e.style.getPropertyValue("src").match(/url\("?(.*?)"?\)/)[1],
                n = Array.from(e.style).filter((e => "src" != e)).reduce(((t, o) => t += o + ":" + hi(e, o) + ";"), "");
            return [/^http/.test(i) ? i : o + i, n]
        })) : []
    }, gi = new Map, $i = new Map;
var fi = async (e = "", t) => {
    if (!e.length) return;
    let {
        color: o,
        imageWidth: i = 300,
        imageHeight: n = 150,
        paddingTop: r = 0,
        paddingRight: a = Jo,
        paddingBottom: s = 0,
        paddingLeft: l = Jo,
        fontFamily: c,
        fontSize: d,
        pixelRatio: u = 1,
        willRequest: h,
        outline: p,
        blur: m,
        styleNonce: g
    } = t, $ = 1, f = "";
    d > 1e3 && z() && ($ = d / 1e3, f = `transform-origin:0 0;transform:scale(${$})`);
    const y = u / $, b = (i + l + a) * u, x = (n + s + r) * u, v = await (async (e, t, o) => {
        if (gi.get(e)) return;
        let i = $i.get(e);
        if (!i) {
            const r = await mi(e, t, o);
            if (!r.length) return void gi.set(e, !0);
            const a = [];
            for (const [e, t] of r) {
                const o = await fetch(e).then((e => e.blob())),
                    i = !(n = o.type) || /woff2/.test(n) ? "woff2" : /woff/.test(n) ? "woff" : /ttf|truetype/.test(n) ? "truetype" : /otf|opentype/.test(n) ? "opentype" : /svg/.test(n) ? "svg" : "woff2",
                    r = await qo(o);
                a.push(`@font-face { src:url(${r}) format('${i}');${t};font-display:block; }`)
            }
            i = a.join(""), $i.set(e, i)
        }
        var n;
        return i
    })(c, h, g);
    let w = "";
    v && (w = `<style${g ? ` nonce="${g}"` : ""}>${v}</style>`);
    const S = e.replace(/%/g, "%25").replace(/#/g, "%23").replace(/&nbsp;/g, " ").replace(/&(?!#\d{4};|[a-z]+;)/gi, "&amp;").replace(/<br>|\n/g, "<br/>"),
        k = `top:${r * y}px;right:${a * y}px;bottom:${s * y}px;left:${l * y}px`;
    let C = o, T = "", M = "";
    if (p || m) {
        const e = Go(o);
        p && (C = [0, 0, 0, 0], T = `-webkit-text-stroke: ${2 * p * y}px ${e}`), m && (Kt() ? M = `filter:blur(${m * y * .4}px)` : (C = [0, 0, 0, 0], M = `text-shadow: 0 0 ${m * y}px ${e}`))
    }
    return ((e, {safariCacheKey: t = "*"} = {}) => new Promise(((o, i) => {
        const n = new Image;
        n.onerror = () => i(new Error("Failed to load SVG")), n.onload = () => {
            if (!Kt() || !e.includes("@font-face") || Yo.has(t)) return o(n);
            Xo(n).then((() => {
                Yo.set(t, !0), o(n)
            }))
        }, n.src = "data:image/svg+xml," + e
    })))(`<svg xmlns="http://www.w3.org/2000/svg" width="${b}" height="${x}" viewBox="0 0 ${b} ${x}"><foreignObject x="0" y="0" width="${b}" height="${x}"><div xmlns="http://www.w3.org/1999/xhtml">${w}<pre contenteditable="true" spellcheck="false" style="position:absolute;${k};${Qo({
        ...t,
        color: C,
        fontSize: d
    }, y)};${ei(e, t, y)};${f};${T};${M}">${S}</pre></div></foreignObject></svg>`, {safariCacheKey: c})
};
const yi = e => {
        const t = {...e};
        return T(t)
    }, bi = (e, t = {}) => {
        const o = mt(e);
        let i, n;
        const r = t.width || t.rx, a = t.height || t.ry;
        if (r && a) return ze(t);
        if (r || a) {
            i = parseFloat(r || Number.MAX_SAFE_INTEGER), n = parseFloat(a || Number.MAX_SAFE_INTEGER);
            const e = Math.min(i, n);
            h(r) || h(a) ? (i = e + "%", n = e * o + "%") : (i = e, n = e)
        } else {
            const e = 10;
            i = e + "%", n = e * o + "%"
        }
        return {
            [(t.width ? "width" : t.rx ? "rx" : void 0) || "width"]: i,
            [(t.width ? "height" : t.rx ? "ry" : void 0) || "height"]: n
        }
    }, xi = (e, t = {}) => {
        return {
            width: void 0,
            height: void 0, ...t,
            aspectRatio: 1,
            backgroundImage: (o = Ho(e), "data:image/svg+xml," + o.replace("<", "%3C").replace(">", "%3E"))
        };
        var o
    }, vi = (e, t = {}) => ({
        backgroundColor: [0, 0, 0, 0], ...Ri(t) ? {} : {
            width: void 0,
            height: void 0,
            aspectRatio: void 0
        }, ...t, backgroundImage: h(e) ? e : jo(e) ? URL.createObjectURL(e) : e
    }), wi = (e, t) => {
        let o;
        if (h(e) || jo(e)) {
            const i = {...bi(t), backgroundSize: "contain"};
            o = Do(e) ? xi(e, i) : vi(e, i)
        } else if (e.src) {
            const i = bi(t, e.shape || e), n = {...e.shape, ...i};
            if (e.width && e.height && !Bo(n, "aspectRatio")) {
                const e = wn(i, "width", t), o = wn(i, "height", t);
                n.aspectRatio = G(e, o)
            }
            n.backgroundSize || e.shape || e.width && e.height || (n.backgroundSize = "contain"), o = Do(e.src) ? xi(e.src, n) : vi(e.src, n)
        } else e.shape && (o = yi(e.shape));
        return Bo(o, "backgroundImage") && (Bo(o, "backgroundColor") || (o.backgroundColor = [0, 0, 0, 0]), Bo(o, "disableStyle") || (o.disableStyle = ["cornerRadius", "backgroundColor", "strokeColor", "strokeWidth"])), t ? xn(o, t) : o
    }, Si = e => he(e.x1, e.y1), ki = e => he(e.x2, e.y2), Ci = e => Bo(e, "text"),
    Ti = e => Ci(e) && !(Wi(e) || Bo(e, "width")), Mi = e => Ci(e) && (Wi(e) || Bo(e, "width")),
    Pi = e => !Ci(e) && Vi(e), Ri = e => Bo(e, "rx"), Ii = e => Bo(e, "x1"), Ei = e => Bo(e, "points"),
    Ai = e => Ci(e) && e.isEditing, Li = e => !Bo(e, "opacity") || e.opacity > 0, Fi = e => e.isSelected,
    zi = e => e.isEditing, Di = e => e._isDraft, Bi = e => Bo(e, "width") && Bo(e, "height"), Oi = e => {
        const t = Bo(e, "right"), o = Bo(e, "bottom");
        return t || o
    }, Wi = e => (Bo(e, "x") || Bo(e, "left")) && Bo(e, "right") || (Bo(e, "y") || Bo(e, "top")) && Bo(e, "bottom"),
    Vi = e => Bi(e) || Wi(e), _i = e => (e._isDraft = !0, e), Ni = e => (e._isDraft = !1, e),
    Hi = (e, t) => !0 !== e.disableStyle && (!Oo(e.disableStyle) || !t || !e.disableStyle.includes(t)),
    ji = e => !0 !== e.disableSelect, Ui = e => !0 !== e.disableRemove, Gi = e => !0 !== e.disableDuplicate && Qi(e),
    Zi = e => !e.disableFlip && (!Di(e) && !Oi(e) && (e => Bo(e, "backgroundImage") || Bo(e, "text"))(e)),
    Xi = (e, t) => !!Ci(e) && (!0 !== e.disableInput && (M(e.disableInput) ? e.disableInput(null != t ? t : e.text) : t || !0)),
    Yi = (e, t) => !0 !== e.disableTextLayout && (!Oo(e.disableTextLayout) || !t || !e.disableTextLayout.includes(t)),
    qi = e => Ki(e) && e.points.length > 3,
    Ki = e => !!Ei(e) && (void 0 !== e.disableAddPoints && !0 !== e.disableAddPoints),
    Ji = e => !0 !== e.disableManipulate && !Di(e) && !Oi(e), Qi = e => Ji(e) && !0 !== e.disableMove,
    en = e => (delete e.left, delete e.right, delete e.top, delete e.bottom, e), tn = e => (delete e.rotation, e),
    on = e => (e.strokeWidth = e.strokeWidth || 1, e.strokeColor = e.strokeColor || [0, 0, 0], e),
    nn = e => (e.backgroundColor = e.backgroundColor ? e.backgroundColor : e.strokeWidth || e.backgroundImage ? void 0 : [0, 0, 0], e),
    rn = e => {
        let t = e.text;
        t = t.replace(/&(#[0-9]+|[a-z]+);/gi, ((e, t) => `___${t}___`)), t = t.replace(/&/, "&amp;"), e.text = t.replace(/___(#[0-9]+|[a-z]+)___/gi, ((e, t) => `&${t};`))
    }, an = e => {
        if (!e.textShadow) return e;
        const [t, o, i, n] = e.textShadow;
        return e.textShadowX = t, e.textShadowY = o, e.textShadowBlur = i, e.textShadowColor = n, delete e.textShadow, e
    }, sn = e => {
        if (!e.textOutline) return e;
        const [t, o] = e.textOutline;
        e.textOutlineWidth = t, e.textOutlineColor = o, delete e.textOutline
    },
    ln = e => (e.fontSize = e.fontSize || "4%", e.fontFamily = e.fontFamily || "sans-serif", e.fontWeight = e.fontWeight || "normal", e.fontStyle = e.fontStyle || "normal", e.fontVariant = e.fontVariant || "normal", e.lineHeight = e.lineHeight || "120%", e.color = e.color || [0, 0, 0], e.format = "html" === e.format ? "html" : "text", an(e), sn(e), "html" === e.format ? rn(e) : (e => {
        rn(e);
        let t = e.text;
        t = t.replace(/</g, "&gt;"), t = t.replace(/>/g, "&lt;"), e.text = t
    })(e), Ti(e) ? cn(e) : dn(e)),
    cn = e => (!1 !== e.disableNewline && (delete e.textAlign, e.text = e.text.replace(/\n/g, " ")), en(e)),
    dn = e => (e.textAlign = e.textAlign || "left", e), un = e => ((e => {
        h(e.id) || (e.id = E()), Bo(e, "rotation") || (e.rotation = 0), Bo(e, "opacity") || (e.opacity = 1), Bo(e, "disableErase") || (e.disableErase = !0)
    })(e), Ci(e) ? ln(e) : Pi(e) ? (e => {
        e.cornerRadius = e.cornerRadius || 0, e.strokeWidth = e.strokeWidth || 0, e.strokeColor = e.strokeColor || [0, 0, 0], nn(e)
    })(e) : Ei(e) ? (e => {
        on(e), tn(e), Bo(e, "pathClose") || (e.disableResize = !0, Bo(e, "disableMove") || (e.disableMove = !0)), en(e)
    })(e) : Ii(e) ? (e => {
        on(e), e.lineStart = e.lineStart || void 0, e.lineEnd = e.lineEnd || void 0, tn(e), en(e)
    })(e) : Ri(e) && (e => {
        e.strokeWidth = e.strokeWidth || 0, e.strokeColor = e.strokeColor || [0, 0, 0], nn(e)
    })(e), e),
    hn = e => Ci(e) ? "text" : Pi(e) ? "rectangle" : Ei(e) ? "path" : Ii(e) ? "line" : Ri(e) ? "ellipse" : void 0,
    pn = (e, t) => parseFloat(e) / 100 * t,
    mn = new RegExp(/^x|left|right|^width|rx|fontSize|eraseRadius|feather|cornerRadius|strokeWidth|strokeDash/, "i"),
    gn = new RegExp(/^y|top|bottom|^height|ry/, "i"), $n = (e, t, {width: o, height: i}) => {
        if (Array.isArray(t)) return t.map((t => (k(t) && bn(t, {width: o, height: i}), h(t) && (t = $n(e, t, {
            width: o,
            height: i
        })), t)));
        if ("string" != typeof t) return t;
        if (!t.endsWith("%")) return t;
        const n = parseFloat(t) / 100;
        return mn.test(e) ? le(o * n, 6) : gn.test(e) ? le(i * n, 6) : t
    }, fn = $n, yn = ["lineHeight", "textOutlineWidth", "textShadowX", "textShadowY", "textShadowBlur"], bn = (e, t) => {
        Object.entries(e).map((([o, i]) => {
            e[o] = $n(o, i, t)
        })), e.text && yn.filter((t => h(e[t]))).forEach((t => {
            var o, i;
            e[t] = (o = e[t], i = e.fontSize, Math.round(i * (parseFloat(o) / 100)))
        }))
    }, xn = (e, t) => (bn(e, t), Mn(e, t), e), vn = (e, t) => {
        let o;
        return /^x|width|rx|fontSize|strokeWidth|cornerRadius/.test(e) ? o = t.width : /^y|height|ry/.test(e) && (o = t.height), o
    },
    wn = (e, t, o) => Array.isArray(e[t]) ? e[t].map((e => Object.entries(e).reduce(((e, [t, i]) => (e[t] = h(i) ? pn(i, vn(t, o)) : i, e)), {}))) : h(e[t]) ? pn(e[t], vn(t, o)) : e[t],
    Sn = (e, t, o) => t.reduce(((t, i) => {
        const n = wn(e, i, o);
        return t[i] = n, t
    }), {}), kn = (e, t, o) => (Object.keys(t).forEach((i => ((e, t, o, i) => {
        if (!h(e[t])) return e[t] = o, e;
        const n = vn(t, i);
        return e[t] = void 0 === n ? o : Uo(o, n), e
    })(e, i, t[i], o))), e), Cn = (e, t) => {
        const o = e.filter((e => e.x < 0 || e.y < 0 || e.x1 < 0 || e.y1 < 0)).reduce(((e, t) => {
            const [o, i, n, r] = (e => {
                const t = Qe(), o = e.strokeWidth || 0;
                if (Pi(e)) t.x = e.x - .5 * o, t.y = e.y - .5 * o, t.width = e.width + o, t.height = e.height + o; else if (Ii(e)) {
                    const {x1: i, y1: n, x2: r, y2: a} = e, s = Math.abs(Math.min(i, r)), l = Math.abs(Math.max(i, r)),
                        c = Math.abs(Math.min(n, a)), d = Math.abs(Math.min(n, a));
                    t.x = s + .5 * o, t.y = l + .5 * o, t.width = l - s + o, t.height = d - c + o
                } else Ri(e) && (t.x = e.x - e.rx + .5 * o, t.y = e.y - e.ry + .5 * o, t.width = 2 * e.rx + o, t.height = 2 * e.ry + o);
                return t && Bo(e, "rotation") && ft(t, e.rotation), wt(t)
            })(t);
            return e.top = Math.min(o, e.top), e.left = Math.min(r, e.left), e.bottom = Math.max(n, e.bottom), e.right = Math.max(i, e.right), e
        }), {top: 0, right: 0, bottom: 0, left: 0});
        return o.right > 0 && (o.right -= t.width), o.bottom > 0 && (o.bottom -= t.height), o
    }, Tn = (e, t, o) => {
        const i = yi(e);
        xn(i, t);
        const n = o(i);
        return Array.isArray(n) ? n : [n]
    }, Mn = (e, t) => {
        if (Bo(e, "left") && (e.x = e.left), Bo(e, "right") && !h(e.right)) {
            const o = t.width - e.right;
            Bo(e, "left") ? (e.x = e.left, e.width = Math.max(0, o - e.left)) : Bo(e, "width") && (e.x = o - e.width)
        }
        if (Bo(e, "top") && (e.y = e.top), Bo(e, "bottom") && !h(e.bottom)) {
            const o = t.height - e.bottom;
            Bo(e, "top") ? (e.y = e.top, e.height = Math.max(0, o - e.top)) : Bo(e, "height") && (e.y = o - e.height)
        }
        return e
    }, Pn = (e, t) => (Ei(e) && e.points.filter((e => zo(e.x))).forEach((e => {
        e.x *= t, e.y *= t
    })), Ii(e) && zo(e.x1) && (e.x1 *= t, e.y1 *= t, e.x2 *= t, e.y2 *= t), zo(e.x) && zo(e.y) && (e.x *= t, e.y *= t), zo(e.width) && zo(e.height) && (e.width *= t, e.height *= t), zo(e.rx) && zo(e.ry) && (e.rx *= t, e.ry *= t), (e => zo(e.strokeWidth) && e.strokeWidth > 0)(e) && (e.strokeWidth *= t), Ci(e) && (e._scale = t, zo(e.fontSize) && (e.fontSize *= t), zo(e.lineHeight) && (e.lineHeight *= t), zo(e.width) && !zo(e.height) && (e.width *= t)), Bo(e, "cornerRadius") && zo(e.cornerRadius) && (e.cornerRadius *= t), e),
    Rn = e => {
        if (e.x1) return Re(he(e.x1, e.y1), he(e.x2, e.y2))
    }, In = e => {
        if (Pi(e)) return he(e.x + .5 * e.width, e.y + .5 * e.height);
        if (Ri(e)) return he(e.x, e.y);
        if (e.text) {
            if (Mi(e)) {
                const t = e.height || ai(e.text, e).height;
                return he(e.x + .5 * e.width, e.y + .5 * t)
            }
            const t = ai(e.text, e);
            return he(e.x + .5 * t.width, e.y + .5 * t.height)
        }
        return Ei(e) ? Ee(e.points) : Ii(e) ? Ee([Si(e), ki(e)]) : void 0
    }, En = (e, t) => {
        let o = !1;
        t.flipX && e.flipX ? o = !0 : !t.flipX && e.flipX ? o = !1 : t.flipX && !e.flipX && (o = !0);
        let i = !1;
        t.flipY && e.flipY ? i = !0 : !t.flipY && e.flipY ? i = !1 : t.flipY && !e.flipY && (i = !0);
        let n = -t.rotation;
        return !o && !i || o && i || (n = -n), {flipX: o, flipY: i, rotation: n}
    };
var An = e => /canvas/i.test(e.nodeName), Ln = (e, t) => new Promise(((o, i) => {
    let n = e, r = !1;
    const a = () => {
        r || (r = !0, M(t) && Promise.resolve().then((() => t(Ve(n.naturalWidth, n.naturalHeight)))))
    };
    if (n.src || (n = new Image, h(e) && new URL(e, location.href).origin !== location.origin && (n.crossOrigin = "anonymous"), n.src = h(e) ? e : URL.createObjectURL(e)), n.complete) return a(), o(n);
    M(t) && Jt(n).then(a).catch(i), n.onload = () => {
        a(), o(n)
    }, n.onerror = () => i(new Error("Failed to load image"))
}));
const Fn = new Map([]), zn = (e, t = {}) => new Promise(((o, n) => {
    const {onMetadata: r = i, onLoad: a = o, onError: s = n, onComplete: l = i} = t;
    let c = Fn.get(e);
    if (c || (c = {
        loading: !1,
        complete: !1,
        error: !1,
        image: void 0,
        size: void 0,
        bus: Ko()
    }, Fn.set(e, c)), c.bus.sub("meta", r), c.bus.sub("load", a), c.bus.sub("error", s), c.bus.sub("complete", l), An(e)) {
        const t = e, o = t.cloneNode();
        c.complete = !0, c.image = o, c.size = We(t)
    }
    if (c.complete) return c.bus.pub("meta", {size: c.size}), c.error ? c.bus.pub("error", c.error) : c.bus.pub("load", c.image), c.bus.pub("complete"), void (c.bus = Ko());
    c.loading || (c.loading = !0, Ln(e, (e => {
        c.size = e, c.bus.pub("meta", {size: e})
    })).then((e => {
        c.image = e, c.bus.pub("load", e)
    })).catch((e => {
        c.error = e, c.bus.pub("error", e)
    })).finally((() => {
        c.complete = !0, c.loading = !1, c.bus.pub("complete"), c.bus = Ko()
    })))
})), Dn = (e, t, o, i) => e.drawImage(t, o.x, o.x, o.width, o.height, i.x, i.y, i.width, i.height);
var Bn = async (e, t, o, i, n = Dn, r) => {
    e.save(), e.clip(), await n(e, t, o, i, r), e.restore()
};
const On = (e, t, o, i, n) => {
        const r = Je(e);
        if (i) {
            const e = kt(it(i), le);
            return e.x *= o.width, e.width *= o.width, e.y *= o.height, e.height *= o.height, {srcRect: e, destRect: r}
        }
        const a = at(0, 0, o.width, o.height);
        if ("contain" === t) {
            const t = vt(e, mt(a));
            r.width = t.width, r.height = t.height, n ? (r.x += n.x, r.y += n.y) : (r.x += t.x, r.y += t.y)
        } else if ("cover" === t) {
            const e = xt(r, a.width / a.height);
            r.width = e.width, r.height = e.height, n ? (r.x += n.x, r.y += n.y) : (r.x += e.x, r.y += e.y)
        } else t ? (r.width = t.width, r.height = t.height, n && (r.x += n.x, r.y += n.y)) : n && (r.width = o.width, r.height = o.height, r.x += n.x, r.y += n.y);
        return {srcRect: a, destRect: r}
    }, Wn = (e, t) => (t.cornerRadius > 0 ? ((e, t, o, i, n, r) => {
        i < 2 * r && (r = i / 2), n < 2 * r && (r = n / 2), e.beginPath(), e.moveTo(t + r, o), e.arcTo(t + i, o, t + i, o + n, r), e.arcTo(t + i, o + n, t, o + n, r), e.arcTo(t, o + n, t, o, r), e.arcTo(t, o, t + i, o, r), e.closePath()
    })(e, t.x, t.y, t.width, t.height, t.cornerRadius) : e.rect(t.x, t.y, t.width, t.height), e),
    Vn = (e, t) => (t.backgroundColor && e.fill(), e), _n = (e, t) => (t.strokeWidth && e.stroke(), e);
var Nn = async (e, t, o = {}) => {
    const {drawImage: i} = o;
    if (e.lineWidth = t.strokeWidth ? t.strokeWidth : 1, e.strokeStyle = t.strokeColor ? Go(t.strokeColor) : "none", e.fillStyle = t.backgroundColor ? Go(t.backgroundColor) : "none", e.globalAlpha = t.opacity, t.backgroundImage) {
        let o;
        if (o = An(t.backgroundImage) ? t.backgroundImage : await zn(t.backgroundImage), Wn(e, t), Vn(e, t), "repeat" === t.backgroundRepeat) {
            const n = t.backgroundPosition || {x: 0, y: 0}, {
                    srcRect: r,
                    destRect: a
                } = On(t, t.backgroundSize || We(o), We(o), t.backgroundCorners, {x: 0, y: 0}),
                s = document.createElement("canvas");
            s.width = a.width, s.height = a.height;
            const l = s.getContext("2d", {willReadFrequently: !1, desynchronized: !0});
            await i(l, o, r, {...a, x: 0, y: 0});
            const c = e.createPattern(s, "repeat");
            e.fillStyle = c, e.save(), e.beginPath(), e.rect(t.x + n.x, t.y + n.y, t.width - n.x, t.height - n.y), e.clip(), e.translate(a.x + n.x, a.y + n.y), e.fill(), $(s), e.restore()
        } else {
            const {srcRect: n, destRect: r} = On(t, t.backgroundSize, We(o), t.backgroundCorners, t.backgroundPosition);
            await Bn(e, o, n, r, i, {feather: t.feather})
        }
        return e.beginPath(), Wn(e, t), _n(e, t), []
    }
    return Wn(e, t), Vn(e, t), _n(e, t), []
}, Hn = async (e, t, o = {}) => new Promise((async (i, n) => {
    const {drawImage: r} = o;
    if (e.lineWidth = t.strokeWidth || 1, e.strokeStyle = t.strokeColor ? Go(t.strokeColor) : "none", e.fillStyle = t.backgroundColor ? Go(t.backgroundColor) : "none", e.globalAlpha = t.opacity, e.ellipse(t.x, t.y, t.rx, t.ry, 0, 0, 2 * Math.PI), t.backgroundColor && e.fill(), t.backgroundImage) {
        let o;
        try {
            o = await zn(t.backgroundImage)
        } catch (e) {
            n(e)
        }
        const a = at(t.x - t.rx, t.y - t.ry, 2 * t.rx, 2 * t.ry), {
            srcRect: s,
            destRect: l
        } = On(a, t.backgroundSize, We(o), t.backgroundCorners, t.backgroundPosition);
        await Bn(e, o, s, l, r), t.strokeWidth && e.stroke(), i([])
    } else t.strokeWidth && e.stroke(), i([])
})), jn = async (e, t, o) => {
    const i = zo(t.width) ? Math.floor(t.width) : void 0, n = zo(t.height) ? Math.floor(t.height) : void 0,
        r = i && n ? De(t) : ai(t.text, {...t, width: i, height: n}),
        a = {x: t.x, y: t.y, width: r.width, height: r.height};
    if (Nn(e, {...t, ...a, options: o}), !t.text.length) return [];
    const {
        textOutlineWidth: s = 0,
        textShadowX: l = 0,
        textShadowY: c = 0,
        textShadowBlur: d = 0,
        textShadowColor: u,
        outline: h,
        blur: p,
        ...m
    } = t, g = !!t.height;
    if (g && (e.rect(a.x, a.y, a.width, a.height), e.save(), e.clip()), l || c || d) {
        e.save(), e.translate(l, c);
        const r = {...a};
        g || (r.height += Jo + d), await Un(e, r, {...t, width: i, height: n}, {
            ...o,
            paddingLeft: Jo + d,
            paddingRight: Jo + d,
            paddingTop: d,
            paddingBottom: d + (g ? -1 * c : t.fontSize),
            shapeExtendedProps: {color: u, blur: d}
        }), e.restore()
    }
    if (s) {
        const r = {...a};
        g || (r.height += Jo + s), await Un(e, r, {...t, width: i, height: n}, {
            ...o,
            paddingLeft: Jo + s,
            paddingRight: Jo + s,
            paddingTop: s,
            paddingBottom: s + g ? 0 : t.fontSize,
            shapeExtendedProps: {color: t.textOutlineColor, outline: s}
        })
    }
    return g && e.restore(), await Un(e, a, {...m, width: i, height: n}, {
        ...o,
        paddingLeft: Jo,
        paddingRight: Jo,
        paddingTop: 0,
        paddingBottom: g ? 0 : t.fontSize
    }), []
};
const Un = async (e, t, o, i) => {
    const {
            willRequest: n,
            shapeExtendedProps: r,
            paddingLeft: a,
            paddingRight: s,
            paddingTop: l,
            paddingBottom: c,
            styleNonce: d
        } = i, u = zo(o.width) ? Math.floor(t.width) : void 0, h = zo(o.height) ? Math.floor(t.height) : void 0,
        p = Math.ceil(t.width), m = Math.ceil(t.height), g = await fi(o.text, {
            ...o, ...r, ...t,
            width: u,
            height: h,
            paddingLeft: a,
            paddingRight: s,
            paddingTop: l,
            paddingBottom: c,
            imageWidth: p,
            imageHeight: m,
            willRequest: n,
            styleNonce: d
        });
    e.drawImage(g, o.x - a, o.y - l, g.width, g.height)
};
var Gn = async (e, t) => new Promise((async o => {
        e.lineWidth = t.strokeWidth || 1, e.strokeStyle = t.strokeColor ? Go(t.strokeColor) : "none", e.globalAlpha = t.opacity, t.bitmap && (e.lineCap = t.strokeCap, e.lineJoin = t.strokeJoin, e.setLineDash(t.strokeDash || []));
        let i = Si(t), n = ki(t);
        e.moveTo(i.x, i.y), e.lineTo(n.x, n.y), t.strokeWidth && e.stroke(), o([])
    })), Zn = async (e, t) => new Promise(((o, i) => {
        if (t.bitmap && 1 === t.points.length) return void Hn(e, {
            x: t.points[0].x,
            y: t.points[0].y,
            rx: .5 * t.strokeWidth,
            ry: .5 * t.strokeWidth,
            backgroundColor: t.strokeColor
        }).then((() => o([])));
        e.lineWidth = t.strokeWidth || 1, e.strokeStyle = t.strokeColor ? Go(t.strokeColor) : "none", e.fillStyle = t.backgroundColor ? Go(t.backgroundColor) : "none", e.globalAlpha = t.opacity;
        const {points: n} = t;
        t.bitmap && (e.lineCap = t.strokeCap, e.lineJoin = t.strokeJoin, e.setLineDash(t.strokeDash || [])), t.pathClose && e.beginPath(), e.moveTo(n[0].x, n[0].y);
        const r = n.length;
        for (let t = 1; t < r; t++) e.lineTo(n[t].x, n[t].y);
        t.pathClose && e.closePath(), t.strokeWidth && e.stroke(), t.backgroundColor && e.fill(), o([])
    })),
    Xn = (e, t, o, i) => t || o ? (e.translate(i.x, i.y), e.scale(t ? -1 : 1, o ? -1 : 1), e.translate(-i.x, -i.y), e) : e;
const Yn = async (e, t, o) => {
    e.globalCompositeOperation = "subtract" === t.drawMode ? "destination-out" : "source-over";
    const i = In(t);
    let n;
    if (So(e, t.rotation, i), Xn(e, t.flipX, t.flipY, i), Pi(t) ? n = Nn : Ri(t) ? n = Hn : Ii(t) ? n = Gn : Ei(t) ? n = Zn : Ci(t) && (n = jn), n) {
        const i = await n(e, t, o);
        if (!i.length) return [];
        return [t, ...await qn(e, i, o)]
    }
    return []
};
var qn = async (e, t, o) => {
    let i = [];
    for (const n of t) e.save(), e.beginPath(), i = [...i, ...await Yn(e, n, o)], e.restore();
    return i
}, Kn = async (e, t = {}) => {
    const {
        shapes: o = [],
        contextBounds: n = e,
        transform: r = i,
        drawImage: a,
        willRequest: s,
        styleNonce: l,
        canvasMemoryLimit: c,
        computeShape: d = Z,
        preprocessShape: u = Z
    } = t;
    if (!o.length) return e;
    const h = m("canvas");
    h.width = n.width, h.height = n.height;
    const p = h.getContext("2d", {willReadFrequently: !0});
    p.putImageData(e, n.x || 0, n.y || 0);
    const g = o.map(yi).map(d).map(u).flat().filter(Boolean);
    r(p), await qn(p, g, {drawImage: a, canvasMemoryLimit: c, willRequest: s, styleNonce: l});
    const f = p.getImageData(0, 0, h.width, h.height);
    return $(h), f
}, Jn = async (e, t = {}) => {
    const {backgroundColor: o, backgroundImage: i} = t, n = !(!o || o && 0 === o[3]);
    if (!i && !n) return e;
    const r = m("canvas");
    r.width = e.width, r.height = e.height;
    const a = r.getContext("2d", {willReadFrequently: !0});
    if (a.putImageData(e, 0, 0), a.globalCompositeOperation = "destination-over", n && (a.fillStyle = Go(o), a.fillRect(0, 0, r.width, r.height)), i) {
        let t;
        t = An(i) ? i : await zn(i);
        const {srcRect: o, destRect: n} = On({x: 0, y: 0, width: e.width, height: e.height}, "cover", {
            width: t.width,
            height: t.height
        });
        a.drawImage(t, o.x, o.y, o.width, o.height, n.x, n.y, n.width, n.height)
    }
    const s = a.getImageData(0, 0, r.width, r.height);
    return $(r), s
}, Qn = e => e.length ? e.reduce(((e, t) => ((e, t) => {
    const o = new Array(20);
    return o[0] = e[0] * t[0] + e[1] * t[5] + e[2] * t[10] + e[3] * t[15], o[1] = e[0] * t[1] + e[1] * t[6] + e[2] * t[11] + e[3] * t[16], o[2] = e[0] * t[2] + e[1] * t[7] + e[2] * t[12] + e[3] * t[17], o[3] = e[0] * t[3] + e[1] * t[8] + e[2] * t[13] + e[3] * t[18], o[4] = e[0] * t[4] + e[1] * t[9] + e[2] * t[14] + e[3] * t[19] + e[4], o[5] = e[5] * t[0] + e[6] * t[5] + e[7] * t[10] + e[8] * t[15], o[6] = e[5] * t[1] + e[6] * t[6] + e[7] * t[11] + e[8] * t[16], o[7] = e[5] * t[2] + e[6] * t[7] + e[7] * t[12] + e[8] * t[17], o[8] = e[5] * t[3] + e[6] * t[8] + e[7] * t[13] + e[8] * t[18], o[9] = e[5] * t[4] + e[6] * t[9] + e[7] * t[14] + e[8] * t[19] + e[9], o[10] = e[10] * t[0] + e[11] * t[5] + e[12] * t[10] + e[13] * t[15], o[11] = e[10] * t[1] + e[11] * t[6] + e[12] * t[11] + e[13] * t[16], o[12] = e[10] * t[2] + e[11] * t[7] + e[12] * t[12] + e[13] * t[17], o[13] = e[10] * t[3] + e[11] * t[8] + e[12] * t[13] + e[13] * t[18], o[14] = e[10] * t[4] + e[11] * t[9] + e[12] * t[14] + e[13] * t[19] + e[14], o[15] = e[15] * t[0] + e[16] * t[5] + e[17] * t[10] + e[18] * t[15], o[16] = e[15] * t[1] + e[16] * t[6] + e[17] * t[11] + e[18] * t[16], o[17] = e[15] * t[2] + e[16] * t[7] + e[17] * t[12] + e[18] * t[17], o[18] = e[15] * t[3] + e[16] * t[8] + e[17] * t[13] + e[18] * t[18], o[19] = e[15] * t[4] + e[16] * t[9] + e[17] * t[14] + e[18] * t[19] + e[19], o
})([...e], t)), e.shift()) : [], er = (e, t) => {
    const o = e.width * e.height,
        i = t.reduce(((e, t) => (t.width > e.width && t.height > e.height && (e.width = t.width, e.height = t.height), e)), {
            width: 0,
            height: 0
        }), n = i.width * i.height;
    return ((e, t = 2) => Math.round(e * t) / t)(Math.max(.5, .5 + (1 - n / o) / 2), 5)
};

function tr() {
}

const or = e => e;

function ir(e, t) {
    for (const o in t) e[o] = t[o];
    return e
}

function nr(e) {
    return e()
}

function rr() {
    return Object.create(null)
}

function ar(e) {
    e.forEach(nr)
}

function sr(e) {
    return "function" == typeof e
}

function lr(e, t) {
    return e != e ? t == t : e !== t || e && "object" == typeof e || "function" == typeof e
}

let cr;

function dr(e, t) {
    return cr || (cr = document.createElement("a")), cr.href = t, e === cr.href
}

function ur(e, ...t) {
    if (null == e) return tr;
    const o = e.subscribe(...t);
    return o.unsubscribe ? () => o.unsubscribe() : o
}

function hr(e) {
    let t;
    return ur(e, (e => t = e))(), t
}

function pr(e, t, o) {
    e.$$.on_destroy.push(ur(t, o))
}

function mr(e, t, o, i) {
    if (e) {
        const n = gr(e, t, o, i);
        return e[0](n)
    }
}

function gr(e, t, o, i) {
    return e[1] && i ? ir(o.ctx.slice(), e[1](i(t))) : o.ctx
}

function $r(e, t, o, i) {
    if (e[2] && i) {
        const n = e[2](i(o));
        if (void 0 === t.dirty) return n;
        if ("object" == typeof n) {
            const e = [], o = Math.max(t.dirty.length, n.length);
            for (let i = 0; i < o; i += 1) e[i] = t.dirty[i] | n[i];
            return e
        }
        return t.dirty | n
    }
    return t.dirty
}

function fr(e, t, o, i, n, r) {
    if (n) {
        const a = gr(t, o, i, r);
        e.p(a, n)
    }
}

function yr(e) {
    if (e.ctx.length > 32) {
        const t = [], o = e.ctx.length / 32;
        for (let e = 0; e < o; e++) t[e] = -1;
        return t
    }
    return -1
}

function br(e) {
    const t = {};
    for (const o in e) "$" !== o[0] && (t[o] = e[o]);
    return t
}

function xr(e, t) {
    const o = {};
    t = new Set(t);
    for (const i in e) t.has(i) || "$" === i[0] || (o[i] = e[i]);
    return o
}

function vr(e, t, o) {
    return e.set(o), t
}

function wr(e) {
    return e && sr(e.destroy) ? e.destroy : tr
}

const Sr = "undefined" != typeof window;
let kr = Sr ? () => window.performance.now() : () => Date.now(), Cr = Sr ? e => requestAnimationFrame(e) : tr;
const Tr = new Set;

function Mr(e) {
    Tr.forEach((t => {
        t.c(e) || (Tr.delete(t), t.f())
    })), 0 !== Tr.size && Cr(Mr)
}

function Pr(e) {
    let t;
    return 0 === Tr.size && Cr(Mr), {
        promise: new Promise((o => {
            Tr.add(t = {c: e, f: o})
        })), abort() {
            Tr.delete(t)
        }
    }
}

function Rr(e, t) {
    e.appendChild(t)
}

function Ir(e) {
    if (!e) return document;
    const t = e.getRootNode ? e.getRootNode() : e.ownerDocument;
    return t && t.host ? t : e.ownerDocument
}

function Er(e) {
    const t = Fr("style");
    return function (e, t) {
        Rr(e.head || e, t), t.sheet
    }(Ir(e), t), t.sheet
}

function Ar(e, t, o) {
    e.insertBefore(t, o || null)
}

function Lr(e) {
    e.parentNode.removeChild(e)
}

function Fr(e) {
    return document.createElement(e)
}

function zr(e) {
    return document.createElementNS("http://www.w3.org/2000/svg", e)
}

function Dr(e) {
    return document.createTextNode(e)
}

function Br() {
    return Dr(" ")
}

function Or() {
    return Dr("")
}

function Wr(e, t, o, i) {
    return e.addEventListener(t, o, i), () => e.removeEventListener(t, o, i)
}

function Vr(e) {
    return function (t) {
        return t.preventDefault(), e.call(this, t)
    }
}

function _r(e) {
    return function (t) {
        return t.stopPropagation(), e.call(this, t)
    }
}

function Nr(e, t, o) {
    null == o ? e.removeAttribute(t) : e.getAttribute(t) !== o && e.setAttribute(t, o)
}

function Hr(e, t) {
    const o = Object.getOwnPropertyDescriptors(e.__proto__);
    for (const i in t) null == t[i] ? e.removeAttribute(i) : "style" === i ? e.style.cssText = t[i] : "__value" === i ? e.value = e[i] = t[i] : o[i] && o[i].set ? e[i] = t[i] : Nr(e, i, t[i])
}

function jr(e, t) {
    Object.keys(t).forEach((o => {
        !function (e, t, o) {
            t in e ? e[t] = "boolean" == typeof e[t] && "" === o || o : Nr(e, t, o)
        }(e, o, t[o])
    }))
}

function Ur(e, t) {
    t = "" + t, e.wholeText !== t && (e.data = t)
}

function Gr(e, t) {
    e.value = null == t ? "" : t
}

function Zr(e, t, o, i) {
    null === o ? e.style.removeProperty(t) : e.style.setProperty(t, o, i ? "important" : "")
}

function Xr(e, t, {bubbles: o = !1, cancelable: i = !1} = {}) {
    const n = document.createEvent("CustomEvent");
    return n.initCustomEvent(e, o, i, t), n
}

class Yr {
    constructor(e = !1) {
        this.is_svg = !1, this.is_svg = e, this.e = this.n = null
    }

    c(e) {
        this.h(e)
    }

    m(e, t, o = null) {
        this.e || (this.is_svg ? this.e = zr(t.nodeName) : this.e = Fr(t.nodeName), this.t = t, this.c(e)), this.i(o)
    }

    h(e) {
        this.e.innerHTML = e, this.n = Array.from(this.e.childNodes)
    }

    i(e) {
        for (let t = 0; t < this.n.length; t += 1) Ar(this.t, this.n[t], e)
    }

    p(e) {
        this.d(), this.h(e), this.i(this.a)
    }

    d() {
        this.n.forEach(Lr)
    }
}

function qr(e, t) {
    return new e(t)
}

const Kr = new Map;
let Jr, Qr = 0;

function ea(e, t, o, i, n, r, a, s = 0) {
    const l = 16.666 / i;
    let c = "{\n";
    for (let e = 0; e <= 1; e += l) {
        const i = t + (o - t) * r(e);
        c += 100 * e + `%{${a(i, 1 - i)}}\n`
    }
    const d = c + `100% {${a(o, 1 - o)}}\n}`, u = `__svelte_${function (e) {
        let t = 5381, o = e.length;
        for (; o--;) t = (t << 5) - t ^ e.charCodeAt(o);
        return t >>> 0
    }(d)}_${s}`, h = Ir(e), {stylesheet: p, rules: m} = Kr.get(h) || function (e, t) {
        const o = {stylesheet: Er(t), rules: {}};
        return Kr.set(e, o), o
    }(h, e);
    m[u] || (m[u] = !0, p.insertRule(`@keyframes ${u} ${d}`, p.cssRules.length));
    const g = e.style.animation || "";
    return e.style.animation = `${g ? g + ", " : ""}${u} ${i}ms linear ${n}ms 1 both`, Qr += 1, u
}

function ta(e, t) {
    const o = (e.style.animation || "").split(", "),
        i = o.filter(t ? e => e.indexOf(t) < 0 : e => -1 === e.indexOf("__svelte")), n = o.length - i.length;
    n && (e.style.animation = i.join(", "), Qr -= n, Qr || Cr((() => {
        Qr || (Kr.forEach((e => {
            const {ownerNode: t} = e.stylesheet;
            t && Lr(t)
        })), Kr.clear())
    })))
}

function oa(e) {
    Jr = e
}

function ia() {
    if (!Jr) throw new Error("Function called outside component initialization");
    return Jr
}

function na(e) {
    ia().$$.on_mount.push(e)
}

function ra(e) {
    ia().$$.after_update.push(e)
}

function aa(e) {
    ia().$$.on_destroy.push(e)
}

function sa() {
    const e = ia();
    return (t, o, {cancelable: i = !1} = {}) => {
        const n = e.$$.callbacks[t];
        if (n) {
            const r = Xr(t, o, {cancelable: i});
            return n.slice().forEach((t => {
                t.call(e, r)
            })), !r.defaultPrevented
        }
        return !0
    }
}

function la(e, t) {
    return ia().$$.context.set(e, t), t
}

function ca(e) {
    return ia().$$.context.get(e)
}

function da(e, t) {
    const o = e.$$.callbacks[t.type];
    o && o.slice().forEach((e => e.call(this, t)))
}

const ua = [], ha = [], pa = [], ma = [], ga = Promise.resolve();
let $a = !1;

function fa() {
    $a || ($a = !0, ga.then(ka))
}

function ya() {
    return fa(), ga
}

function ba(e) {
    pa.push(e)
}

function xa(e) {
    ma.push(e)
}

const va = new Set;
let wa, Sa = 0;

function ka() {
    const e = Jr;
    do {
        for (; Sa < ua.length;) {
            const e = ua[Sa];
            Sa++, oa(e), Ca(e.$$)
        }
        for (oa(null), ua.length = 0, Sa = 0; ha.length;) ha.pop()();
        for (let e = 0; e < pa.length; e += 1) {
            const t = pa[e];
            va.has(t) || (va.add(t), t())
        }
        pa.length = 0
    } while (ua.length);
    for (; ma.length;) ma.pop()();
    $a = !1, va.clear(), oa(e)
}

function Ca(e) {
    if (null !== e.fragment) {
        e.update(), ar(e.before_update);
        const t = e.dirty;
        e.dirty = [-1], e.fragment && e.fragment.p(e.ctx, t), e.after_update.forEach(ba)
    }
}

function Ta(e, t, o) {
    e.dispatchEvent(Xr(`${t ? "intro" : "outro"}${o}`))
}

const Ma = new Set;
let Pa;

function Ra() {
    Pa = {r: 0, c: [], p: Pa}
}

function Ia() {
    Pa.r || ar(Pa.c), Pa = Pa.p
}

function Ea(e, t) {
    e && e.i && (Ma.delete(e), e.i(t))
}

function Aa(e, t, o, i) {
    if (e && e.o) {
        if (Ma.has(e)) return;
        Ma.add(e), Pa.c.push((() => {
            Ma.delete(e), i && (o && e.d(1), i())
        })), e.o(t)
    } else i && i()
}

const La = {duration: 0};

function Fa(e, t, o, i) {
    let n = t(e, o), r = i ? 0 : 1, a = null, s = null, l = null;

    function c() {
        l && ta(e, l)
    }

    function d(e, t) {
        const o = e.b - r;
        return t *= Math.abs(o), {a: r, b: e.b, d: o, duration: t, start: e.start, end: e.start + t, group: e.group}
    }

    function u(t) {
        const {delay: o = 0, duration: i = 300, easing: u = or, tick: h = tr, css: p} = n || La,
            m = {start: kr() + o, b: t};
        t || (m.group = Pa, Pa.r += 1), a || s ? s = m : (p && (c(), l = ea(e, r, t, i, o, u, p)), t && h(0, 1), a = d(m, i), ba((() => Ta(e, t, "start"))), Pr((t => {
            if (s && t > s.start && (a = d(s, i), s = null, Ta(e, a.b, "start"), p && (c(), l = ea(e, r, a.b, a.duration, 0, u, n.css))), a) if (t >= a.end) h(r = a.b, 1 - r), Ta(e, a.b, "end"), s || (a.b ? c() : --a.group.r || ar(a.group.c)), a = null; else if (t >= a.start) {
                const e = t - a.start;
                r = a.a + a.d * u(e / a.duration), h(r, 1 - r)
            }
            return !(!a && !s)
        })))
    }

    return {
        run(e) {
            sr(n) ? (wa || (wa = Promise.resolve(), wa.then((() => {
                wa = null
            }))), wa).then((() => {
                n = n(), u(e)
            })) : u(e)
        }, end() {
            c(), a = s = null
        }
    }
}

const za = "undefined" != typeof window ? window : "undefined" != typeof globalThis ? globalThis : global;

function Da(e, t) {
    e.d(1), t.delete(e.key)
}

function Ba(e, t) {
    Aa(e, 1, 1, (() => {
        t.delete(e.key)
    }))
}

function Oa(e, t, o, i, n, r, a, s, l, c, d, u) {
    let h = e.length, p = r.length, m = h;
    const g = {};
    for (; m--;) g[e[m].key] = m;
    const $ = [], f = new Map, y = new Map;
    for (m = p; m--;) {
        const e = u(n, r, m), s = o(e);
        let l = a.get(s);
        l ? i && l.p(e, t) : (l = c(s, e), l.c()), f.set(s, $[m] = l), s in g && y.set(s, Math.abs(m - g[s]))
    }
    const b = new Set, x = new Set;

    function v(e) {
        Ea(e, 1), e.m(s, d), a.set(e.key, e), d = e.first, p--
    }

    for (; h && p;) {
        const t = $[p - 1], o = e[h - 1], i = t.key, n = o.key;
        t === o ? (d = t.first, h--, p--) : f.has(n) ? !a.has(i) || b.has(i) ? v(t) : x.has(n) ? h-- : y.get(i) > y.get(n) ? (x.add(i), v(t)) : (b.add(n), h--) : (l(o, a), h--)
    }
    for (; h--;) {
        const t = e[h];
        f.has(t.key) || l(t, a)
    }
    for (; p;) v($[p - 1]);
    return $
}

function Wa(e, t) {
    const o = {}, i = {}, n = {$$scope: 1};
    let r = e.length;
    for (; r--;) {
        const a = e[r], s = t[r];
        if (s) {
            for (const e in a) e in s || (i[e] = 1);
            for (const e in s) n[e] || (o[e] = s[e], n[e] = 1);
            e[r] = s
        } else for (const e in a) n[e] = 1
    }
    for (const e in i) e in o || (o[e] = void 0);
    return o
}

function Va(e) {
    return "object" == typeof e && null !== e ? e : {}
}

function _a(e, t, o) {
    const i = e.$$.props[t];
    void 0 !== i && (e.$$.bound[i] = o, o(e.$$.ctx[i]))
}

function Na(e) {
    e && e.c()
}

function Ha(e, t, o, i) {
    const {fragment: n, after_update: r} = e.$$;
    n && n.m(t, o), i || ba((() => {
        const t = e.$$.on_mount.map(nr).filter(sr);
        e.$$.on_destroy ? e.$$.on_destroy.push(...t) : ar(t), e.$$.on_mount = []
    })), r.forEach(ba)
}

function ja(e, t) {
    const o = e.$$;
    null !== o.fragment && (ar(o.on_destroy), o.fragment && o.fragment.d(t), o.on_destroy = o.fragment = null, o.ctx = [])
}

function Ua(e, t, o, i, n, r, a, s = [-1]) {
    const l = Jr;
    oa(e);
    const c = e.$$ = {
        fragment: null,
        ctx: [],
        props: r,
        update: tr,
        not_equal: n,
        bound: rr(),
        on_mount: [],
        on_destroy: [],
        on_disconnect: [],
        before_update: [],
        after_update: [],
        context: new Map(t.context || (l ? l.$$.context : [])),
        callbacks: rr(),
        dirty: s,
        skip_bound: !1,
        root: t.target || l.$$.root
    };
    a && a(c.root);
    let d = !1;
    if (c.ctx = o ? o(e, t.props || {}, ((t, o, ...i) => {
        const r = i.length ? i[0] : o;
        return c.ctx && n(c.ctx[t], c.ctx[t] = r) && (!c.skip_bound && c.bound[t] && c.bound[t](r), d && function (e, t) {
            -1 === e.$$.dirty[0] && (ua.push(e), fa(), e.$$.dirty.fill(0)), e.$$.dirty[t / 31 | 0] |= 1 << t % 31
        }(e, t)), o
    })) : [], c.update(), d = !0, ar(c.before_update), c.fragment = !!i && i(c.ctx), t.target) {
        if (t.hydrate) {
            const e = function (e) {
                return Array.from(e.childNodes)
            }(t.target);
            c.fragment && c.fragment.l(e), e.forEach(Lr)
        } else c.fragment && c.fragment.c();
        t.intro && Ea(e.$$.fragment), Ha(e, t.target, t.anchor, t.customElement), ka()
    }
    oa(l)
}

class Ga {
    $destroy() {
        ja(this, 1), this.$destroy = tr
    }

    $on(e, t) {
        if (!sr(t)) return tr;
        const o = this.$$.callbacks[e] || (this.$$.callbacks[e] = []);
        return o.push(t), () => {
            const e = o.indexOf(t);
            -1 !== e && o.splice(e, 1)
        }
    }

    $set(e) {
        var t;
        this.$$set && (t = e, 0 !== Object.keys(t).length) && (this.$$.skip_bound = !0, this.$$set(e), this.$$.skip_bound = !1)
    }
}

const Za = [];

function Xa(e, t) {
    return {subscribe: Ya(e, t).subscribe}
}

function Ya(e, t = tr) {
    let o;
    const i = new Set;

    function n(t) {
        if (lr(e, t) && (e = t, o)) {
            const t = !Za.length;
            for (const t of i) t[1](), Za.push(t, e);
            if (t) {
                for (let e = 0; e < Za.length; e += 2) Za[e][0](Za[e + 1]);
                Za.length = 0
            }
        }
    }

    return {
        set: n, update: function (t) {
            n(t(e))
        }, subscribe: function (r, a = tr) {
            const s = [r, a];
            return i.add(s), 1 === i.size && (o = t(n) || tr), r(e), () => {
                i.delete(s), 0 === i.size && (o(), o = null)
            }
        }
    }
}

function qa(e, t, o) {
    const i = !Array.isArray(e), n = i ? [e] : e, r = t.length < 2;
    return Xa(o, (e => {
        let o = !1;
        const a = [];
        let s = 0, l = tr;
        const c = () => {
            if (s) return;
            l();
            const o = t(i ? a[0] : a, e);
            r ? e(o) : l = sr(o) ? o : tr
        }, d = n.map(((e, t) => ur(e, (e => {
            a[t] = e, s &= ~(1 << t), o && c()
        }), (() => {
            s |= 1 << t
        }))));
        return o = !0, c(), function () {
            ar(d), l()
        }
    }))
}

var Ka = e => e.reduce(((e, t) => Object.assign(e, t)), {});
const Ja = e => ({updateValue: e}), Qa = e => ({defaultValue: e}), es = e => ({store: e}),
    ts = e => ({store: (t, o) => qa(...e(o))}), os = e => ({
        store: (t, o) => {
            const [i, n, r = (() => !1)] = e(o);
            let a, s = !0;
            return qa(i, ((e, t) => {
                n(e, (e => {
                    !s && r(a, e) || (a = e, s = !1, t(e))
                }))
            }))
        }
    }), is = e => ({
        store: (t, o) => {
            const [i, n = {}, r] = e(o);
            let a = [];
            const s = {}, l = e => i(e, s), c = e => {
                (a.length || e.length) && (a = e, d())
            }, d = () => {
                const e = a.map(l);
                r && e.sort(r), a = [...e], h(e)
            };
            Object.entries(n).map((([e, t]) => t.subscribe((t => {
                s[e] = t, t && d()
            }))));
            const {subscribe: u, set: h} = Ya(t || []);
            return {set: c, update: e => c(e(a)), subscribe: u}
        }
    });
var ns = e => {
    const t = {}, o = {};
    return e.forEach((([e, ...n]) => {
        const r = Ka(n), a = t[e] = ((e, t, o) => {
            const {store: n = (e => Ya(e)), defaultValue: r = i, updateValue: a} = o, s = n(r(), t, e), {
                subscribe: l,
                update: c = i
            } = s;
            let d;
            const u = e => {
                let t = !0;
                d && d(), d = l((o => {
                    if (t) return t = !1;
                    e(o), d(), d = void 0
                }))
            }, h = a ? a(e) : Z;
            return s.set = e => c((t => h(e, t, u))), s.defaultValue = r, s
        })(o, t, r), s = {get: () => hr(a), set: a.set};
        Object.defineProperty(o, e, s)
    })), {stores: t, accessors: o}
};
var rs = [["src", es((() => {
        let e;
        const {subscribe: t, set: o} = Ya(), i = t => {
            e !== t && (e = t, o(e))
        };
        return {set: i, subscribe: t, update: t => i(t(e))}
    }))], ["imageReader"], ["imageWriter"], ["imageScrambler"], ["imageRedactionRendering", Qa((() => "pixelated"))], ["images", Qa((() => []))], ["shapePreprocessor"], ["willRequestResource"], ["willRequest"], ["csp"]],
    as = e => e.charAt(0).toUpperCase() + e.slice(1), ss = (e, t) => {
        Object.keys(t).forEach((o => {
            const i = M(t[o]) ? {value: t[o], writable: !1} : t[o];
            Object.defineProperty(e, o, i)
        }))
    };
const ls = (e, t) => {
    let o, i, n, r, a, s, l, c, d, u;
    const h = t.length;
    for (o = 0; o < h; o++) if (i = t[o], n = t[o + 1 > h - 1 ? 0 : o + 1], r = i.x - e.x, a = i.y - e.y, s = n.x - e.x, l = n.y - e.y, c = r - s, d = a - l, u = c * a - d * r, u < -1e-5) return !1;
    return !0
};
var cs = (e, t) => {
    const o = Ft(t), i = ue();
    St(e).forEach((e => {
        we(e, i), ls(e, t) || o.forEach((t => {
            const o = Math.atan2(t.start.y - t.end.y, t.start.x - t.end.x), n = 1e4 * Math.sin(Math.PI - o),
                r = 1e4 * Math.cos(Math.PI - o), a = he(e.x + n, e.y + r), s = Ye(Xe(t), 1e4), l = Pt(Ze(e, a), s);
            l && we(i, Se(me(l), e))
        }))
    }));
    const n = Je(e);
    we(n, i);
    return !!St(n).every((e => ls(e, t))) && ($t(e, n), !0)
}, ds = (e, t) => {
    const o = St(e), i = zt(t, 5), n = st(e), r = [];
    o.forEach((e => {
        const t = ((e, t) => {
            if (0 === t) return e;
            const o = he(e.start.x - e.end.x, e.start.y - e.end.y), i = ye(o), n = Ce(i, t);
            return e.end.x += n.x, e.end.y += n.y, e
        })(Ze(me(n), me(e)), 1e6);
        let o = !1;
        i.map(Xe).forEach((e => {
            const i = Pt(t, e);
            i && !o && (r.push(i), o = !0)
        }))
    }));
    const a = Re(r[0], r[2]) < Re(r[1], r[3]) ? [r[0], r[2]] : [r[1], r[3]], s = it(a);
    return s.width < e.width && ($t(e, s), !0)
}, us = (e, t, o = {x: 0, y: 0}) => {
    const i = et(e), n = st(i), r = Ct(i, o, n).map((e => $e(e, t, n))), a = it(r);
    return r.map((e => Se(e, a)))
}, hs = (e, t = 0, o = mt(e)) => {
    let i, n;
    if (0 !== t) {
        const r = Math.atan2(1, o), a = Math.sign(t) * t, s = a % Math.PI, l = a % Y;
        let c;
        c = s > q && s < Y + q ? l > q ? a : Y - l : l > q ? Y - l : a;
        const d = Math.min(Math.abs(e.height / Math.sin(r + c)), Math.abs(e.width / Math.cos(r - c)));
        i = Math.cos(r) * d, n = i / o
    } else i = e.width, n = i / o, n > e.height && (n = e.height, i = n * o);
    return Ve(i, n)
}, ps = (e, t, o, i, n, r, a, s) => {
    const l = ze(a), c = ze(s), d = le(Math.max(t.width / c.width, t.height / c.height)),
        u = le(Math.min(t.width / l.width, t.height / l.height)), h = Je(t);
    if (u < 1 || d > 1) {
        const o = st(e), i = st(t), n = u < 1 ? u : d, r = (i.x + o.x) / 2, a = (i.y + o.y) / 2, s = h.width / n,
            l = h.height / n;
        gt(h, r - .5 * s, a - .5 * l, s, l)
    }
    return r ? (((e, t, o = 0, i = ue(), n) => {
        if (zo(o) && 0 !== o || i.x || i.y) {
            const n = mt(e), r = us(t, o, i), a = hs(t, o, n);
            if (!(e.width < a.width && e.height < a.height)) {
                const t = .5 * e.width - .5 * a.width, o = .5 * e.height - .5 * a.height;
                e.width > a.width && (e.width = a.width, e.x += t), e.height > a.height && (e.height = a.height, e.y += o)
            }
            cs(e, r), ds(e, r) && cs(e, r)
        } else {
            const o = mt(e);
            e.width = Math.min(e.width, t.width), e.height = Math.min(e.height, t.height), e.x = Math.max(e.x, 0), e.x + e.width > t.width && (e.x -= e.x + e.width - t.width), e.y = Math.max(e.y, 0), e.y + e.height > t.height && (e.y -= e.y + e.height - t.height);
            const i = st(e), r = vt(e, o);
            r.width = Math.max(n.width, r.width), r.height = Math.max(n.height, r.height), r.x = i.x - .5 * r.width, r.y = i.y - .5 * r.height, $t(e, r)
        }
    })(h, o, i, n, l), {crop: h}) : {crop: h}
}, ms = (e, t, o) => {
    const i = et(e), n = st(i), r = ft(i, o, n), a = st(Tt(it(r))), s = st(t), l = $e(s, -o, a), c = Se(l, a),
        d = ve(we(n, c), le);
    return at(d.x - .5 * t.width, d.y - .5 * t.height, t.width, t.height)
}, gs = (e, t, o) => Math.max(t, Math.min(e, o));
const $s = ["cropLimitToImage", "cropMinSize", "cropMaxSize", "cropAspectRatio", "flipX", "flipY", "rotation", "crop", "colorMatrix", "convolutionMatrix", "gamma", "vignette", "manipulation", "redaction", "annotation", "decoration", "selection", "frame", "backgroundColor", "backgroundImage", "targetSize", "metadata", "trim", "volume", "minDuration", "maxDuration", "currentTime"],
    fs = e => Oo(e) ? e.map(fs) : po(e) || Ht(e) ? e : k(e) ? {...e} : e,
    ys = e => e.map((e => Object.entries(e).reduce(((e, [t, o]) => (t.startsWith("_") || (e[t] = o), e)), {})));
const bs = (e, t) => e === t;
var xs = (e, t, o = bs) => {
    if (e.length !== t.length) return !1;
    for (let i = 0; i < e.length; i++) if (!o(e[i], t[i])) return !1;
    return !0
};
const vs = (e, t, o) => {
        const i = ve(st(e), (e => le(e, 8))), n = et(t), r = st(n), a = ft(n, o, r), s = ve(He(it(a)), (e => le(e, 8))),
            l = Math.abs(s.x - i.x), c = Math.abs(s.y - i.y);
        return l < 1 && c < 1
    }, ws = (e, t, o, i, n) => {
        if (!n) return [-1 / 0, 1 / 0];
        const r = Math.max(o.width / i.width, o.height / i.height), a = Ve(i.width * r, i.height * r),
            s = (l = a, Math.sqrt(l.width * l.width + l.height * l.height));
        var l;
        if (s < Math.min(e.width, e.height)) return [-1 / 0, 1 / 0];
        const c = t ? e.height : e.width, d = t ? e.width : e.height, u = Math.acos(a.height / s), h = u - Math.acos(d / s),
            p = Math.asin(c / s) - u;
        if (Number.isNaN(h) && Number.isNaN(p)) return [-1 / 0, 1 / 0];
        const m = Number.isNaN(h) ? p : Number.isNaN(p) ? h : Math.min(h, p);
        return [-m, m]
    }, Ss = (e, t) => {
        const {context: o, props: i} = t;
        return e._isFormatted || ((e = un(e))._isFormatted = !0, Object.assign(e, i)), e._isDraft || !Wi(e) || e._context && pt(o, e._context) || (Mn(e, o), e._context = {...o}), e
    },
    ks = (e, t) => (e._isFormatted || (e.disableMove = !0, e.disableSelect = !0, e.disableResize = !0, e.disableRotate = !0), Ss(e, t));
var Cs = [["file"], ["size"], ["loadState"], ["processState"], ["aspectRatio", ts((({size: e}) => [e, e => e ? mt(e) : void 0]))], ["perspectiveX", Qa((() => 0))], ["perspectiveY", Qa((() => 0))], ["perspective", ts((({
                                                                                                                                                                                                                              perspectiveX: e,
                                                                                                                                                                                                                              perspectiveY: t
                                                                                                                                                                                                                          }) => [[e, t], ([e, t]) => ({
    x: e,
    y: t
})]))], ["rotation", Qa((() => 0)), Ja((e => (t, o, i) => {
    if (t === o) return t;
    const {
        loadState: n,
        size: r,
        rotationRange: a,
        cropMinSize: s,
        cropMaxSize: l,
        crop: c,
        perspective: d,
        cropLimitToImage: u,
        cropOrigin: h
    } = e;
    if (!c || !n || !n.beforeComplete) return t;
    const p = u && ((e, t, o) => {
        const i = hs(t, o, mt(e));
        return _e(Ge(i, Math.round), Ge(ze(e), Math.round))
    })(c, r, o), m = u && vs(c, r, o), g = ((e, t, o, i, n, r, a, s, l, c) => {
        const d = ze(l), u = ze(c);
        a && (u.width = Math.min(c.width, n.width), u.height = Math.min(c.height, n.height));
        let h = !1;
        const p = (t, o) => {
            const l = ms(n, i, t), c = et(n), m = st(c), g = Ct(c, r, m), $ = Se(me(m), Mt(g)), f = $e(st(l), o, m),
                y = Se(me(m), f);
            g.forEach((e => $e(e, o, m)));
            const b = it(g), x = Mt(g), v = we(Se(Se(x, y), b), $),
                w = at(v.x - .5 * l.width, v.y - .5 * l.height, l.width, l.height);
            if (s && ct(w, s.width / w.width), a) {
                const e = us(n, o, r);
                ds(w, e)
            }
            const S = le(Math.min(w.width / d.width, w.height / d.height), 8),
                k = le(Math.max(w.width / u.width, w.height / u.height), 8);
            return (S < 1 || k > 1) && le(Math.abs(o - t)) === le(Math.PI / 2) && !h ? (h = !0, p(e, e + Math.sign(o - t) * Math.PI)) : {
                rotation: o,
                crop: kt(w, (e => le(e, 8)))
            }
        }, m = Math.sign(t) * Math.round(Math.abs(t) / Y) * Y, g = gs(t, m + o[0], m + o[1]);
        return p(e, g)
    })(o, t, a, c, r, d, u, h, s, l);
    if (p && m) {
        const e = hs(r, t, mt(g.crop));
        g.crop.x += .5 * g.crop.width, g.crop.y += .5 * g.crop.height, g.crop.x -= .5 * e.width, g.crop.y -= .5 * e.height, g.crop.width = e.width, g.crop.height = e.height
    }
    return i((() => {
        e.crop = kt(g.crop, (e => le(e, 8)))
    })), g.rotation
}))], ["flipX", Qa((() => !1))], ["flipY", Qa((() => !1))], ["flip", ts((({
                                                                              flipX: e,
                                                                              flipY: t
                                                                          }) => [[e, t], ([e, t]) => ({
    x: e,
    y: t
})]))], ["isRotatedSideways", os((({rotation: e}) => [[e], ([e], t) => t(K(e)), (e, t) => e !== t]))], ["crop", Ja((e => (t, o = t) => {
    const {
        loadState: i,
        size: n,
        cropMinSize: r,
        cropMaxSize: a,
        cropLimitToImage: s,
        cropAspectRatio: l,
        rotation: c,
        perspective: d
    } = e;
    if (!t && !o || !i || !i.beforeComplete) return t;
    t || (t = et(hs(n, c, l || mt(n))));
    const u = ps(o, t, n, c, d, s, r, a), h = kt(u.crop, (e => le(e, 8)));
    return pt(o, h) ? o : h
}))], ["cropAspectRatio", Ja((e => (t, o) => {
    const {loadState: i, crop: n, size: r, rotation: a, cropLimitToImage: s} = e, l = (e => {
        if (e) {
            if (/:/.test(e)) {
                const [t, o] = e.split(":");
                return t / o
            }
            return parseFloat(e)
        }
    })(t);
    if (!l) return;
    if (!n || !i || !i.beforeComplete) return l;
    const c = o ? Math.abs(t - o) : 1;
    if (vs(n, r, a) && s && c >= .1) {
        const o = ((e, t) => {
            const o = e.width, i = e.height;
            return K(t) && (e.width = i, e.height = o), e
        })(ze(r), a);
        e.crop = kt(vt(et(o), t), le)
    } else {
        const t = {width: n.height * l, height: n.height}, o = .5 * (n.width - t.width), i = .5 * (n.height - t.height);
        e.crop = kt(at(n.x + o, n.y + i, t.width, t.height), le)
    }
    return l
}))], ["cropOrigin"], ["cropMinSize", Qa((() => ({width: 1, height: 1})))], ["cropMaxSize", Qa((() => ({
    width: 32768,
    height: 32768
})))], ["cropLimitToImage", Qa((() => !0)), Ja((e => (t, o, i) => {
    const {crop: n} = e;
    return n ? (!o && t && i((() => e.crop = Je(e.crop))), t) : t
}))], ["cropSize", os((({crop: e}) => [[e], ([e], t) => {
    e && t(Ve(e.width, e.height))
}, (e, t) => _e(e, t)]))], ["cropRectAspectRatio", ts((({cropSize: e}) => [[e], ([e], t) => {
    e && t(le(mt(e), 5))
}]))], ["cropRange", os((({
                              size: e,
                              rotation: t,
                              cropRectAspectRatio: o,
                              cropMinSize: i,
                              cropMaxSize: n,
                              cropLimitToImage: r
                          }) => [[e, t, o, i, n, r], ([e, t, o, i, n, r], a) => {
    if (!e) return;
    a(((e, t, o, i, n, r) => {
        const a = ze(i), s = ze(n);
        return r ? [a, Ge(hs(e, t, o), Math.round)] : [a, s]
    })(e, t, o, i, n, r))
}, (e, t) => xs(e, t)]))], ["rotationRange", os((({
                                                      size: e,
                                                      isRotatedSideways: t,
                                                      cropMinSize: o,
                                                      cropSize: i,
                                                      cropLimitToImage: n
                                                  }) => [[e, t, o, i, n], ([e, t, o, i, n], r) => {
    if (!e || !i) return;
    r(ws(e, t, o, i, n))
}, (e, t) => xs(e, t)]))], ["backgroundColor", Ja((() => e => ((e = [0, 0, 0, 0], t = 1) => 4 === e.length ? e : [...e, t])(e)))], ["backgroundImage"], ["targetSize"], ["colorMatrix"], ["convolutionMatrix"], ["gamma"], ["noise"], ["vignette"], ["duration"], ["currentTime"], ["minDuration", Qa((() => 1 / 24))], ["maxDuration", Qa((() => 1 / 0))], ["volume", Qa((() => 1))], ["trim"], ["redaction", is((({size: e}) => [Ss, {context: e}]))], ["manipulation", is((({size: e}) => [Ss, {context: e}]))], ["annotation", is((({size: e}) => [Ss, {context: e}]))], ["decoration", is((({crop: e}) => [Ss, {context: e}]))], ["selection", is((({size: e}) => [ks, {context: e}]))], ["frame", Ja((() => e => {
    if (!e) return;
    const t = {
        frameStyle: void 0,
        x: 0,
        y: 0,
        width: "100%",
        height: "100%",
        disableStyle: ["backgroundColor", "strokeColor", "strokeWidth"]
    };
    return h(e) ? t.frameStyle = e : Object.assign(t, e), t
}))], ["metadata"], ["state", es(((e, t, o) => {
    const i = $s.map((e => t[e]));
    let n = !1;
    const r = Ya({}), {subscribe: a} = qa([...i, r], ((e, t) => {
        if (n) return;
        const o = $s.reduce(((t, o, i) => (t[o] = fs(e[i]), t)), {});
        o.crop && kt(o.crop, Math.round), o.manipulation = o.manipulation && ys(o.manipulation), o.redaction = o.redaction && ys(o.redaction), o.annotation = o.annotation && ys(o.annotation), o.decoration = o.decoration && ys(o.decoration), o.selection = o.selection && ys(o.selection), t(o)
    })), s = e => {
        e && (n = !0, o.cropOrigin = void 0, $s.filter((t => Bo(e, t))).forEach((t => {
            const i = e[t];
            o[t] = null === i ? void 0 : fs(i)
        })), n = !1, r.set({}))
    };
    return {set: s, update: e => s(e(null)), subscribe: a}
}))]], Ts = async (e, t, o = {}, n) => {
    const {ontaskstart: r, ontaskprogress: a, ontaskend: s, token: l} = n;
    let c = !1;
    const d = {cancel: i};
    l.cancel = () => {
        c = !0, d.cancel()
    };
    for (const [i, n] of t.entries()) {
        if (c) return;
        const [t, l] = n;
        r(i, l);
        try {
            e = await t(e, {...o, taskCancelToken: d}, (e => a(i, l, e)))
        } catch (e) {
            throw c = !0, e
        }
        s(i, l)
    }
    return e
};
const Ms = e => console.warn(`Pintura: ${e} is a required prop.`),
    Ps = ["loadstart", "loadabort", "loaderror", "loadprogress", "load", "processstart", "processabort", "processerror", "processprogress", "process"],
    Rs = ["flip", "cropOrigin", "isRotatedSideways", "perspective", "perspectiveX", "perspectiveY", "cropRange"],
    Is = ["images"], Es = Cs.map((([e]) => e)).filter((e => !Rs.includes(e))), As = e => "image" + as(e),
    Ls = e => Bo(e, "crop");
var Fs = () => {
    const {stores: e, accessors: t} = ns(rs), {sub: o, pub: n} = Ko(), r = () => t.images ? t.images[0] : {};
    let a = {};
    const s = {};
    Es.forEach((e => {
        Object.defineProperty(t, As(e), {
            get: () => {
                const t = r();
                if (t) return t.accessors[e]
            }, set: t => {
                a[As(e)] = t, s[As(e)] = t;
                const o = r();
                o && (o.accessors[e] = t)
            }
        })
    }));
    const l = () => t.images && t.images[0];
    let c;
    const d = e.src.subscribe((e => {
        if (!e) return t.images = [];
        t.imageReader ? (t.images.length && (a = {}), p(e)) : c = setTimeout((() => Ms("imageReader")), 32)
    })), u = e.imageReader.subscribe((e => {
        e && (clearTimeout(c), t.images.length || t.src && p(t.src))
    })), p = e => {
        Promise.resolve().then((() => g(e, a))).catch((() => {
        }))
    };
    let m;
    const g = (e, o = {}) => new Promise(((r, c) => {
        let d = l();
        const u = !(!1 === o.cropLimitToImage || !1 === o.imageCropLimitToImage || !1 === s.imageCropLmitedToImage),
            h = o.cropMinSize || o.imageCropMinSize || s.imageCropMinSize, p = u ? h : d && d.accessors.cropMinSize,
            g = o.minDuration || o.imageMinDuration;
        d && f(), d = (({minSize: e = {width: 1, height: 1}, minDuration: t = 0} = {}) => {
            const {stores: o, accessors: n} = ns(Cs), {pub: r, sub: a} = Ko(), s = (e, t) => {
                const o = () => n[e] || {}, i = t => {
                    n[e] = {...o(), ...t, timeStamp: Date.now()}
                }, a = () => o().error, s = e => {
                    a() || (i({error: e}), r(t + "error", {...o()}))
                };
                return {
                    start() {
                        r(t + "start")
                    }, onabort() {
                        i({abort: !0}), r(t + "abort", {...o()})
                    }, ontaskstart(e, n) {
                        a() || (i({
                            index: e,
                            task: n,
                            taskProgress: void 0,
                            taskLengthComputable: void 0
                        }), r(t + "taskstart", {...o()}))
                    }, ontaskprogress(e, n, s) {
                        a() || (i({
                            index: e,
                            task: n,
                            taskProgress: s.loaded / s.total,
                            taskLengthComputable: s.lengthComputable
                        }), r(t + "taskprogress", {...o()}), r(t + "progress", {...o()}))
                    }, ontaskend(e, n) {
                        a() || (i({index: e, task: n}), r(t + "taskend", {...o()}))
                    }, ontaskerror(e) {
                        s(e)
                    }, error(e) {
                        s(e)
                    }, beforeComplete(e) {
                        a() || (i({beforeComplete: !0}), r("before" + t, e))
                    }, complete(e) {
                        a() || (i({complete: !0}), r(t, e))
                    }
                }
            };
            return ss(n, {
                read: (o, {reader: r}, a = {}) => {
                    if (!r) return;
                    Object.assign(n, {file: void 0, size: void 0, loadState: void 0});
                    let l = {cancel: i}, c = !1;
                    const d = s("loadState", "load"), u = {token: l, ...d},
                        h = {src: o, size: void 0, dest: void 0, duration: void 0};
                    return Promise.resolve().then((async () => {
                        try {
                            if (d.start(), c) return d.onabort();
                            const o = await Ts(h, r, a, u);
                            if (c) return d.onabort();
                            const {size: i, duration: s, dest: p} = o || {};
                            if (!i || !i.width || !i.height) throw new co("Image size missing", "IMAGE_SIZE_MISSING", o);
                            if (s > 0 && s < t) throw new co("Video too short", "VIDEO_TOO_SHORT", {
                                ...o,
                                minDuration: t
                            });
                            if (i.width < e.width || i.height < e.height) throw new co("Image too small", "IMAGE_TOO_SMALL", {
                                ...o,
                                minWidth: e.width,
                                minHeight: e.height
                            });
                            Object.assign(n, {file: p, size: i, duration: s}), d.beforeComplete(o), d.complete(o)
                        } catch (e) {
                            d.error(e)
                        } finally {
                            l = void 0
                        }
                    })), () => {
                        c = !0, l && l.cancel(), d.onabort()
                    }
                }, write: (e, t) => {
                    if (!n.loadState.complete) return;
                    n.processState = void 0;
                    const o = s("processState", "process"), r = {src: n.file, imageState: n.state, dest: void 0};
                    if (M(e) && (e = e(n.file, n.state)), !e) return o.start(), void o.complete(r);
                    let a = {cancel: i}, l = !1;
                    const c = t, d = {token: a, ...o};
                    return Promise.resolve().then((async () => {
                        try {
                            if (o.start(), l) return o.onabort();
                            const t = await Ts(r, e, c, d);
                            if (l) return o.onabort();
                            o.complete(t)
                        } catch (e) {
                            o.error(e)
                        } finally {
                            a = void 0
                        }
                    })), () => {
                        l = !0, a && a.cancel()
                    }
                }, on: a
            }), {accessors: n, stores: o}
        })({minSize: p, minDuration: g}), Ps.map((e => {
            return d.accessors.on(e, (t = e, e => n(t, e)));
            var t
        }));
        const $ = () => {
            a = {}, y.forEach((e => e()))
        }, y = [];
        y.push(d.accessors.on("loaderror", (e => {
            $(), c(e)
        }))), y.push(d.accessors.on("loadabort", (() => {
            $(), c({name: "AbortError"})
        }))), y.push(d.accessors.on("load", (e => {
            m = void 0, $(), r(e)
        }))), y.push(d.accessors.on("beforeload", (() => ((e, o) => {
            if (Ls(o)) return void (t.imageState = o);
            if (!o.imageCrop) {
                const t = e.accessors.size, i = o.imageRotation || 0, n = je(ze(t), i), r = et(n);
                r.width = le(Math.abs(r.width), 6), r.height = le(Math.abs(r.height), 6);
                const a = o.imageCropAspectRatio || (o.imageCropLimitToImage ? mt(t) : mt(r));
                let s;
                o.imageCropLimitToImage ? s = vt(r, a) : (s = xt(r, a), s.x = (t.width - s.width) / 2, s.y = (t.height - s.height) / 2), o.imageCrop = s
            }
            if (e.accessors.duration && !o.imageTrim && o.imageMaxDuration) {
                const {duration: t} = e.accessors;
                o.imageTrim = [[0, Math.min(o.imageMaxDuration / t, 1)]]
            }
            const i = ["imageCropLimitToImage", "imageCrop", "imageCropAspectRatio", "imageRotation"];
            i.filter((e => Bo(o, e))).forEach((e => {
                t[e] = o[e], delete o[e]
            }));
            const n = Object.keys(o).filter((e => !i.includes(e))).reduce(((e, t) => (e[t] = o[t], e)), {});
            Object.assign(t, n)
        })(d, o)))), t.images = [d], o.imageReader && (t.imageReader = o.imageReader), o.imageWriter && (t.imageWriter = o.imageWriter), m = d.accessors.read(e, {reader: t.imageReader}, {willRequest: t.willRequest})
    }));
    let $;
    const f = () => {
        const e = l();
        e && (m && m(), e.accessors.loadState = void 0, t.images = [])
    };
    return Object.defineProperty(t, "stores", {get: () => e}), ss(t, {
        on: o, loadImage: g, abortLoadImage: () => {
            m && m(), t.images = []
        }, editImage: (e, o) => new Promise(((i, n) => {
            g(e, o).then((() => {
                const {images: e} = t, o = e[0], r = () => {
                    a(), s()
                }, a = o.accessors.on("processerror", (e => {
                    r(), n(e)
                })), s = o.accessors.on("process", (e => {
                    r(), i(e)
                }))
            })).catch(n)
        })), removeImage: f, processImage: (e, o) => new Promise(((i, n) => {
            try {
                const r = [], a = () => {
                    $ = void 0, r.forEach((e => e()))
                };
                (async () => {
                    if ((e => h(e) || jo(e) || Nt(e))(e)) try {
                        await g(e, o)
                    } catch (e) {
                        n(e)
                    } else e && (Ls(e) ? t.imageState = e : Object.assign(t, e));
                    const s = l();
                    if (!s) return n("no image");
                    r.push(s.accessors.on("processerror", (e => {
                        a(), n(e)
                    }))), r.push(s.accessors.on("processabort", (() => {
                        a(), n({name: "AbortError"})
                    }))), r.push(s.accessors.on("process", (e => {
                        a(), i(e)
                    }))), $ = s.accessors.write(t.imageWriter, {
                        redactionRenderStyle: t.imageRedactionRendering,
                        shapePreprocessor: t.shapePreprocessor || Z,
                        imageScrambler: t.imageScrambler,
                        willRequest: t.willRequest,
                        csp: t.csp || {},
                        willRequestResource: t.willRequestResource
                    })
                })()
            } catch (e) {
                n(e)
            }
        })), abortProcessImage: () => {
            const e = l();
            e && ($ && $(), e.accessors.processState = void 0)
        }, destroy: () => {
            d && d(), u && u()
        }
    }), t
};
const zs = (e, t) => {
    const {processImage: o} = Fs();
    return o(e, t)
};
var Ds = () => Kt() ? bo() ? /15_|16_/.test(navigator.userAgent) ? 14745600 : 16777216 : /15_/.test(navigator.userAgent) ? 16777216 : 1 / 0 : 1 / 0,
    Bs = (e, t) => Object.keys(e).filter((e => !t.includes(e))).reduce(((t, o) => (t[o] = e[o], t)), {}),
    Os = e => new Promise((t => {
        if (e.duration === 1 / 0) return e.ontimeupdate = () => {
            e.ontimeupdate = void 0, t(e)
        }, void (e.currentTime = Number.MAX_SAFE_INTEGER);
        t(e)
    }));
const Ws = e => new Promise((t => {
    const o = new FileReader;
    o.onload = () => t(o.result), o.readAsArrayBuffer(e)
})), Vs = (e, t = 0, o = e.byteLength) => {
    const i = [], n = t + o;
    for (; t < n;) {
        const o = e.getUint32(t);
        if (o < 0) break;
        const n = e.getUint32(t + 4);
        if (i.push({type: n, size: o, offset: t, bodyOffset: t + 8, bodySize: o - 8}), o < 8) break;
        t += o
    }
    return i
}, _s = (e, {limit: t = 1024} = {}) => {
    let o = 0;
    o += 4;
    if (1718909296 !== e.getUint32(o)) return 0;
    o += 4;
    const i = e.getUint32(o);
    return 1836069938 === i ? ((e, t, o) => {
        let i = !1, n = -1;
        for (let r = t; r < o; r++) if (i || 1953653099 !== e.getUint32(r) || (i = !0, r += 4), i && 64 == e.getUint8(r)) {
            n = r;
            break
        }
        if (n < 0) return 0;
        const r = e.getUint32(n - 28), a = e.getUint32(n - 20), s = e.getUint32(n - 32), l = e.getUint32(n - 16);
        return 65536 === r && 4294901760 === a ? 90 : 4294901760 === s && 4294901760 === l ? 180 : 4294901760 === r && 65536 === a ? 270 : 0
    })(e, o, t) : 1903435808 === i ? (e => {
        const t = Vs(e).find((e => 1836019574 === e.type));
        if (!t) return 0;
        const o = Vs(e, t.bodyOffset, t.bodySize);
        o.filter((e => 1953653099 === e.type)).forEach((t => {
            o.push(...Vs(e, t.bodyOffset, t.bodySize))
        }));
        const i = [1836476516, 1953196132], n = o.filter((e => i.includes(e.type)));
        for (const {type: t, bodyOffset: o} of n) {
            const i = e.getUint8(o);
            let n = o + 4;
            n += 1836476516 === t ? 32 : 36, n += 1 === i ? 12 : 0;
            const r = e.getInt32(n), a = e.getInt32(n + 4);
            if (0 === r && a > 0) return 90;
            if (r < 0 && 0 === a) return 180;
            if (0 === r && a < 0) return 270
        }
        return 0
    })(e) : 0
};
var Ns = e => new Promise(((t, o) => {
    (z() ? (async e => {
        const t = await Ws(e), o = new DataView(t);
        return _s(o)
    })(e) : Promise.resolve(0)).then((i => {
        const n = document.createElement("video");
        n.onerror = () => o(n.error), n.playsInline = !0, n.preload = "auto", n.onseeked = () => {
            n.onseeked = void 0, t(n)
        }, n.onloadeddata = () => {
            n.onloadeddata = void 0, n.dataset.rotation = i ? "" + i : "0", Os(n).then(t), n.currentTime = 0
        }, bo() && Kt() ? (n.srcObject = e, n.load()) : n.src = URL.createObjectURL(e)
    }))
})), Hs = (e, t) => new Promise((o => {
    if (e.currentTime === t) return o(e);
    let i = e.onseeked;
    e.onseeked = () => {
        e.onseeked = i, o(e)
    }, e.currentTime = gs(t, 0, e.duration)
})), js = (e, t = 0) => new Promise(((o, i) => {
    Ns(e).then((e => {
        Hs(e, t).then((e => {
            const t = m("canvas");
            Qt(e).then((({width: i, height: n}) => {
                t.width = i, t.height = n;
                const r = t.getContext("2d", {willReadFrequently: !0}), a = () => {
                    r.drawImage(e, 0, 0, t.width, t.height);
                    const i = r.getImageData(0, 0, t.width, t.height);
                    $(t), URL.revokeObjectURL(e.src), o(i)
                };
                Kt() ? setTimeout(a, 16) : a()
            }))
        }))
    }))
})), Us = e => /video/.test(e.type);
const Gs = ({imageDataResizer: e, canvasMemoryLimit: t} = {}) => async (o, i, n, r, a) => {
        n.width = Math.max(n.width, 1), n.height = Math.max(n.height, 1), r.width = Math.max(r.width, 1), r.height = Math.max(r.height, 1);
        const {dest: s} = await zs(i, {
            imageReader: vl(),
            imageWriter: Sl({format: "canvas", targetSize: {...r, upscale: !0}, imageDataResizer: e, canvasMemoryLimit: t}),
            imageCrop: n
        }), {feather: l = 0} = a || {};
        if (l > 0) {
            const e = m("canvas");
            e.width = s.width, e.height = s.height;
            const t = e.getContext("2d", {willReadFrequently: !0}), o = 1 / l;
            let i = 0;
            for (i = 0; i < l; i++) {
                const e = i * o;
                t.strokeStyle = `rgba(0,0,0,${e * e})`, t.strokeRect(i + .5, i + .5, s.width - 2 * i - 1, s.height - 2 * i - 1)
            }
            t.fillStyle = "#000", t.fillRect(i, i, s.width + .5 - 2 * i, s.height + .5 - 2 * i);
            const n = s.getContext("2d");
            n.globalCompositeOperation = "destination-in", n.drawImage(e, 0, 0), $(e)
        }
        o.drawImage(s, r.x, r.y, r.width, r.height), $(s)
    }, Zs = (e, t = ((...e) => e), o) => async (i, n, r) => {
        r(ro(0, !1));
        let a = !1;
        const s = await e(...t(i, n, (e => {
            a = !0, r(e)
        })));
        return o && o(i, s), a || r(ro(1, !1)), i
    }, Xs = ({willRequest: e, srcProp: t = "src", destProp: o = "dest"} = {}) => [Zs(go, ((o, i, n) => [o[t], n, {
        ...i,
        willRequest: e
    }]), ((e, t) => e[o] = t)), "any-to-file"], Ys = ({srcProp: e = "dest", destProp: t = "dest"} = {}) => [Zs((async e => {
        if (/octet-stream/.test(e.type)) {
            console.warn(`Pintura: File has unknown mime type "${e.type}", make sure your server sets the correct Content-Type header.`);
            let t = "image";
            const o = await to(e);
            /video/i.test(o.nodeName) && (t = "video");
            const i = {type: t + "/unknown"};
            return Ht(e) ? new File([e], e.name, {...i, lastModified: e.lastModified}) : new Blob([e], i)
        }
        return e
    }), (t => [t[e]]), ((e, o) => e[t] = o)), "any-to-file"], qs = ({
                                                                        srcProp: e = "src",
                                                                        destProp: t = "size"
                                                                    } = {}) => [Zs(io, (t => [t[e]]), ((e, o) => e[t] = o)), "read-image-size"],
    Ks = async e => {
        const t = await to(e);
        if (oo(t)) return await (e => new Promise(((t, o) => {
            const i = () => {
                Os(e).then((() => {
                    t(e.duration)
                }))
            };
            if (e.readyState >= 1) return i();
            e.onloadedmetadata = i, e.onerror = () => o(e.error)
        })))(t)
    }, Js = ({
                 srcProp: e = "src",
                 destProp: t = "duration"
             } = {}) => [Zs(Ks, (t => [t[e]]), ((e, o) => e[t] = o)), "read-media-duration"], Qs = ({
                                                                                                        srcSize: e = "size",
                                                                                                        srcOrientation: t = "orientation",
                                                                                                        destSize: o = "size"
                                                                                                    } = {}) => [Zs(xo, (o => [o[e], o[t]]), ((e, t) => e[o] = t)), "image-size-match-orientation"],
    el = ({
              srcProp: e = "src",
              destProp: t = "copy"
          } = {}) => [Zs(((e, t) => vo(e) ? r(e, t) : void 0), (t => [t[e], onprogress]), ((e, o) => e[t] = o)), "read-image-head"],
    tl = ({
              srcProp: e = "copy",
              destProp: o = "orientation"
          } = {}) => [Zs(t, (t => [t[e], 274]), ((e, t = 1) => e[o] = t)), "read-exif-orientation-tag"],
    ol = ({srcProp: e = "copy"} = {}) => [Zs(t, (t => [t[e], 274, 1])), "clear-exif-orientation-tag"], il = ({
                                                                                                                 srcImageSize: e = "size",
                                                                                                                 srcCanvasSize: t = "imageData",
                                                                                                                 srcImageState: o = "imageState",
                                                                                                                 destImageSize: i = "size",
                                                                                                                 destScalar: n = "scalar"
                                                                                                             } = {}) => [Zs(((e, t) => [Math.min(t.width / e.width, t.height / e.height), De(t)]), (i => [i[e], i[t], i[o]]), ((e, [t, o]) => {
        e[n] = t, e[i] = o
    })), "calculate-canvas-scalar"], nl = ({
                                               srcProp: e = "src",
                                               destProp: t = "imageData",
                                               canvasMemoryLimit: o,
                                               srcImageState: i = "imageState"
                                           } = {}) => [Zs(((e, t, o) => Us(e) ? js(e, o.currentTime) : B(e, t)), (t => [t[e], o, t[i]]), ((e, o) => e[t] = o)), "blob-to-image-data"],
    rl = ({
              srcImageData: e = "imageData",
              srcOrientation: t = "orientation"
          } = {}) => [Zs(S, (o => [o[e], o[t]]), ((e, t) => e.imageData = t)), "image-data-match-orientation"], al = ({
                                                                                                                          srcImageData: e = "imageData",
                                                                                                                          srcImageState: t = "imageState"
                                                                                                                      } = {}) => [Zs(Jn, (o => [o[e], {
        backgroundColor: o[t].backgroundColor,
        backgroundImage: o[t].backgroundImage
    }]), ((e, t) => e.imageData = t)), "image-data-fill"], sl = ({
                                                                     srcImageData: e = "imageData",
                                                                     srcImageState: t = "imageState",
                                                                     destScalar: o = "scalar"
                                                                 } = {}) => [Zs(Co, (i => {
        const n = i[o];
        let {crop: r} = i[t];
        return r && 1 !== n && (r = ct(Je(r), n, ue())), [i[e], {
            crop: r,
            rotation: i[t].rotation,
            flipX: i[t].flipX,
            flipY: i[t].flipY
        }]
    }), ((e, t) => e.imageData = t)), "image-data-crop"], ll = ({
                                                                    targetSize: e = {
                                                                        width: void 0,
                                                                        height: void 0,
                                                                        fit: void 0,
                                                                        upscale: void 0
                                                                    },
                                                                    imageDataResizer: t,
                                                                    srcProp: o = "imageData",
                                                                    srcImageState: i = "imageState",
                                                                    destImageScaledSize: n = "imageScaledSize"
                                                                }) => [Zs(Po, (n => {
        const r = Math.min(e.width || Number.MAX_SAFE_INTEGER, n[i].targetSize && n[i].targetSize.width || Number.MAX_SAFE_INTEGER),
            a = Math.min(e.height || Number.MAX_SAFE_INTEGER, n[i].targetSize && n[i].targetSize.height || Number.MAX_SAFE_INTEGER);
        return [n[o], {
            width: r,
            height: a,
            fit: e.fit || "contain",
            upscale: (s = n[i], !!(s.targetSize && s.targetSize.width || s.targetSize && s.targetSize.height) || (e.upscale || !1))
        }, t];
        var s
    }), ((e, t) => {
        _e(e.imageData, t) || (e[n] = De(t)), e.imageData = t
    })), "image-data-resize"], cl = ({
                                         srcImageData: e = "imageData",
                                         srcImageState: t = "imageState",
                                         destImageData: o = "imageData"
                                     } = {}) => [Zs(Fo, (o => {
        const {colorMatrix: i} = o[t], n = i && Object.keys(i).map((e => i[e])).filter(Boolean);
        return [o[e], {
            colorMatrix: n && Qn(n),
            convolutionMatrix: o[t].convolutionMatrix,
            gamma: o[t].gamma,
            noise: o[t].noise,
            vignette: o[t].vignette
        }]
    }), ((e, t) => e[o] = t)), "image-data-filter"], dl = ({
                                                               srcImageData: e = "imageData",
                                                               srcImageState: t = "imageState",
                                                               destImageData: o = "imageData",
                                                               destScalar: i = "scalar"
                                                           } = {}) => [Zs((async (e, t, o, i, n, r) => {
        if (!t || !i.length) return e;
        let a;
        try {
            const n = {dataSizeScalar: er(e, i)};
            o && o[3] > 0 && (n.backgroundColor = [...o]), a = await t(e, n)
        } catch (e) {
        }
        const s = m("canvas");
        s.width = e.width, s.height = e.height;
        const l = s.getContext("2d", {willReadFrequently: !0});
        if (l.putImageData(e, 0, 0), "auto" === r) {
            const t = Math.sqrt(e.width * e.height);
            l.filter = `blur(${Math.round(t / 100)}px)`
        }
        const c = new Path2D;
        i.forEach((e => {
            const t = at(e.x, e.y, e.width, e.height);
            ht(t, n);
            const o = ft(Je(t), e.rotation), i = new Path2D;
            o.forEach(((e, t) => {
                if (0 === t) return i.moveTo(e.x, e.y);
                i.lineTo(e.x, e.y)
            })), c.addPath(i)
        })), l.clip(c, "nonzero"), l.imageSmoothingEnabled = !1, l.drawImage(a, 0, 0, s.width, s.height), $(a);
        const d = l.getImageData(0, 0, s.width, s.height);
        return $(s), d
    }), ((o, {
        imageScrambler: n,
        redactionRenderStyle: r
    }) => [o[e], n, o[t].backgroundColor, o[t].redaction, o[i], r]), ((e, t) => e[o] = t)), "image-data-redact"], ul = ({
                                                                                                                            srcImageData: e = "imageData",
                                                                                                                            srcSize: t = "size",
                                                                                                                            srcImageState: o = "imageState",
                                                                                                                            srcShapes: i = "annotation",
                                                                                                                            destImageData: n = "imageData",
                                                                                                                            destImageScaledSize: r = "imageScaledSize",
                                                                                                                            destScalar: a = "scalar",
                                                                                                                            imageDataResizer: s,
                                                                                                                            canvasMemoryLimit: l,
                                                                                                                            shapeFilter: c = Z,
                                                                                                                            shapeClip: d = !0,
                                                                                                                            destImageContext: u = "imageContext"
                                                                                                                        } = {}) => [Zs(Kn, ((n, {
        shapePreprocessor: h,
        willRequestResource: p,
        csp: m,
        willRequest: g
    }) => {
        const $ = n[o][i].filter(c);
        if (!$.length) return [n[e]];
        const f = n[a], {crop: y} = n[o], b = n[t];
        let x = f;
        const v = n[r];
        v && (x = Math.min(v.width / y.width, v.height / y.height));
        const w = {width: b.width / f, height: b.height / f};
        return [n[e], {
            shapes: $,
            computeShape: e => (e = xn(e, w), e = Bs(e, ["left", "right", "top", "bottom"]), e = Pn(e, x)),
            transform: e => {
                const i = n[t], {rotation: a = 0, flipX: s, flipY: l, cropLimitToImage: c} = n[o], {crop: h = et(i)} = n[o];
                let p = 1;
                p = n[r] ? x : f;
                const m = {width: i.width / f * p, height: i.height / f * p}, g = _t(m, a), $ = g.width, y = g.height,
                    b = .5 * m.width - .5 * $, v = .5 * m.height - .5 * y, w = He(m);
                e.translate(-b, -v), e.translate(-h.x * p, -h.y * p), e.translate(w.x, w.y), e.rotate(a), e.translate(-w.x, -w.y);
                const S = n[u] || {x: 0, y: 0};
                e.translate(S.x, S.y), e.scale(s ? -1 : 1, l ? -1 : 1), e.translate(s ? -m.width * f : 0, l ? -m.height * f : 0), c && d && (e.rect(0, 0, m.width, m.height), e.clip())
            },
            drawImage: Gs({imageDataResizer: s, canvasMemoryLimit: l}),
            preprocessShape: e => h(e, {isPreview: !1, ...n[o]}),
            canvasMemoryLimit: l,
            willRequest: g || p,
            styleNonce: m.styleNonce
        }]
    }), ((e, t) => e[n] = t)), "image-data-annotate"], hl = ({
                                                                 srcImageData: e = "imageData",
                                                                 srcImageState: t = "imageState",
                                                                 destImageData: o = "imageData",
                                                                 destImageScaledSize: i = "imageScaledSize",
                                                                 imageDataResizer: n,
                                                                 canvasMemoryLimit: r,
                                                                 destScalar: a = "scalar",
                                                                 shapeFilter: s = Z,
                                                                 destImageContext: l = "imageContext"
                                                             } = {}) => [Zs(Kn, ((o, {
        shapePreprocessor: c,
        willRequestResource: d,
        willRequest: u,
        csp: h
    }) => {
        let p = o[t].decoration.filter(s);
        if ("undefined" != typeof window && (e => {
            if (e && e._bj9ox0o) return;
            const [i] = [[85, 110, 108, 105, 99, 101, 110, 115, 101, 100, 32, 80, 105, 110, 116, 117, 114, 97, 32, 105, 110, 115, 116, 97, 110, 99, 101, 32]].map((e => e.map((e => String.fromCharCode(e))).join(""))), {
                width: n,
                height: r
            } = o[t].crop, a = r / 15;
            p = [...p, {
                x: .5 * -a,
                y: .5 * -a,
                width: 1.5 * n,
                height: 1.25 * r,
                text: Array(50).fill(i).join(""),
                fontWeight: 900,
                lineHeight: a,
                fontSize: a,
                color: [1, 1, 1, .05]
            }]
        })(window), !p.length) return [o[e]];
        let m = o[a];
        const {crop: g} = o[t], $ = o[i];
        if ($) {
            const e = Math.min($.width / g.width, $.height / g.height);
            m = e
        }
        return [o[e], {
            shapes: p,
            drawImage: Gs({imageDataResizer: n, canvasMemoryLimit: r}),
            computeShape: e => (e = xn(e, g), e = Bs(e, ["left", "right", "top", "bottom"]), e = Pn(e, m)),
            preprocessShape: e => c(e, {isPreview: !1, ...o[t]}),
            canvasMemoryLimit: r,
            willRequest: u || d,
            styleNonce: h.styleNonce,
            transform: e => {
                const t = o[l] || {x: 0, y: 0};
                e.translate(t.x, t.y)
            }
        }]
    }), ((e, t) => e[o] = t)), "image-data-decorate"], pl = ({
                                                                 srcImageData: e = "imageData",
                                                                 srcImageState: t = "imageState",
                                                                 destImageData: o = "imageData",
                                                                 destImageScaledSize: i = "imageScaledSize",
                                                                 imageDataResizer: n,
                                                                 canvasMemoryLimit: r,
                                                                 destScalar: a = "scalar",
                                                                 destImageContext: s = "imageContext"
                                                             } = {}) => [Zs(((e, t) => new Promise((o => {
        if (!t) return o([e]);
        Kn(e, t).then((e => {
            o([e, t.contextBounds])
        }))
    }))), ((o, {shapePreprocessor: s, willRequestResource: l, willRequest: c, csp: d}) => {
        const u = o[t].frame;
        if (!u) return [o[e]];
        const h = o[a];
        let {crop: p} = o[t];
        p && 1 !== h && (p = ct(Je(p), h, ue()));
        const m = {...p}, g = Cn(Tn(u, m, s), m);
        m.x = Math.abs(g.left), m.y = Math.abs(g.top), m.width += Math.abs(g.left) + Math.abs(g.right), m.height += Math.abs(g.top) + Math.abs(g.bottom);
        const $ = o[i], f = $ ? Math.min($.width / p.width, $.height / p.height) : 1;
        return ht(m, f), m.x = Math.floor(m.x), m.y = Math.floor(m.y), m.width = Math.floor(m.width), m.height = Math.floor(m.height), [o[e], {
            shapes: [u],
            contextBounds: m,
            computeShape: t => xn(t, o[e]),
            transform: e => {
                e.translate(m.x, m.y)
            },
            drawImage: Gs({imageDataResizer: n, canvasMemoryLimit: r}),
            preprocessShape: e => s(e, {isPreview: !1, ...o[t]}),
            canvasMemoryLimit: r,
            willRequest: c || l,
            styleNonce: d.styleNonce
        }]
    }), ((e, [t, i]) => {
        e[s] = i, e[o] = t
    })), "image-data-frame"], ml = ({
                                        mimeType: e,
                                        quality: t,
                                        srcImageData: o = "imageData",
                                        srcFile: i = "src",
                                        destBlob: n = "blob"
                                    } = {}) => [Zs(W, (n => [n[o], e || j(n[i].name) || n[i].type, t]), ((e, t) => e[n] = t)), "image-data-to-blob"],
    gl = ({
              srcImageData: e = "imageData",
              srcOrientation: t = "orientation",
              destCanvas: o = "dest"
          } = {}) => [Zs(w, (o => [o[e], o[t]]), ((e, t) => e[o] = t)), "image-data-to-canvas"], $l = async (e, t) => {
        if (!vo(e) || !t) return e;
        const o = (e, t) => {
            let o = 2;
            const i = new DataView(e), n = i.byteLength;
            for (t(i.getUint8(0), 0, 2, n); o < n && 255 == i.getUint8(o);) {
                const e = i.getUint8(o + 1), r = i.getUint16(o + 2) + 2;
                if (!1 === t(e, o, r, n)) break;
                o += r
            }
        }, i = e => e >= 224 && e <= 237, n = (e => {
            const t = [];
            return o(e, ((o, n, r) => {
                if (218 === o) return !1;
                i(o) && t.push(new Uint8Array(e, n, r))
            })), t
        })(t), a = ((e, t) => {
            const n = [];
            o(e, ((o, r, a, s) => 0 === r ? (n.push(new Uint8Array(e, r, a)), void n.push(...t)) : 218 === o ? (n.push(new Uint8Array(e, r, s - r)), !1) : void (i(o) || n.push(new Uint8Array(e, r, a)))));
            let r = n.reduce(((e, t) => e + t.length), 0), a = new Uint8Array(r), s = 0;
            return n.forEach((e => {
                a.set(e, s), s += e.length
            })), a
        })(await r(e), n);
        return new Blob([a], {type: "image/jpeg"})
    },
    fl = (e = "blob", t = "copy", o = "blob") => [Zs($l, (o => [o[e], o[t]]), ((e, t) => e[o] = t)), "blob-write-image-head"],
    yl = ({
              renameFile: e,
              srcBlob: t = "blob",
              srcFile: o = "src",
              destFile: i = "dest",
              defaultFilename: n
          } = {}) => [Zs(U, (i => [i[t], e ? e(i[o]) : i[o].name || `${n}.${_(i[t].type)}`]), ((e, t) => e[i] = t)), "blob-to-file"],
    bl = ({
              url: e = "./",
              dataset: t = (e => [["dest", e.dest, e.dest.name], ["imageState", e.imageState]]),
              destStore: o = "store",
              credentials: n,
              headers: r = {}
          }) => [Zs((async (t, o) => await ((e, t, o) => new Promise(((n, r) => {
        const {token: a = {}, beforeSend: s = i, onprogress: l = i} = o;
        a.cancel = () => c.abort();
        const c = new XMLHttpRequest;
        c.upload.onprogress = l, c.onload = () => c.status >= 200 && c.status < 300 ? n(c) : r(c), c.onerror = () => r(c), c.ontimeout = () => r(c), c.open("POST", encodeURI(e)), s(c), c.send(t instanceof FormData ? t : t.reduce(((e, t) => (e.append(...t.map(wo)), e)), new FormData))
    })))(e, t, {
        onprogress: o,
        beforeSend: e => uo(e, {headers: r, credentials: n})
    })), ((e, o, i) => [t(e), i]), ((e, t) => e[o] = t)), "store"],
    xl = e => [Zs((t => e && e.length ? (Object.keys(t).forEach((o => {
        e.includes(o) || delete t[o]
    })), t) : t)), "prop-filter"], vl = (e = {}) => {
        const {
            orientImage: t = !0,
            outputProps: o = ["src", "dest", "size", "duration"],
            preprocessImageFile: i,
            request: n = {}
        } = e;
        return [Xs({willRequest: () => n}), Ys(), i && [Zs(i, ((e, t, o) => [e.dest, t, o]), ((e, t) => e.dest = t)), "preprocess-image-file"], qs({srcProp: "dest"}), Js({srcProp: "dest"}), t && el({srcProp: "dest"}), t && tl(), t && Qs(), xl(o)].filter(Boolean)
    }, wl = e => e && (h(e) ? bl({url: e}) : M(e) ? [e, "store"] : bl(e)), Sl = (e = {}) => (t, o, i = {}) => {
        let {
            canvasMemoryLimit: n = Ds(),
            orientImage: r = !0,
            copyImageHead: a = !0,
            mimeType: s,
            quality: l,
            renameFile: c,
            targetSize: d,
            imageDataResizer: u,
            store: h,
            format: p = "file",
            outputProps: m = ["src", "dest", "imageState", "store"],
            preprocessImageSource: g,
            preprocessImageState: $,
            postprocessImageData: f,
            postprocessImageBlob: y,
            testSrcSupport: b = !1
        } = {...e, ...i};
        if (!b || eo(t)) return "blob" === p && (p = "file"), [g && [Zs(g, ((e, t, o) => [e.src, t, o, e.imageState]), ((e, t) => e.src = t)), "preprocess-image-source"], (r || a) && el(), r && tl(), qs(), $ && [Zs($, ((e, t, o, i) => [e.imageState, t, o, {
            size: e.size,
            orientation: e.orientation
        }]), ((e, t) => e.imageState = t)), "preprocess-image-state"], nl({canvasMemoryLimit: n}), r && Qs(), r && rl(), il(), dl(), sl(), ll({
            imageDataResizer: u,
            targetSize: d
        }), ul({imageDataResizer: u, canvasMemoryLimit: n, srcShapes: "manipulation"}), cl(), al(), ul({
            imageDataResizer: u,
            canvasMemoryLimit: n,
            srcShapes: "annotation",
            shapeFilter: e => !e.aboveFrame
        }), hl({imageDataResizer: u, canvasMemoryLimit: n, shapeFilter: e => !e.aboveFrame}), pl({
            imageDataResizer: u,
            canvasMemoryLimit: n
        }), ul({
            imageDataResizer: u,
            canvasMemoryLimit: n,
            srcShapes: "annotation",
            shapeFilter: e => e.aboveFrame,
            shapeClip: !1
        }), hl({
            imageDataResizer: u,
            canvasMemoryLimit: n,
            shapeFilter: e => e.aboveFrame
        }), f && [Zs(f, ((e, t, o) => [e.imageData, t, o]), ((e, t) => e.imageData = t)), "postprocess-image-data"], "file" === p ? ml({
            mimeType: s,
            quality: l
        }) : "canvas" === p ? gl() : [e => (e.dest = e.imageData, e)], "file" === p && r && ol(), "file" === p && a && fl(), y && [Zs(y, (({
                                                                                                                                               blob: e,
                                                                                                                                               imageData: t,
                                                                                                                                               src: o
                                                                                                                                           }, i, n) => [{
            blob: e,
            imageData: t,
            src: o
        }, i, n]), ((e, t) => e.blob = t)), "postprocess-image-file"], "file" === p && yl({
            defaultFilename: "image",
            renameFile: c
        }), "file" === p ? wl(h) : M(h) && [h, "store"], xl(m)].filter(Boolean)
    };
var kl = (e, t, o, i, n, r, a, s, l, c, d) => {
    if (!(e && t && o && i && s)) return;
    s *= r;
    const u = Tt(Je(t)), h = st(u), p = st(e), m = et(o), g = st(m), $ = ms(o, i, l), f = st($), y = Se(me(g), f),
        b = Se(me(p), h);
    y.x += b.x, y.y += b.y;
    const x = ge(me(y));
    x.x += b.x, x.y += b.y;
    const v = st(lt(lt(Je(n), a), e)), w = Se(v, p);
    return we(y, w), {origin: x, translation: y, rotation: {x: d ? Math.PI : 0, y: c ? Math.PI : 0, z: l}, scale: s}
};
let Cl = null;
var Tl = () => {
        if (null === Cl) if ("WebGL2RenderingContext" in window) {
            let e;
            try {
                e = m("canvas"), Cl = !!e.getContext("webgl2")
            } catch (e) {
                Cl = !1
            }
            e && $(e), e = void 0
        } else Cl = !1;
        return Cl
    }, Ml = e => 0 == (e & e - 1),
    Pl = (e, t = {}, o = "", i = "") => Object.keys(t).filter((e => !k(t[e]))).reduce(((e, n) => e.replace(new RegExp(o + n + i), t[n])), e);
const Rl = {
        head: "#version 300 es\n\nin vec4 aPosition;uniform mat4 uMatrix;",
        text: "\nin vec2 aTexCoord;out vec2 vTexCoord;",
        matrix: "\ngl_Position=uMatrix*vec4(aPosition.x,aPosition.y,0,1);"
    }, Il = {
        head: "#version 300 es\nprecision highp float;\n\nout vec4 fragColor;",
        mask: "\nuniform float uMaskFeather[8];uniform float uMaskBounds[4];uniform float uMaskOpacity;float mask(float x,float y,float bounds[4],float opacity){return 1.0-(1.0-(smoothstep(bounds[3],bounds[3]+1.0,x)*(1.0-smoothstep(bounds[1]-1.0,bounds[1],x))*(1.0-step(bounds[0],y))*step(bounds[2],y)))*(1.0-opacity);}",
        init: "\nfloat a=1.0;vec4 fillColor=uColor;vec4 textureColor=texture(uTexture,vTexCoord);textureColor*=(1.0-step(uRepeat.y,vTexCoord.y))*step(0.0,vTexCoord.y)*(1.0-step(uRepeat.x,vTexCoord.x))*step(0.0,vTexCoord.x);",
        colorize: "\nif(uTextureColor.a!=0.0&&textureColor.a>0.0){vec3 colorFlattened=textureColor.rgb/textureColor.a;if(colorFlattened.r>=.9999&&colorFlattened.g==0.0&&colorFlattened.b>=.9999){textureColor.rgb=uTextureColor.rgb*textureColor.a;}textureColor*=uTextureColor.a;}",
        maskapply: "\nfloat m=mask(gl_FragCoord.x,gl_FragCoord.y,uMaskBounds,uMaskOpacity);",
        maskfeatherapply: "\nfloat leftFeatherOpacity=step(uMaskFeather[1],gl_FragCoord.x)*uMaskFeather[0]+((1.0-uMaskFeather[0])*smoothstep(uMaskFeather[1],uMaskFeather[3],gl_FragCoord.x));float rightFeatherOpacity=(1.0-step(uMaskFeather[7],gl_FragCoord.x))*uMaskFeather[4]+((1.0-uMaskFeather[4])*smoothstep(uMaskFeather[7],uMaskFeather[5],gl_FragCoord.x));a*=leftFeatherOpacity*rightFeatherOpacity;",
        rectaa: "\nvec2 scaledPoint=vec2(vRectCoord.x*uSize.x,vRectCoord.y*uSize.y);a*=smoothstep(0.0,uEdgeFeather,uSize.x-scaledPoint.x);a*=smoothstep(0.0,uEdgeFeather,uSize.y-scaledPoint.y);a*=smoothstep(0.0,uEdgeFeather,scaledPoint.x);a*=smoothstep(0.0,uEdgeFeather,scaledPoint.y);",
        cornerradius: "\nvec2 s=(uSize-2.0)*.5;vec2 r=(vRectCoord*uSize)-1.0;vec2 p=r-s;float cornerRadius=uCornerRadius[0];bool left=r.x<s.x;bool top=r.y<s.y;if(!left&&top){cornerRadius=uCornerRadius[1];}if(!left&&!top){cornerRadius=uCornerRadius[3];}if(left&&!top){cornerRadius=uCornerRadius[2];}a*=1.0-clamp(length(max(abs(p)-(s-cornerRadius),0.0))-cornerRadius,0.0,1.0);",
        fragcolor: "\nif(m<=0.0)discard;fillColor.a*=a;fillColor.rgb*=fillColor.a;fillColor.rgb*=m;fillColor.rgb+=(1.0-m)*(uCanvasColor.rgb*fillColor.a);textureColor*=uTextureOpacity;textureColor.a*=a;textureColor.rgb*=m*a;textureColor.rgb+=(1.0-m)*(uCanvasColor.rgb*textureColor.a);fragColor=textureColor+(fillColor*(1.0-textureColor.a));"
    }, El = (e, t, o) => {
        const i = e.createShader(o),
            n = ((e, t, o) => (t = Pl(t, o === e.VERTEX_SHADER ? Rl : Il, "##").trim(), Tl() ? t : (t = (t = t.replace(/#version.+/gm, "").trim()).replace(/^\/\/\#/gm, "#"), o === e.VERTEX_SHADER && (t = t.replace(/in /gm, "attribute ").replace(/out /g, "varying ")), o === e.FRAGMENT_SHADER && (t = t.replace(/in /gm, "varying ").replace(/out.*?;/gm, "").replace(/texture\(/g, "texture2D(").replace(/fragColor/g, "gl_FragColor")), "" + t)))(e, t, o);
        return e.shaderSource(i, n), e.compileShader(i), e.getShaderParameter(i, e.COMPILE_STATUS) || console.error(e.getShaderInfoLog(i)), i
    }, Al = (e, t, o, i, n) => {
        const r = El(e, t, e.VERTEX_SHADER), a = El(e, o, e.FRAGMENT_SHADER), s = e.createProgram();
        e.attachShader(s, r), e.attachShader(s, a), e.linkProgram(s);
        const l = {};
        return i.forEach((t => {
            l[t] = e.getAttribLocation(s, t)
        })), n.forEach((t => {
            l[t] = e.getUniformLocation(s, t)
        })), {
            program: s, locations: l, destroy() {
                e.detachShader(s, r), e.detachShader(s, a), e.deleteShader(r), e.deleteShader(a), e.deleteProgram(s)
            }
        }
    }, Ll = e => "VIDEO" !== e.nodeName && (!!Tl() || Ml(e.width) && Ml(e.height)),
    Fl = (e, t, o, i) => (e.bindTexture(e.TEXTURE_2D, t), e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, e.RGBA, e.UNSIGNED_BYTE, o), ((e, t, o) => {
        e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, Ll(t) ? e.LINEAR_MIPMAP_LINEAR : e.LINEAR), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, o.filterParam), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, o.wrapParam), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, o.wrapParam), Ll(t) && e.generateMipmap(e.TEXTURE_2D)
    })(e, o, i), e.bindTexture(e.TEXTURE_2D, null), t),
    zl = (e, t = 1) => e ? [e[0], e[1], e[2], zo(e[3]) ? t * e[3] : t] : [0, 0, 0, 0], Dl = () => {
        const e = new Float32Array(16);
        return e[0] = 1, e[5] = 1, e[10] = 1, e[15] = 1, e
    }, Bl = (e, t, o, i, n, r, a) => {
        const s = 1 / (t - o), l = 1 / (i - n), c = 1 / (r - a);
        e[0] = -2 * s, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = -2 * l, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 2 * c, e[11] = 0, e[12] = (t + o) * s, e[13] = (n + i) * l, e[14] = (a + r) * c, e[15] = 1
    }, Ol = (e, t, o, i) => {
        e[12] = e[0] * t + e[4] * o + e[8] * i + e[12], e[13] = e[1] * t + e[5] * o + e[9] * i + e[13], e[14] = e[2] * t + e[6] * o + e[10] * i + e[14], e[15] = e[3] * t + e[7] * o + e[11] * i + e[15]
    }, Wl = (e, t) => {
        e[0] *= t, e[1] *= t, e[2] *= t, e[3] *= t, e[4] *= t, e[5] *= t, e[6] *= t, e[7] *= t, e[8] *= t, e[9] *= t, e[10] *= t, e[11] *= t
    }, Vl = (e, t) => {
        const o = Math.sin(t), i = Math.cos(t), n = e[4], r = e[5], a = e[6], s = e[7], l = e[8], c = e[9], d = e[10],
            u = e[11];
        e[4] = n * i + l * o, e[5] = r * i + c * o, e[6] = a * i + d * o, e[7] = s * i + u * o, e[8] = l * i - n * o, e[9] = c * i - r * o, e[10] = d * i - a * o, e[11] = u * i - s * o
    }, _l = (e, t) => {
        const o = Math.sin(t), i = Math.cos(t), n = e[0], r = e[1], a = e[2], s = e[3], l = e[8], c = e[9], d = e[10],
            u = e[11];
        e[0] = n * i - l * o, e[1] = r * i - c * o, e[2] = a * i - d * o, e[3] = s * i - u * o, e[8] = n * o + l * i, e[9] = r * o + c * i, e[10] = a * o + d * i, e[11] = s * o + u * i
    }, Nl = (e, t) => {
        const o = Math.sin(t), i = Math.cos(t), n = e[0], r = e[1], a = e[2], s = e[3], l = e[4], c = e[5], d = e[6],
            u = e[7];
        e[0] = n * i + l * o, e[1] = r * i + c * o, e[2] = a * i + d * o, e[3] = s * i + u * o, e[4] = l * i - n * o, e[5] = c * i - r * o, e[6] = d * i - a * o, e[7] = u * i - s * o
    };
var Hl = e => e * Math.PI / 180,
    jl = (e, t) => Tl() ? e.getContext("webgl2", t) : e.getContext("webgl", t) || e.getContext("experimental-webgl", t);
const Ul = (e, t) => {
    const o = e.length;
    return t >= o ? e[t % o] : t < 0 ? e[t % o + o] : e[t]
}, Gl = (e, t, o, i) => {
    const n = he(o.x - t.x, o.y - t.y), r = he(i.x - o.x, i.y - o.y), a = he(t.x - i.x, t.y - i.y),
        s = he(e.x - t.x, e.y - t.y), l = he(e.x - o.x, e.y - o.y), c = he(e.x - i.x, e.y - i.y), d = Me(n, s),
        u = Me(r, l), h = Me(a, c);
    return d <= 0 && u <= 0 && h <= 0
}, Zl = e => {
    if (e.length < 3) return [];
    if ((e => {
        const t = e.length;
        for (let o = 0; o < t; o++) {
            const t = Ze(e[o], Ul(e, o + 1));
            if (It(t, e, {ignoreIdenticalLines: !0, breakOnIntersection: !0})) return !0
        }
        return !1
    })(e)) return [];
    (e => {
        let t, o, i, n, r, a = 0;
        const s = e.length;
        for (t = 0; t < s; t++) o = e[t], i = e[(t + 1) % s], n = i.x - o.x, r = (i.y + o.y) / 2, a += n * r;
        return a
    })(e) < 0 && e.reverse();
    const t = e.length, o = [...Array(t).keys()], i = [];
    let n, r, a, s, l, c, d, u, h, p, m, g, $ = 1024;
    for (; o.length > 3;) {
        if ($ <= 0) return [];
        for ($--, n = 0; n < o.length; n++) if (a = o[n], s = Ul(o, n - 1), l = Ul(o, n + 1), c = e[a], d = e[s], u = e[l], h = he(d.x - c.x, d.y - c.y), p = he(u.x - c.x, u.y - c.y), !(Me(h, p) < 0)) {
            for (m = !0, r = 0; r < t; r++) if (r !== a && r !== s && r !== l && (g = e[r], Gl(g, d, c, u))) {
                m = !1;
                break
            }
            if (m) {
                i.push([d, c, u]), o.splice(n, 1);
                break
            }
        }
    }
    return i.push([e[o[0]], e[o[1]], e[o[2]]]), i
}, Xl = (e, t, o, i, n) => {
    const r = ye(he(i.x - o.x, i.y - o.y)), a = ye(he(n.x - i.x, n.y - i.y)), s = ye(he(r.x + a.x, r.y + a.y)),
        l = he(-s.y, s.x), c = he(-r.y, r.x), d = Math.min(1 / Te(l, c), 5);
    e[t] = i.x, e[t + 1] = i.y, e[t + 2] = l.x * d, e[t + 3] = l.y * d, e[t + 4] = -1, e[t + 5] = i.x, e[t + 6] = i.y, e[t + 7] = l.x * d, e[t + 8] = l.y * d, e[t + 9] = 1
}, Yl = e => {
    const t = new Float32Array(8);
    return t[0] = e[3].x, t[1] = e[3].y, t[2] = e[0].x, t[3] = e[0].y, t[4] = e[2].x, t[5] = e[2].y, t[6] = e[1].x, t[7] = e[1].y, t
}, ql = (e, t = 0, o, i) => {
    const n = St(e), r = e.x + .5 * e.width, a = e.y + .5 * e.height;
    return (o || i) && Ae(n, o, i, r, a), 0 !== t && Le(n, t, r, a), n
}, Kl = (e, t, o, i, n) => {
    const r = Math.min(20, Math.max(4, Math.round(i / 2)));
    let a = 0, s = 0, l = 0, c = 0, d = 0;
    for (; d < r; d++) a = d / r, s = n * Y + a * Y, l = i * Math.cos(s), c = i * Math.sin(s), e.push(he(t + l, o + c))
};
let Jl = null;
var Ql = () => {
    if (null !== Jl) return Jl;
    let e = m("canvas");
    const t = jl(e);
    return Jl = t ? t.getParameter(t.MAX_TEXTURE_SIZE) : void 0, $(e), e = void 0, Jl
}, ec = () => l() && !!window.chrome;
const tc = new Float32Array([0, 1, 0, 0, 1, 1, 1, 0]), oc = new Float32Array([1, 0, 0, 0, 1, 1, 0, 1]), ic = l() && z(),
    nc = [0, 0, 0, 0, 1, 0, 0, 0, 0], rc = [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0],
    ac = [0, 0, 0, 0], sc = [0, 0, 0, 0], lc = (e, t, o, i, n) => {
        if (!o || !i) return tc;
        let r = i.x / o.width, a = i.y / o.height, s = e / o.width / n, l = t / o.height / n;
        s -= r, l -= a;
        return new Float32Array([-r, l, -r, -a, s, l, s, -a])
    };
var cc = (e, t = {}) => {
    const {alpha: o = !1} = t, i = {width: 0, height: 0}, n = {width: 0, height: 0}, r = Ql() || 1024;
    let a, s, l;
    const c = Dl(), d = Dl();
    let u, h, p, m, g, f, y, b, x, v = 0, w = 0, S = 0, k = 1;
    const C = new Map([]), T = () => {
        R.stencilOp(R.KEEP, R.KEEP, R.KEEP), R.stencilFunc(R.ALWAYS, 1, 255), R.stencilMask(255)
    }, M = Hl(30), P = Math.tan(M / 2), R = jl(e, {alpha: o, antialias: !1, premultipliedAlpha: !0, stencil: !0});
    if (!R) return;
    R.getExtension("OES_standard_derivatives"), R.disable(R.DEPTH_TEST), R.enable(R.STENCIL_TEST), R.enable(R.BLEND), R.blendFunc(R.ONE, R.ONE_MINUS_SRC_ALPHA), R.pixelStorei(R.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !(!o && z())), T();
    const I = R.createTexture();
    R.bindTexture(R.TEXTURE_2D, I), R.texImage2D(R.TEXTURE_2D, 0, R.RGBA, 1, 1, 0, R.RGBA, R.UNSIGNED_BYTE, new Uint8Array(ac)), C.set(0, I);
    const E = R.createTexture();
    C.set(2, E);
    const A = R.createFramebuffer(), L = R.createTexture();
    C.set(1, L);
    const F = R.createFramebuffer(),
        D = Al(R, "\n##head\n##text\nvoid main(){vTexCoord=aTexCoord;gl_Position=uMatrix*aPosition;}", "\n##head\nin vec2 vTexCoord;uniform sampler2D uTexture;uniform sampler2D uTextureOverlay;uniform sampler2D uTextureBlend;uniform vec2 uTextureSize;uniform float uOpacity;uniform int uAntialias;uniform vec4 uOverlayColor;uniform mat4 uColorMatrix;uniform vec4 uColorOffset;uniform float uClarityKernel[9];uniform float uClarityKernelWeight;uniform float uColorGamma;uniform float uColorVignette;uniform float uMaskClip;uniform float uMaskOpacity;uniform float uMaskBounds[4];uniform float uMaskCornerRadius[4];uniform float uMaskFeather[8];vec4 applyGamma(vec4 c,float g){c.r=pow(c.r,g);c.g=pow(c.g,g);c.b=pow(c.b,g);return c;}vec4 applyColorMatrix(vec4 c,mat4 m,vec4 o){vec4 res=(c*m)+(o*c.a);res=clamp(res,0.0,1.0);return res;}vec4 applyConvolutionMatrix(vec4 c,float k0,float k1,float k2,float k3,float k4,float k5,float k6,float k7,float k8,float w){vec2 pixel=vec2(1)/uTextureSize;vec4 colorSum=texture(uTexture,vTexCoord-pixel)*k0+texture(uTexture,vTexCoord+pixel*vec2(0.0,-1.0))*k1+texture(uTexture,vTexCoord+pixel*vec2(1.0,-1.0))*k2+texture(uTexture,vTexCoord+pixel*vec2(-1.0,0.0))*k3+texture(uTexture,vTexCoord)*k4+texture(uTexture,vTexCoord+pixel*vec2(1.0,0.0))*k5+texture(uTexture,vTexCoord+pixel*vec2(-1.0,1.0))*k6+texture(uTexture,vTexCoord+pixel*vec2(0.0,1.0))*k7+texture(uTexture,vTexCoord+pixel)*k8;vec4 color=vec4(clamp((colorSum/w),0.0,1.0).rgb,c.a);return color;}vec4 blendPremultipliedAlpha(vec4 back,vec4 front){return front+(back*(1.0-front.a));}vec4 applyVignette(vec4 c,vec2 pos,vec2 center,float v){float d=distance(pos,center)/length(center);float f=1.0-(d*abs(v));if(v>0.0){c.rgb*=f;}else if(v<0.0){c.rgb+=(1.0-f)*(1.0-c.rgb);}return c;}void main(){float x=gl_FragCoord.x;float y=gl_FragCoord.y;float a=1.0;float maskTop=uMaskBounds[0];float maskRight=uMaskBounds[1];float maskBottom=uMaskBounds[2];float maskLeft=uMaskBounds[3];float leftFeatherOpacity=step(uMaskFeather[1],x)*uMaskFeather[0]+((1.0-uMaskFeather[0])*smoothstep(uMaskFeather[1],uMaskFeather[3],x));float rightFeatherOpacity=(1.0-step(uMaskFeather[7],x))*uMaskFeather[4]+((1.0-uMaskFeather[4])*smoothstep(uMaskFeather[7],uMaskFeather[5],x));a*=leftFeatherOpacity*rightFeatherOpacity;float overlayColorAlpha=(smoothstep(maskLeft,maskLeft+1.0,x)*(1.0-smoothstep(maskRight-1.0,maskRight,x))*(1.0-step(maskTop,y))*step(maskBottom,y));if(uOverlayColor.a==0.0){a*=overlayColorAlpha;}vec2 offset=vec2(maskLeft,maskBottom);vec2 size=vec2(maskRight-maskLeft,maskTop-maskBottom)*.5;vec2 center=offset.xy+size.xy;int pixelX=int(step(center.x,x));int pixelY=int(step(y,center.y));float cornerRadius=0.0;if(pixelX==0&&pixelY==0)cornerRadius=uMaskCornerRadius[0];if(pixelX==1&&pixelY==0)cornerRadius=uMaskCornerRadius[1];if(pixelX==0&&pixelY==1)cornerRadius=uMaskCornerRadius[2];if(pixelX==1&&pixelY==1)cornerRadius=uMaskCornerRadius[3];float cornerOffset=sign(cornerRadius)*length(max(abs(gl_FragCoord.xy-size-offset)-size+cornerRadius,0.0))-cornerRadius;float cornerOpacity=1.0-smoothstep(0.0,1.0,cornerOffset);a*=cornerOpacity;if(uAntialias==1){vec2 scaledPoint=vec2(vTexCoord.x*uTextureSize.x,vTexCoord.y*uTextureSize.y);a*=smoothstep(0.0,1.0,uTextureSize.x-scaledPoint.x);a*=smoothstep(0.0,1.0,uTextureSize.y-scaledPoint.y);a*=smoothstep(0.0,1.0,scaledPoint.x);a*=smoothstep(0.0,1.0,scaledPoint.y);}vec4 color=texture(uTexture,vTexCoord);if(uClarityKernelWeight!=-1.0){color=applyConvolutionMatrix(color,uClarityKernel[0],uClarityKernel[1],uClarityKernel[2],uClarityKernel[3],uClarityKernel[4],uClarityKernel[5],uClarityKernel[6],uClarityKernel[7],uClarityKernel[8],uClarityKernelWeight);}color=blendPremultipliedAlpha(color,texture(uTextureBlend,vTexCoord));color=applyGamma(color,uColorGamma);color=applyColorMatrix(color,uColorMatrix,uColorOffset);color*=a;if(uColorVignette!=0.0){vec2 pos=gl_FragCoord.xy-offset;color=applyVignette(color,pos,center-offset,uColorVignette);}color=blendPremultipliedAlpha(color,texture(uTextureOverlay,vTexCoord));if(overlayColorAlpha<=0.0){color*=1.0-uOverlayColor.a;}color*=uOpacity;fragColor=color;}", ["aPosition", "aTexCoord"], ["uMatrix", "uTexture", "uTextureBlend", "uTextureOverlay", "uTextureSize", "uColorGamma", "uColorVignette", "uColorOffset", "uColorMatrix", "uClarityKernel", "uClarityKernelWeight", "uOpacity", "uMaskOpacity", "uMaskBounds", "uMaskCornerRadius", "uMaskFeather", "uOverlayColor", "uAntialias"]),
        B = R.createBuffer(), O = R.createBuffer();
    R.bindBuffer(R.ARRAY_BUFFER, O), R.bufferData(R.ARRAY_BUFFER, tc, R.STATIC_DRAW);
    const W = R.createBuffer();
    R.bindBuffer(R.ARRAY_BUFFER, W), R.bufferData(R.ARRAY_BUFFER, oc, R.STATIC_DRAW);
    const V = Al(R, "#version 300 es\n\nin vec4 aPosition;in vec2 aNormal;in float aMiter;out vec2 vNormal;out float vMiter;out float vWidth;uniform float uWidth;uniform float uSharpness;uniform mat4 uMatrix;void main(){vMiter=aMiter;vNormal=aNormal;vWidth=(uWidth*.5)+uSharpness;gl_Position=uMatrix*vec4(aPosition.x+(aNormal.x*vWidth*aMiter),aPosition.y+(aNormal.y*vWidth*aMiter),0,1);}", "\n##head\n##mask\nin vec2 vNormal;in float vMiter;in float vWidth;uniform float uWidth;uniform vec4 uColor;uniform vec4 uCanvasColor;void main(){vec4 fillColor=uColor;float m=mask(gl_FragCoord.x,gl_FragCoord.y,uMaskBounds,uMaskOpacity);if(m<=0.0)discard;fillColor.a*=clamp(smoothstep(vWidth-.5,vWidth-1.0,abs(vMiter)*vWidth),0.0,1.0);fillColor.rgb*=fillColor.a;fillColor.rgb*=m;fillColor.rgb+=(1.0-m)*(uCanvasColor.rgb*fillColor.a);fragColor=fillColor;}", ["aPosition", "aNormal", "aMiter"], ["uColor", "uCanvasColor", "uMatrix", "uWidth", "uSharpness", "uMaskBounds", "uMaskOpacity"]),
        _ = R.createBuffer();
    ec() && (R.bindBuffer(R.ARRAY_BUFFER, _), R.bufferData(R.ARRAY_BUFFER, 1, R.DYNAMIC_DRAW));
    const N = (e, t, o, i = !1) => {
            const {program: n, locations: r} = V;
            R.useProgram(n), R.enableVertexAttribArray(r.aPosition), R.enableVertexAttribArray(r.aNormal), R.enableVertexAttribArray(r.aMiter);
            const a = ((e, t) => {
                    let o, i, n, r = 0;
                    const a = e.length, s = new Float32Array(10 * (t ? a + 1 : a)), l = e[0], c = e[a - 1];
                    for (r = 0; r < a; r++) o = e[r - 1], i = e[r], n = e[r + 1], o || (o = t ? c : he(i.x + (i.x - n.x), i.y + (i.y - n.y))), n || (n = t ? l : he(i.x + (i.x - o.x), i.y + (i.y - o.y))), Xl(s, 10 * r, o, i, n);
                    return t && Xl(s, 10 * a, c, l, e[1]), s
                })(e, i), s = 5 * Float32Array.BYTES_PER_ELEMENT, c = 2 * Float32Array.BYTES_PER_ELEMENT,
                d = 4 * Float32Array.BYTES_PER_ELEMENT;
            R.uniform1f(r.uWidth, t), R.uniform1f(r.uSharpness, l), R.uniform4fv(r.uColor, o), R.uniformMatrix4fv(r.uMatrix, !1, u), R.uniform4f(r.uCanvasColor, v, w, S, k), R.uniform1fv(r.uMaskBounds, y), R.uniform1f(r.uMaskOpacity, f), R.bindBuffer(R.ARRAY_BUFFER, _), R.bufferData(R.ARRAY_BUFFER, a, R.STATIC_DRAW), R.vertexAttribPointer(r.aPosition, 2, R.FLOAT, !1, s, 0), R.vertexAttribPointer(r.aNormal, 2, R.FLOAT, !1, s, c), R.vertexAttribPointer(r.aMiter, 1, R.FLOAT, !1, s, d), R.drawArrays(R.TRIANGLE_STRIP, 0, a.length / 5), R.disableVertexAttribArray(r.aPosition), R.disableVertexAttribArray(r.aNormal), R.disableVertexAttribArray(r.aMiter)
        },
        H = Al(R, "\n##head\nvoid main(){\n##matrix\n}", "\n##head\n##mask\nuniform vec4 uColor;uniform vec4 uCanvasColor;void main(){vec4 fillColor=uColor;\n##maskapply\nfillColor.rgb*=fillColor.a;fillColor.rgb*=m;fillColor.rgb+=(1.0-m)*(uCanvasColor.rgb*fillColor.a);fragColor=fillColor;}", ["aPosition"], ["uColor", "uCanvasColor", "uMatrix", "uMaskBounds", "uMaskOpacity"]),
        j = R.createBuffer(),
        U = Al(R, "\n##head\n##text\nin vec2 aRectCoord;out vec2 vRectCoord;void main(){vTexCoord=aTexCoord;vRectCoord=aRectCoord;\n##matrix\n}", "\n##head\n##mask\nin vec2 vTexCoord;in vec2 vRectCoord;uniform sampler2D uTexture;uniform vec4 uTextureColor;uniform float uTextureOpacity;uniform vec2 uRepeat;uniform vec4 uColor;uniform float uCornerRadius[4];uniform vec2 uSize;uniform vec2 uPosition;uniform vec4 uCanvasColor;uniform int uInverted;uniform float uEdgeFeather;void main(){\n##init\n##colorize\n##rectaa\n##cornerradius\n##maskfeatherapply\nif(uInverted==1)a=1.0-a;\n##maskapply\n##fragcolor\n}", ["aPosition", "aTexCoord", "aRectCoord"], ["uTexture", "uColor", "uMatrix", "uCanvasColor", "uTextureColor", "uTextureOpacity", "uRepeat", "uPosition", "uSize", "uMaskBounds", "uMaskOpacity", "uMaskFeather", "uCornerRadius", "uInverted", "uEdgeFeather"]),
        Z = R.createBuffer(), X = R.createBuffer(), Y = R.createBuffer(),
        q = Al(R, "\n##head\n##text\nout vec2 vTexCoordDouble;void main(){vTexCoordDouble=vec2(aTexCoord.x*2.0-1.0,aTexCoord.y*2.0-1.0);vTexCoord=aTexCoord;\n##matrix\n}", "\n##head\n##mask\nin vec2 vTexCoord;in vec2 vTexCoordDouble;uniform sampler2D uTexture;uniform float uTextureOpacity;uniform vec2 uTextureAdjust;uniform vec2 uRepeat;uniform vec2 uRadius;uniform vec4 uColor;uniform int uInverted;uniform vec4 uCanvasColor;void main(){\n##init\nfloat ar=uRadius.x/uRadius.y;vec2 rAA=vec2(uRadius.x-1.0,uRadius.y-(1.0/ar));vec2 scaledPointSq=vec2((vTexCoordDouble.x*uTextureAdjust.x*uRadius.x)*(vTexCoordDouble.x*uTextureAdjust.x*uRadius.x),(vTexCoordDouble.y*uTextureAdjust.y*uRadius.y)*(vTexCoordDouble.y*uTextureAdjust.y*uRadius.y));float p=(scaledPointSq.x/(uRadius.x*uRadius.x))+(scaledPointSq.y/(uRadius.y*uRadius.y));float pAA=(scaledPointSq.x/(rAA.x*rAA.x))+(scaledPointSq.y/(rAA.y*rAA.y));a=smoothstep(1.0,p/pAA,p);if(uInverted==1)a=1.0-a;\n##maskapply\n##fragcolor\n}", ["aPosition", "aTexCoord"], ["uTexture", "uTextureOpacity", "uTextureAdjust", "uRepeat", "uColor", "uCanvasColor", "uMatrix", "uRadius", "uInverted", "uMaskBounds", "uMaskOpacity"]),
        K = R.createBuffer(), J = R.createBuffer(), Q = new Map,
        ee = {2: {width: 0, height: 0}, 1: {width: 0, height: 0}}, te = (e, t, o, n = 1) => {
            const a = Math.min(Math.min(4096, r) / o.width, Math.min(4096, r) / o.height, n), l = Math.floor(a * o.width),
                c = Math.floor(a * o.height);
            _e(o, ee[e]) ? R.bindFramebuffer(R.FRAMEBUFFER, t) : (R.bindTexture(R.TEXTURE_2D, C.get(e)), R.texImage2D(R.TEXTURE_2D, 0, R.RGBA, l, c, 0, R.RGBA, R.UNSIGNED_BYTE, null), R.texParameteri(R.TEXTURE_2D, R.TEXTURE_MIN_FILTER, R.LINEAR), R.texParameteri(R.TEXTURE_2D, R.TEXTURE_WRAP_S, R.CLAMP_TO_EDGE), R.texParameteri(R.TEXTURE_2D, R.TEXTURE_WRAP_T, R.CLAMP_TO_EDGE), R.bindFramebuffer(R.FRAMEBUFFER, t), R.framebufferTexture2D(R.FRAMEBUFFER, R.COLOR_ATTACHMENT0, R.TEXTURE_2D, C.get(e), 0), ee[e] = o);
            const h = o.width * s, p = o.height * s;
            var m, g;
            Bl(d, 0, h, p, 0, -1, 1), Ol(d, 0, p, 0), g = 1, (m = d)[0] *= g, m[1] *= g, m[2] *= g, m[3] *= g, ((e, t) => {
                e[4] *= t, e[5] *= t, e[6] *= t, e[7] *= t
            })(d, -1), u = d, R.viewport(0, 0, l, c), R.colorMask(!0, !0, !0, !0), R.clearColor(0, 0, 0, 0), R.clear(R.COLOR_BUFFER_BIT), x = [1, 0, 1, 0, 1, Math.max(i.width, o.width), 1, Math.max(i.width, o.width)]
        }, oe = (e, t) => {
            const {forceRelease: o = !1} = t || {}, {src: i} = Q.get(e);
            i instanceof HTMLCanvasElement && (o || i.dataset.retain || $(i)), Q.delete(e), R.deleteTexture(e)
        }, ie = e => Q.get(e).isRotatedVideo;
    return {
        drawPath: (e, t = 0, o = !1, i = !1, n, r, a, l, c) => {
            if (e.length < 2) return;
            const d = e.map((e => ({x: e.x * s, y: e.y * s}))), h = n * s;
            if (h > 0 && N(d, h, zl(r, c), a), d.length < 3 || !l || 0 === l[3] || !a) return;
            const p = Zl(d), m = new Float32Array(6 * p.length);
            p.forEach((([e, t, o], i) => {
                const n = 6 * i;
                m[n + 0] = e.x, m[n + 1] = e.y, m[n + 2] = t.x, m[n + 3] = t.y, m[n + 4] = o.x, m[n + 5] = o.y
            })), ((e, t) => {
                const {program: o, locations: i} = H;
                R.useProgram(o), R.enableVertexAttribArray(i.aPosition), R.uniform4fv(i.uColor, t), R.uniformMatrix4fv(i.uMatrix, !1, u), R.uniform1fv(i.uMaskBounds, y), R.uniform1f(i.uMaskOpacity, f), R.uniform4f(i.uCanvasColor, v, w, S, k), R.bindBuffer(R.ARRAY_BUFFER, j), R.bufferData(R.ARRAY_BUFFER, e, R.STATIC_DRAW), R.vertexAttribPointer(i.aPosition, 2, R.FLOAT, !1, 0, 0), R.drawArrays(R.TRIANGLES, 0, e.length / 2), R.disableVertexAttribArray(i.aPosition)
            })(m, zl(l, c))
        },
        drawRect: (e, t = 0, o = !1, i = !1, n, r, a, l, c, d = !1, h, p, m, g, $, b = 1 / s, C, T) => {
            const M = ht(Je(e), s),
                P = n.map((t => ((e, t) => Math.floor(gs(e, 0, Math.min(.5 * (t.width - 1), .5 * (t.height - 1)))))(t || 0, e))).map((e => e * s));
            if (r || a) {
                const e = Je(M);
                e.x -= .5, e.y -= .5, e.width += 1, e.height += 1;
                const n = ql(e, t, o, i), p = Yl(n);
                let m;
                C && (m = zl(C), 0 === m[3] && (m[3] = .001));
                const E = l && d ? [e.width / l.width, e.height / l.height] : [1, 1];
                ((e, t, o, i, n, r = I, a, l = 1, c = ac, d = tc, h = x, p = 1, m) => {
                    const {program: g, locations: $} = U;
                    R.useProgram(g), R.enableVertexAttribArray($.aPosition), R.enableVertexAttribArray($.aTexCoord), R.enableVertexAttribArray($.aRectCoord), R.uniform4fv($.uColor, n), R.uniform2fv($.uSize, [t, o]), R.uniform2fv($.uPosition, [e[2], e[3]]), R.uniform2fv($.uRepeat, a), R.uniform1i($.uInverted, m ? 1 : 0), R.uniform1fv($.uCornerRadius, i), R.uniform4f($.uCanvasColor, v, w, S, k), R.uniform1fv($.uMaskFeather, h.map(((e, t) => t % 2 == 0 ? e : e * s))), R.uniform1fv($.uMaskBounds, y), R.uniform1f($.uMaskOpacity, f), R.uniform1f($.uEdgeFeather, Math.max(0, p)), R.uniformMatrix4fv($.uMatrix, !1, u), R.uniform1i($.uTexture, 4), R.uniform4fv($.uTextureColor, c), R.uniform1f($.uTextureOpacity, l), R.activeTexture(R.TEXTURE0 + 4), R.bindTexture(R.TEXTURE_2D, r), R.bindBuffer(R.ARRAY_BUFFER, X), R.bufferData(R.ARRAY_BUFFER, d, R.STATIC_DRAW), R.vertexAttribPointer($.aTexCoord, 2, R.FLOAT, !1, 0, 0), R.bindBuffer(R.ARRAY_BUFFER, Y), R.bufferData(R.ARRAY_BUFFER, tc, R.STATIC_DRAW), R.vertexAttribPointer($.aRectCoord, 2, R.FLOAT, !1, 0, 0), R.bindBuffer(R.ARRAY_BUFFER, Z), R.bufferData(R.ARRAY_BUFFER, e, R.STATIC_DRAW), R.vertexAttribPointer($.aPosition, 2, R.FLOAT, !1, 0, 0), R.drawArrays(R.TRIANGLE_STRIP, 0, e.length / 2), R.disableVertexAttribArray($.aPosition), R.disableVertexAttribArray($.aTexCoord), R.disableVertexAttribArray($.aRectCoord)
                })(p, e.width, e.height, P, zl(r, g), a, E, g, m, h ? new Float32Array(h) : lc(e.width, e.height, l, c, s), $, b * s, T)
            }
            p && (p = Math.min(p, M.width, M.height), N(((e, t, o, i, n, r, a, s) => {
                const l = [];
                if (r.every((e => 0 === e))) l.push(he(e, t), he(e + o, t), he(e + o, t + i), he(e, t + i)); else {
                    const [n, a, s, c] = r, d = e, u = e + o, h = t, p = t + i;
                    l.push(he(d + n, h)), Kl(l, u - a, h + a, a, -1), l.push(he(u, h + a)), Kl(l, u - c, p - c, c, 0), l.push(he(u - c, p)), Kl(l, d + s, p - s, s, 1), l.push(he(d, p - s)), Kl(l, d + n, h + n, n, 2)
                }
                return (a || s) && Ae(l, a, s, e + .5 * o, t + .5 * i), n && Le(l, n, e + .5 * o, t + .5 * i), l
            })(M.x, M.y, M.width, M.height, t, P, o, i), p * s, zl(m, g), !0))
        },
        drawEllipse: (e, t, o, i, n, r, a, l, c, d, h, p, m, g, $) => {
            const b = ht(at(e.x - t, e.y - o, 2 * t, 2 * o), s);
            if (a || l) {
                const e = Je(b);
                $ || (e.x -= .5, e.y -= .5, e.width += 1, e.height += 1);
                const t = ql(e, i, n, r);
                ((e, t, o, i, n = I, r, a = tc, l = 1, c = !1) => {
                    const {program: d, locations: h} = q;
                    R.useProgram(d), R.enableVertexAttribArray(h.aPosition), R.enableVertexAttribArray(h.aTexCoord), R.uniformMatrix4fv(h.uMatrix, !1, u), R.uniform2fv(h.uRadius, [.5 * t, .5 * o]), R.uniform2fv(h.uTextureAdjust, [r.width / (t / s), r.height / (o / s)]), R.uniform1i(h.uInverted, c ? 1 : 0), R.uniform4fv(h.uColor, i), R.uniform4f(h.uCanvasColor, v, w, S, k), R.uniform2fv(h.uRepeat, [1, 1]), R.uniform1fv(h.uMaskBounds, y), R.uniform1f(h.uMaskOpacity, f), R.uniform1i(h.uTexture, 4), R.uniform1f(h.uTextureOpacity, l), R.activeTexture(R.TEXTURE0 + 4), R.bindTexture(R.TEXTURE_2D, n), R.bindBuffer(R.ARRAY_BUFFER, J), R.bufferData(R.ARRAY_BUFFER, a, R.STATIC_DRAW), R.vertexAttribPointer(h.aTexCoord, 2, R.FLOAT, !1, 0, 0), R.bindBuffer(R.ARRAY_BUFFER, K), R.bufferData(R.ARRAY_BUFFER, e, R.STATIC_DRAW), R.vertexAttribPointer(h.aPosition, 2, R.FLOAT, !1, 0, 0), R.drawArrays(R.TRIANGLE_STRIP, 0, e.length / 2), R.disableVertexAttribArray(h.aPosition), R.disableVertexAttribArray(h.aTexCoord)
                })(Yl(t), e.width, e.height, zl(a, g), l, c || Ve(e.width / s, e.height / s), h ? new Float32Array(h) : lc(e.width, e.height, c, d, s), g, $)
            }
            p && N(((e, t, o, i, n, r, a) => {
                const s = .5 * Math.abs(o), l = .5 * Math.abs(i), c = Math.abs(o) + Math.abs(i),
                    d = Math.max(20, Math.round(c / 6));
                return Dt(he(e + s, t + l), s, l, n, r, a, d)
            })(b.x, b.y, b.width, b.height, i, n, r), p * s, zl(m, g), !0)
        },
        drawImage: (e, t, o, n, r, l, c, d, u, h, p = rc, m = 1, g, $ = 1, x = 0, v = b, w = sc, S = ac, k = !1, T = !1, I = !0) => {
            const E = t.width * s, A = t.height * s, L = -.5 * E, F = .5 * A, z = .5 * E, V = -.5 * A,
                _ = new Float32Array([L, V, 0, L, F, 0, z, V, 0, z, F, 0]);
            R.bindBuffer(R.ARRAY_BUFFER, B), R.bufferData(R.ARRAY_BUFFER, _, R.STATIC_DRAW);
            const N = t.height / 2 / P * (i.height / t.height) * -1;
            r *= s, l *= s, o *= s, n *= s;
            const {program: H, locations: j} = D, U = Dl();
            ((e, t, o, i, n) => {
                const r = 1 / Math.tan(t / 2), a = 1 / (i - n);
                e[0] = r / o, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = r, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = (n + i) * a, e[11] = -1, e[12] = 0, e[13] = 0, e[14] = 2 * n * i * a, e[15] = 0
            })(U, M, a, 1, 2 * -N), Ol(U, r, -l, N), Ol(U, o, -n, 0), Nl(U, -u), Wl(U, h), Ol(U, -o, n, 0), _l(U, d), Vl(U, c), R.useProgram(H), R.enableVertexAttribArray(j.aPosition), R.enableVertexAttribArray(j.aTexCoord), R.uniform1i(j.uTexture, 3), R.uniform2f(j.uTextureSize, t.width, t.height), R.activeTexture(R.TEXTURE0 + 3), R.bindTexture(R.TEXTURE_2D, e);
            const G = T ? 1 : 0, Z = C.get(G);
            R.uniform1i(j.uTextureBlend, G), R.activeTexture(R.TEXTURE0 + G), R.bindTexture(R.TEXTURE_2D, Z);
            const X = k ? 2 : 0, Y = C.get(X);
            R.uniform1i(j.uTextureOverlay, X), R.activeTexture(R.TEXTURE0 + X), R.bindTexture(R.TEXTURE_2D, Y), R.bindBuffer(R.ARRAY_BUFFER, B), R.vertexAttribPointer(j.aPosition, 3, R.FLOAT, !1, 0, 0);
            const q = ic && ie(e);
            let K;
            R.bindBuffer(R.ARRAY_BUFFER, q ? W : O), R.vertexAttribPointer(j.aTexCoord, 2, R.FLOAT, !1, 0, 0), R.uniformMatrix4fv(j.uMatrix, !1, U), R.uniform4fv(j.uOverlayColor, S), !g || xs(g, nc) ? (g = nc, K = -1) : (K = g.reduce(((e, t) => e + t), 0), K = K <= 0 ? 1 : K), R.uniform1fv(j.uClarityKernel, g), R.uniform1f(j.uClarityKernelWeight, K), R.uniform1f(j.uColorGamma, 1 / $), R.uniform1f(j.uColorVignette, x), R.uniform1i(j.uAntialias, I ? 1 : 0), R.uniform4f(j.uColorOffset, p[4], p[9], p[14], p[19]), R.uniformMatrix4fv(j.uColorMatrix, !1, [p[0], p[1], p[2], p[3], p[5], p[6], p[7], p[8], p[10], p[11], p[12], p[13], p[15], p[16], p[17], p[18]]), R.uniform1f(j.uOpacity, m), R.uniform1f(j.uMaskOpacity, f), R.uniform1fv(j.uMaskBounds, y), R.uniform1fv(j.uMaskCornerRadius, w.map((e => e * s))), R.uniform1fv(j.uMaskFeather, v.map(((e, t) => t % 2 == 0 ? e : e * s))), R.drawArrays(R.TRIANGLE_STRIP, 0, 4), R.disableVertexAttribArray(j.aPosition), R.disableVertexAttribArray(j.aTexCoord)
        },
        textureFilterNearest: R.NEAREST,
        textureFilterLinear: R.LINEAR,
        textureClamp: R.CLAMP_TO_EDGE,
        textureRepeat: R.REPEAT,
        textureCreate: () => R.createTexture(),
        textureUpdate: (e, t, o) => (Q.set(e, {
            src: t,
            options: o,
            isRotatedVideo: "VIDEO" === t.nodeName && (t.dataset && 90 == t.dataset.rotation || 270 == t.dataset.rotation)
        }), Fl(R, e, t, o)),
        textureGetSize: e => {
            const {src: t, options: o} = Q.get(e), i = De(t);
            return o.scalar ? Ge(i, (e => e / o.scalar)) : i
        },
        textureDelete: oe,
        enablePreviewStencil: () => {
            R.stencilOp(R.KEEP, R.KEEP, R.REPLACE), R.stencilFunc(R.ALWAYS, 1, 255), R.stencilMask(255)
        },
        applyPreviewStencil: () => {
            R.stencilFunc(R.EQUAL, 1, 255), R.stencilMask(0)
        },
        disablePreviewStencil: T,
        setCanvasColor(e) {
            v = e[0], w = e[1], S = e[2], k = o ? e[3] : 1, R.clear(R.COLOR_BUFFER_BIT)
        },
        resetCanvasMatrix: () => {
            Bl(c, 0, i.width, i.height, 0, -1, 1)
        },
        updateCanvasMatrix(e, t, o, n, r) {
            const a = e.width, l = e.height, d = i.width * (.5 / s), u = i.height * (.5 / s),
                h = {x: d + (o.x + t.x), y: u + (o.y + t.y)}, p = {x: h.x - t.x, y: h.y - t.y}, m = .5 * a, g = .5 * l;
            $e(p, r.z, h), Ie(p, n, h);
            Ol(c, (p.x - m) * s, (p.y - g) * s, 0), Ol(c, m * s, g * s, 0), Nl(c, r.z);
            const $ = r.x > Math.PI / 2;
            Vl(c, $ ? Math.PI : 0);
            const f = r.y > Math.PI / 2;
            _l(c, f ? Math.PI : 0), Wl(c, n), Ol(c, -m * s, -g * s, 0)
        },
        drawToCanvas() {
            R.bindFramebuffer(R.FRAMEBUFFER, null), u = c, R.viewport(0, 0, R.drawingBufferWidth, R.drawingBufferHeight), R.colorMask(!0, !0, !0, !0), R.clearColor(v, w, S, k), R.clear(R.COLOR_BUFFER_BIT), x = [1, 0, 1, 0, 1, i.width, 1, i.width]
        },
        drawToImageBlendBuffer(e, t) {
            te(1, F, e, t)
        },
        drawToImageOverlayBuffer(e, t) {
            te(2, A, e, t)
        },
        enableMask(e, t) {
            const o = e.x * s, n = e.y * s, r = e.width * s, a = e.height * s;
            g = o, p = g + r, h = i.height - n, m = i.height - (n + a), f = 1 - t, y = [h, p, m, g]
        },
        disableMask() {
            g = 0, p = i.width, h = i.height, m = 0, f = 1, y = [h, p, m, g]
        },
        resize: (t, o, r) => {
            s = Math.max(1, r), l = 1 === s ? .75 : 1, n.width = t, n.height = o, i.width = t * s, i.height = o * s, a = G(i.width, i.height), e.width = i.width, e.height = i.height, Bl(c, 0, i.width, i.height, 0, -1, 1), b = [1, 0, 1, 0, 1, n.width, 1, n.width]
        },
        release() {
            Array.from(Q.keys()).forEach((e => oe(e, {forceRelease: !0}))), Q.clear(), C.forEach((e => {
                R.deleteTexture(e)
            })), C.clear(), D.destroy(), V.destroy(), H.destroy(), U.destroy(), q.destroy(), e.width = 1, e.height = 1, e = void 0
        }
    }
}, dc = e => e % 2 == 0 ? e : e + 1;
var uc = (e, t, o) => {
    const {targetCanvas: i, targetSize: n, disableDraw: r = !1, shapePreprocessor: a} = o || {},
        s = i || document.createElement("canvas"), {crop: l, colorMatrix: c, convolutionMatrix: d} = t, u = oo(e),
        h = {width: u ? e.videoWidth : e.width, height: u ? e.videoHeight : e.height}, {
            upscale: p = !1,
            fit: g = "contain",
            width: $,
            height: f
        } = n || {};
    let y = 1;
    "contain" === g ? y = Math.min(($ || Number.MAX_SAFE_INTEGER) / l.width, (f || Number.MAX_SAFE_INTEGER) / l.height) : "cover" === g && (y = Math.max(($ || l.width) / l.width, (f || l.height) / l.height)), p || (y = Math.min(y, 1));
    const b = "force" === g ? $ : Math.floor(l.width * y), x = "force" === g ? f : Math.floor(l.height * y),
        v = u ? dc(b) : b, w = u ? dc(x) : x, S = cc(s, {alpha: !0});
    S.resize(v, w, 1);
    const k = S.textureCreate();
    let C;
    S.setCanvasColor([0, 0, 0, 0]), S.drawToCanvas(), S.disableMask(), S.disablePreviewStencil();
    {
        const e = Object.values(c || {}).filter(Boolean);
        e.length && (C = Qn(e))
    }
    const T = {x: 0, y: 0, width: v, height: w}, {
            origin: M,
            translation: P,
            rotation: R,
            scale: I
        } = kl(T, T, h, l, {x: 0, y: 0, width: v, height: w}, y, {x: 0, y: 0}, 1, t.rotation, t.flipX, t.flipY),
        E = [h, M.x, M.y, P.x, P.y, R.x, R.y, R.z, I, C, 1, d && d.clarity, zo(t.gamma) ? t.gamma : 1, t.vignette || 0, [1, 0, 1, 0, 1, w, 1, v], void 0, void 0, void 0, void 0, !1];
    let A = !1;
    const L = t.decoration.length || t.annotation.length, F = L && S.textureCreate(), z = () => {
        S.textureUpdate(k, e, {filterParam: S.textureFilterLinear, wrapParam: S.textureClamp})
    }, D = () => {
        z(), S.drawImage(k, ...E), L && A && S.drawRect(T, 0, !1, !1, [0, 0, 0, 0], void 0, F)
    };
    return z(), !r && D(), {
        canvas: s, prepare: async () => {
            if (!L) return;
            const {dest: e} = await zs(m("canvas", h), {
                shapePreprocessor: a,
                imageReader: [[async (e, t, o) => {
                    const {src: i} = e, n = parseInt(i.width, 10), r = parseInt(i.height, 10), a = await O(i);
                    return {...e, dest: a, size: {width: n, height: r}}
                }, "read-canvas"]],
                imageWriter: Sl({format: "canvas"}),
                imageState: {
                    ...t,
                    redaction: [],
                    frame: void 0,
                    gamma: void 0,
                    convolutionMatrix: void 0,
                    colorMatrix: void 0,
                    backgroundColor: [0, 0, 0, 0],
                    backgroundImage: void 0,
                    trim: void 0,
                    vignette: void 0,
                    volume: void 0
                }
            });
            S.textureUpdate(F, e, {filterParam: S.textureFilterLinear, wrapParam: S.textureClamp}), A = !0, !r && D()
        }, redraw: D, destroy: () => {
            S.release()
        }
    }
}, hc = (e, t) => {
    const {imageData: o, amount: i = 1} = e, n = Math.round(2 * Math.max(1, i)), r = Math.round(.5 * n), a = o.width,
        s = o.height, l = new Uint8ClampedArray(a * s * 4), c = o.data;
    let d, u, h, p, m, g = 0, $ = 0, f = 0;
    const y = a * s * 4 - 4;
    for (h = 0; h < s; h++) for (d = crypto.getRandomValues(new Uint8ClampedArray(s)), u = 0; u < a; u++) p = d[h] / 255, $ = 0, f = 0, p < .5 && ($ = 4 * (-r + Math.round(Math.random() * n))), p > .5 && (f = (-r + Math.round(Math.random() * n)) * (4 * a)), m = Math.min(Math.max(0, g + $ + f), y), l[g] = c[m], l[g + 1] = c[m + 1], l[g + 2] = c[m + 2], l[g + 3] = c[m + 3], g += 4;
    t(null, {data: l, width: o.width, height: o.height})
};
const pc = [.0625, .125, .0625, .125, .25, .125, .0625, .125, .0625];

function mc(e) {
    return Math.sqrt(1 - --e * e)
}

function gc(e) {
    return "[object Date]" === Object.prototype.toString.call(e)
}

function $c(e, t) {
    if (e === t || e != e) return () => e;
    const o = typeof e;
    if (o !== typeof t || Array.isArray(e) !== Array.isArray(t)) throw new Error("Cannot interpolate values of different type");
    if (Array.isArray(e)) {
        const o = t.map(((t, o) => $c(e[o], t)));
        return e => o.map((t => t(e)))
    }
    if ("object" === o) {
        if (!e || !t) throw new Error("Object cannot be null");
        if (gc(e) && gc(t)) {
            e = e.getTime();
            const o = (t = t.getTime()) - e;
            return t => new Date(e + t * o)
        }
        const o = Object.keys(t), i = {};
        return o.forEach((o => {
            i[o] = $c(e[o], t[o])
        })), e => {
            const t = {};
            return o.forEach((o => {
                t[o] = i[o](e)
            })), t
        }
    }
    if ("number" === o) {
        const o = t - e;
        return t => e + t * o
    }
    throw new Error(`Cannot interpolate ${o} values`)
}

function fc(e, t = {}) {
    const o = Ya(e);
    let i, n = e;

    function r(r, a) {
        if (null == e) return o.set(e = r), Promise.resolve();
        n = r;
        let s = i, l = !1, {delay: c = 0, duration: d = 400, easing: u = or, interpolate: h = $c} = ir(ir({}, t), a);
        if (0 === d) return s && (s.abort(), s = null), o.set(e = n), Promise.resolve();
        const p = kr() + c;
        let m;
        return i = Pr((t => {
            if (t < p) return !0;
            l || (m = h(e, r), "function" == typeof d && (d = d(e, r)), l = !0), s && (s.abort(), s = null);
            const i = t - p;
            return i > d ? (o.set(e = r), !1) : (o.set(e = m(u(i / d))), !0)
        })), i.promise
    }

    return {set: r, update: (t, o) => r(t(n, e), o), subscribe: o.subscribe}
}

function yc(e, t, o, i) {
    if ("number" == typeof o) {
        const n = i - o, r = (o - t) / (e.dt || 1 / 60),
            a = (r + (e.opts.stiffness * n - e.opts.damping * r) * e.inv_mass) * e.dt;
        return Math.abs(a) < e.opts.precision && Math.abs(n) < e.opts.precision ? i : (e.settled = !1, o + a)
    }
    if (Oo(o)) return o.map(((n, r) => yc(e, t[r], o[r], i[r])));
    if ("object" == typeof o) {
        const n = {};
        for (const r in o) n[r] = yc(e, t[r], o[r], i[r]);
        return n
    }
    throw new Error(`Cannot spring ${typeof o} values`)
}

function bc(e, t = {}) {
    const o = Ya(e), {stiffness: i = .15, damping: n = .8, precision: r = .01} = t;
    let a, s, l, c = e, d = e, u = 1, h = 0, p = !1;

    function m(t, i = {}) {
        d = t;
        const n = l = {};
        if (null == e || i.hard || g.stiffness >= 1 && g.damping >= 1) return p = !0, a = null, c = t, o.set(e = d), Promise.resolve();
        if (i.soft) {
            const e = !0 === i.soft ? .5 : +i.soft;
            h = 1 / (60 * e), u = 0
        }
        if (!s) {
            a = null, p = !1;
            const t = {inv_mass: void 0, opts: g, settled: !0, dt: void 0};
            s = Pr((i => {
                if (null === a && (a = i), p) return p = !1, s = null, !1;
                u = Math.min(u + h, 1), t.inv_mass = u, t.opts = g, t.settled = !0, t.dt = 60 * (i - a) / 1e3;
                const n = yc(t, c, e, d);
                return a = i, c = e, o.set(e = n), t.settled && (s = null), !t.settled
            }))
        }
        return new Promise((e => {
            s.promise.then((() => {
                n === l && e()
            }))
        }))
    }

    const g = {set: m, update: (t, o) => m(t(d, e), o), subscribe: o.subscribe, stiffness: i, damping: n, precision: r};
    return g
}

var xc = Xa(!1, (e => {
    const t = window.matchMedia("(prefers-reduced-motion:reduce)"), o = () => e(t.matches);
    return o(), t.addListener(o), () => t.removeListener(o)
})), vc = () => "ResizeObserver" in window;
const wc = Qe(), Sc = (e, t, o, i, n) => {
    e.rect || (e.rect = Qe());
    const r = e.rect;
    gt(wc, t, o, i, n), pt(r, wc) || ($t(r, wc), e.dispatchEvent(new CustomEvent("measure", {detail: r})))
}, kc = Math.round, Cc = e => {
    const t = e.getBoundingClientRect();
    Ic && Sc(e, kc(t.x), kc(t.y), kc(t.width), kc(t.height))
}, Tc = e => {
    Ic && Sc(e, e.offsetLeft, e.offsetTop, e.offsetWidth, e.offsetHeight)
}, Mc = [];
let Pc, Rc, Ic = void 0;

function Ec() {
    Mc.length ? (Mc.forEach((e => e.measure(e))), Ic = requestAnimationFrame(Ec)) : Ic = void 0
}

let Ac = new Map([]), Lc = 0, Fc = 0;
var zc = (e, t = {}) => {
    const {observePosition: o = !1, observeViewRect: i = !1, once: n = !1, disabled: r = !1, isMeasureRoot: a = !1} = t;
    if (vc() && a && (Rc || (Rc = new ResizeObserver((e => {
        e.forEach((e => {
            Ac.set(e.target, e.contentRect)
        }));
        const t = Array.from(Ac.values()).some((({width: e, height: t}) => e > 0 && t > 0));
        t ? t && !1 === Ic && Ec() : (Ic && cancelAnimationFrame(Ic), Ic = !1)
    }))), Rc.observe(e), Lc++), !r) return !vc() || o || i ? (e.measure = i ? Cc : Tc, Mc.push(e), void 0 === Ic && (Ic = requestAnimationFrame(Ec)), e.measure(e), {
        destroy() {
            a && Rc && (Ac.delete(e), Rc.unobserve(e), Lc--, 0 === Lc && (Rc.disconnect(), Rc = void 0));
            const t = Mc.indexOf(e);
            Mc.splice(t, 1), delete e.measure
        }
    }) : (Pc || (Pc = new ResizeObserver((e => {
        e.forEach((e => {
            Ic && Tc(e.target)
        }))
    }))), Pc.observe(e), Tc(e), n ? Pc.unobserve(e) : Fc++, {
        destroy() {
            a && Rc && (Ac.delete(e), Rc.unobserve(e), Lc--, 0 === Lc && (Rc.disconnect(), Rc = void 0)), n || (Pc.unobserve(e), Fc--, 0 === Fc && (Pc.disconnect(), Pc = void 0))
        }
    })
}, Dc = e => {
    let t = void 0;
    const o = {
        pointerdown: () => {
            t = !1
        }, keydown: () => {
            t = !0
        }, keyup: () => {
            t = !1
        }, focus: e => {
            !1 !== t && (e.target.dataset.focusVisible = "")
        }, blur: e => {
            delete e.target.dataset.focusVisible
        }
    };
    return Object.keys(o).forEach((t => e.addEventListener(t, o[t], !0))), {
        destroy() {
            Object.keys(o).forEach((t => e.removeEventListener(t, o[t], !0)))
        }
    }
};
const Bc = e => /^http/.test(e),
    Oc = e => new Promise(((t, o) => "file" === e.kind ? t(e.getAsFile()) : "string" === e.kind ? e.getAsString(t) : void o()));
var Wc = (e, t = {}) => {
    const o = e => {
        e.preventDefault()
    }, i = async o => {
        o.preventDefault(), o.stopPropagation();
        try {
            const i = await (e => new Promise(((t, o) => {
                const {items: i} = e.dataTransfer;
                if (!i) return t([]);
                const n = Array.from(i).some((e => "text/uri-list" === e.type)),
                    r = Array.from(i).filter((e => ("file" === e.kind || "string" === e.kind) && "text/x-moz-url" !== e.type)).map(Oc);
                Promise.all(r).then((e => {
                    if (n) return t([e.find(Bc)].filter(Boolean));
                    const o = e.filter((e => jo(e) && eo(e) || Bc(e)));
                    t(o)
                })).catch(o)
            })))(o);
            e.dispatchEvent(new CustomEvent("dropfiles", {detail: {event: o, resources: i}, ...t}))
        } catch (e) {
        }
    };
    return e.addEventListener("drop", i), e.addEventListener("dragover", o), {
        destroy() {
            e.removeEventListener("drop", i), e.removeEventListener("dragover", o)
        }
    }
};
let Vc = null;
var _c = () => {
    if (null === Vc) if (l()) {
        const e = m("canvas");
        Vc = !jl(e, {failIfMajorPerformanceCaveat: !0}), $(e)
    } else Vc = !1;
    return Vc
}, Nc = e => e instanceof WebGLTexture, Hc = ([e, t, o, i]) => [i.x, i.y, e.x, e.y, o.x, o.y, t.x, t.y];

function jc(e) {
    let t, o, i, n;
    return {
        c() {
            t = Fr("div"), o = Fr("canvas"), Nr(t, "class", "PinturaCanvas")
        }, m(r, a) {
            Ar(r, t, a), Rr(t, o), e[37](o), i || (n = [Wr(o, "measure", e[38]), wr(zc.call(null, o))], i = !0)
        }, p: tr, i: tr, o: tr, d(o) {
            o && Lr(t), e[37](null), i = !1, ar(n)
        }
    }
}

function Uc(e, t, o) {
    let n, r, a, s, c, d, u;
    const p = [0, 0, 0, 0], g = ue(), y = l() && (e => {
        const t = .5 * e, o = m("canvas", {"data-retain": !0, width: e, height: e}), i = o.getContext("2d");
        return i.fillStyle = "#f0f", i.fillRect(0, 0, t, t), i.fillRect(t, t, t, t), o
    })(128), b = sa();
    let x, {isAnimated: v} = t, {isTransparent: w} = t, {maskRect: S} = t, {maskOpacity: k = 1} = t, {maskFrameOpacity: C = .95} = t, {maskMarkupOpacity: T = 1} = t, {clipAnnotationsToImage: M = !0} = t, {pixelRatio: P = 1} = t, {textPixelRatio: R = P} = t, {backgroundColor: I} = t, {willRender: E = Z} = t, {didRender: A = Z} = t, {willRequest: L} = t, {csp: F} = t, {loadImageData: D = Z} = t, {enableGrid: B = !1} = t, {gridColors: O} = t, {gridSize: W} = t, {gridOpacity: V = 0} = t, {images: _ = []} = t, {interfaceImages: N = []} = t, {selectionColor: H} = t,
        j = null, U = null, X = null;
    const Y = (e, t) => e.set(t, {hard: !v}), q = {precision: 1e-4 * .01};
    let K = 0;
    const J = fc(void 0, {duration: 0});
    pr(e, J, (e => o(36, u = e)));
    const Q = bc(1, q);
    pr(e, Q, (e => o(35, c = e)));
    const ee = bc(1, q);
    pr(e, ee, (e => o(51, a = e)));
    const te = Ya();
    pr(e, te, (e => o(53, d = e)));
    const oe = Ya();
    pr(e, oe, (e => o(52, s = e)));
    const ie = {}, ne = (e, t) => {
        let o = ie[e.id];
        const i = Math.min(1, 2048 / t.width);
        let n = o ? o.element : m("canvas", {width: t.width * i, height: t.height * i, "data-retain": !0});
        if (!o || ((e, t) => {
            if (e.total !== t.length) return !0;
            const o = e.last, i = t[t.length - 1];
            return o.drawMode !== i.drawMode || !(!Pi(o) || Pi(i) && pt(o, i)) || !(!Ri(o) || Ri(i) && o.x === i.x && o.y === i.y && o.rx === i.rx && o.ry === i.ry) || !(!Ei(o) || Ei(i) && i.points.length === o.points.length)
        })(o, e.actions)) {
            n = n.cloneNode(), ((e, t, o) => {
                const {selectionColor: i = [1, 1, 1], scalar: n = 1} = o || {};
                let r = !1;
                for (const o of t) {
                    const t = "subtract" === o.drawMode;
                    if (t && !r) continue;
                    e.globalCompositeOperation = t ? "destination-out" : "source-over", e.save(), e.beginPath();
                    const a = In(o);
                    ko(e, n, n), So(e, o.rotation, a), Xn(e, o.flipX, o.flipY, a), o.width ? Nn(e, {
                        ...o,
                        backgroundColor: i
                    }) : o.points ? Zn(e, Object.assign({}, o, o.pathClose ? {
                        backgroundColor: i,
                        strokeColor: [0, 0, 0, 0]
                    } : {strokeColor: i, strokeJoin: "round", strokeCap: "round"})) : o.rx && Hn(e, {
                        ...o,
                        backgroundColor: i,
                        strokeColor: [0, 0, 0, 0],
                        strokeJoin: "round",
                        strokeCap: "round"
                    }), e.restore(), r = !0
                }
            })(n.getContext("2d"), e.actions, {selectionColor: [1, 0, 1], scalar: i});
            const t = e.actions.length;
            ie[e.id] = {total: t, last: {...e.actions[t - 1]}, element: n}
        }
        return {x: 0, y: 0, ...t, fillColor: e.color || [1, 1, 1], backgroundImage: n}
    };
    let re;
    const ae = () => {
        cancelAnimationFrame(re), re = requestAnimationFrame((() => {
            Pe = !0, Ne = 0, r()
        }))
    }, se = new Map([]), le = new Map([]), ce = (e, t) => ({
        filterParam: "pixelated" === e ? j.textureFilterNearest : j.textureFilterLinear,
        wrapParam: "repeat" === t ? j.textureRepeat : j.textureClamp
    }), de = (e, t, o) => {
        if (!se.has(e)) {
            se.set(e, e);
            const n = ce(t, o);
            if (!h(i = e) && (mo(i) || f(i) || An(i) || oo(i))) {
                const t = j.textureCreate();
                j.textureUpdate(t, e, n), se.set(e, t)
            } else D(e).then((t => {
                if (!j || !t) return;
                const o = j.textureCreate();
                j.textureUpdate(o, t, n), se.set(e, o), ae()
            })).catch((t => {
                se.set(e, t)
            }))
        }
        var i, n;
        if (oo(e) && ((n = e).currentTime > 0 && !n.paused && !n.ended && n.readyState > 2 || "true" === e.dataset.redraw)) {
            const i = se.get(e), n = ce(t, o);
            return j.textureUpdate(i, e, n), e.dataset.redraw = !1, i
        }
        return se.get(e)
    }, pe = (e, t = {}) => {
        const o = t.id || e.id;
        if (e.width && e.width < 1 || e.height && e.height < 1 || !e.text.length) return void le.delete(o);
        let {
            text: i,
            textAlign: n,
            fontFamily: r,
            fontSize: a = 16,
            fontWeight: s,
            fontVariant: l,
            fontStyle: c,
            letterSpacing: d,
            lineHeight: u = a,
            width: h,
            height: p
        } = e, {
            outline: g = 0,
            blur: $ = 0,
            paddingTop: f = 0,
            paddingRight: y = 0,
            paddingBottom: b = 0,
            paddingLeft: x = 0
        } = t;
        h = zo(h) ? Math.floor(h) : h, p = zo(p) ? Math.floor(p) : p;
        const {textSize: v, signature: w} = ((e = "", t) => {
            let {
                width: o = 0,
                height: i = "auto",
                fontSize: n,
                fontFamily: r,
                lineHeight: a,
                fontWeight: s,
                fontStyle: l,
                fontVariant: c,
                letterSpacing: d
            } = t;
            const u = Zo({
                text: e,
                fontFamily: r,
                fontWeight: s,
                fontStyle: l,
                fontVariant: c,
                fontSize: n,
                lineHeight: a,
                letterSpacing: d,
                width: o,
                height: i
            });
            let h = ti.get(u);
            if (h) return h;
            let p = 1;
            n > 1e3 && z() && (p = n / 1e3, n = 1e3, a *= p);
            const g = Yt(m("pre", {
                contenteditable: "true",
                spellcheck: "false",
                style: `${ii}${Qo({
                    fontFamily: r,
                    fontWeight: s,
                    fontStyle: l,
                    fontVariant: c,
                    fontSize: n,
                    letterSpacing: d,
                    lineHeight: a
                })};${ei(e, t)}"`,
                innerHTML: e
            })), $ = g.getBoundingClientRect();
            return h = {
                signature: oi(g).flat().map((e => e.text)).join("_;_"),
                textSize: Ge(De($), (e => Math.ceil(e * p)))
            }, ti.set(u, h), g.remove(), h
        })(i, {...e, width: h, height: void 0}), S = Zo({
            text: i,
            textAlign: n,
            fontFamily: r,
            fontSize: a,
            fontWeight: s,
            fontVariant: l,
            fontStyle: c,
            lineHeight: u,
            letterSpacing: d,
            outline: g,
            blur: $,
            signature: w
        });
        if (!se.has(S)) {
            se.set(S, i);
            const e = Math.ceil(v.width), t = Math.ceil(v.height);
            if (0 === e || 0 === t) return;
            const m = Ql(), w = Math.min(1, (m - (x + y) * R) / (e * R), (m - (f + b) * R) / (t * R));
            fi(i, {
                fontSize: a,
                fontFamily: r,
                fontWeight: s,
                fontVariant: l,
                fontStyle: c,
                letterSpacing: d,
                textAlign: n,
                lineHeight: u,
                width: h,
                height: p,
                imageWidth: e,
                imageHeight: t,
                paddingLeft: x,
                paddingTop: f,
                paddingRight: y,
                paddingBottom: b,
                pixelRatio: R * w,
                willRequest: L,
                outline: g,
                blur: $,
                styleNonce: F.styleNonce,
                color: [1, 0, 1]
            }).then((e => {
                if (!j) return;
                const t = j.textureCreate();
                j.textureUpdate(t, e, {
                    filterParam: j.textureFilterLinear,
                    wrapParam: j.textureClamp,
                    scalar: w
                }), se.set(S, t), le.set(o, t), ae()
            })).catch(console.error)
        }
        const k = se.get(S);
        return Nc(k) ? k : le.get(o)
    }, me = new Map, ge = e => {
        let t;
        return e.backgroundImage ? t = de(e.backgroundImage, e.backgroundImageRendering, "repeat" === e.backgroundRepeat ? "repeat" : void 0) : e.bitmap && e.points && (t = (e => {
            const {id: t, points: o, strokeWidth: i, strokeCap: n, strokeJoin: r, strokeColor: a, strokeDash: s} = e;
            let l = se.get(t), c = me.get(t);
            const d = Zo({
                points: o.map((e => `${e.x},${e.y}`)).join(","),
                strokeWidth: i,
                strokeCap: n,
                strokeJoin: r,
                strokeColor: a,
                strokeDash: (s || []).join(",")
            });
            if (c) {
                const {hash: e} = c;
                if (se.has(t)) {
                    if (d === e) return se.get(t)
                } else c = void 0
            }
            if (!c) {
                const o = m("canvas", {width: 1, height: 1});
                c = {
                    canvas: o,
                    hash: void 0
                }, me.set(e.id, c), l = j.textureCreate(), j.textureUpdate(l, o, {
                    filterParam: j.textureFilterLinear,
                    wrapParam: j.textureClamp
                }), se.set(t, l)
            }
            const {canvas: u} = c, h = Math.ceil(e.strokeWidth), p = it(o), g = Math.floor(p.x) - .5 * h,
                $ = Math.floor(p.y) - .5 * h, f = Math.ceil(p.width + h), y = Math.ceil(p.height + h);
            u.width = Math.max(f, 1), u.height = Math.max(y, 1);
            const b = u.getContext("2d");
            return b.clearRect(0, 0, u.width, u.height), f >= 1 && y >= 1 && (b.translate(-g, -$), Zn(b, e), b.resetTransform()), j.textureUpdate(l, u, {
                filterParam: j.textureFilterLinear,
                wrapParam: j.textureClamp
            }), me.set(t, {canvas: u, hash: d}), se.get(t)
        })(e)), t
    }, fe = ({
                 texture: e,
                 size: t,
                 origin: o,
                 translation: i,
                 rotation: n,
                 scale: r,
                 colorMatrix: a,
                 opacity: s,
                 convolutionMatrix: l,
                 gamma: c,
                 vignette: d,
                 maskFeather: u,
                 maskCornerRadius: h,
                 overlayColor: p,
                 enableOverlay: m,
                 enableManipulation: g,
                 enableAntialiasing: $
             }) => {
        let f = 0, y = 0;
        if (1 === P) {
            const e = Math.abs(1 - r) < Number.EPSILON;
            f = e && U % 2 != 0 ? .5 : 0, y = e && X % 2 != 0 ? .5 : 0
        }
        return j.drawImage(e, t, o.x, o.y, i.x + f, i.y + y, n.x, n.y, n.z, r, a, gs(s, 0, 1), l, c, d, u, h, p, m, g, $), e
    }, ye = (e, t, o) => {
        const i = st(t), n = st(e), r = i.x - n.x, a = i.y - n.y, s = $e(i, o, n);
        return {x: s.x - n.x - r, y: s.y - n.y - a}
    }, be = (e, t, o) => {
        let i = void 0, n = void 0;
        const r = G(o.width, o.height);
        if ("repeat" === e.backgroundRepeat && (i = {...o}, n = {x: 0, y: 0}), "contain" === e.backgroundSize) {
            const o = vt(t, r, t);
            i = Be(o), n = e.backgroundPosition ? e.backgroundPosition : he(.5 * (t.width - i.width), .5 * (t.height - i.height))
        } else if ("cover" === e.backgroundSize) {
            const o = xt(t, r, t);
            i = Be(o), e.backgroundPosition ? n = e.backgroundPosition : (n = he(o.x, o.y), n = he(.5 * (t.width - i.width), .5 * (t.height - i.height)))
        } else e.backgroundSize ? (i = e.backgroundSize, n = e.backgroundPosition || {
            x: 0,
            y: 0
        }) : e.backgroundPosition && (i = {...o}, n = e.backgroundPosition);
        return {backgroundSize: i, backgroundPosition: n}
    }, xe = (e = [], t) => {
        e.forEach((e => {
            let o = ge(e);
            const i = "complete" !== e.status && ("loading" === e.status || e.backgroundImage && o === e.backgroundImage);
            i && ae();
            const n = "error" === e.status || e.backgroundImage && o instanceof Error;
            let r = Nc(o) ? o : void 0;
            const a = e._scale || 1, s = e._translate || g, l = e.strokeWidth && e.strokeWidth * a,
                c = e.cornerRadius ? ((e, t) => [e, e, e, e].map((e => e * t)))(e.cornerRadius, a) : p, d = !!e.width,
                u = h(e.text), m = Oo(e.points), $ = Ri(e);
            if (m) {
                const i = e.points.map((e => he(e.x * a + s.x, e.y * a + s.y)));
                if (e.bitmap) {
                    o && t.push(o);
                    const n = it(i), s = Math.ceil(e.strokeWidth * a);
                    j.drawRect({
                        x: Math.floor(n.x) - .5 * s,
                        y: Math.floor(n.y) - .5 * s,
                        width: Math.ceil(n.width + s),
                        height: Math.ceil(n.height + s)
                    }, e.rotation, e.flipX, e.flipY, [0, 0, 0, 0], void 0, r, void 0, void 0, void 0, void 0, void 0, void 0, e.opacity, void 0, void 0, !1, !1)
                } else j.drawPath(i, e.rotation, e.flipX, e.flipY, l, e.strokeColor, e.pathClose, e.backgroundColor, e.opacity)
            } else if ($) {
                let c = e.x, d = e.y;
                c *= a, d *= a, c += s.x, d += s.y;
                const u = nt({x: c, y: d, rx: e.rx * a, ry: e.ry * a}), h = he(c, d), p = r && j.textureGetSize(r);
                let m, g;
                if (p && e.backgroundImage && (e.backgroundSize || e.backgroundPosition || e.backgroundRepeat)) {
                    const t = be(e, u, p);
                    m = t.backgroundSize, g = t.backgroundPosition
                }
                if (j.drawEllipse(h, e.rx * a, e.ry * a, e.rotation, e.flipX, e.flipY, e.backgroundColor, r, m, g, e.backgroundCorners && Hc(e.backgroundCorners), l, e.strokeColor, e.opacity, e.inverted), o && t.push(o), i || n) {
                    if (!(e.backgroundColor || e.strokeColor && e.strokeWidth)) {
                        const t = e.opacity || 1;
                        j.drawEllipse(h, e.rx * a, e.ry * a, e.rotation, e.flipX, e.flipY, n ? [1, .2549, .2118, .25 * t] : [0, 0, 0, .25 * t])
                    }
                    n && Te(h), i && Ce(h)
                }
            } else if (u) {
                const {fontSize: o = 16} = e, i = o > 1e3 && z() ? o / 1e3 : 1,
                    n = Math.max(16, Math.ceil(o / i * .25)), r = Math.abs(e.rotation) > 0,
                    d = zo(e.width) ? Math.floor(e.width) : e.width, u = zo(e.height) ? Math.floor(e.height) : e.height,
                    h = ai(e.text, {...e, width: d, height: u}), m = Math.ceil(h.width), g = Math.ceil(h.height),
                    $ = {x: e.x * a + s.x, y: e.y * a + s.y, width: m * a, height: g * a}, f = !!e.height;
                (e.backgroundColor || e.strokeColor) && j.drawRect($, e.rotation, e.flipX, e.flipY, c, e.backgroundColor, void 0, void 0, void 0, !1, void 0, l, e.strokeColor, e.opacity, void 0, void 0, void 0, e.inverted);
                const {textShadowX: y, textShadowY: b, textShadowBlur: x} = e;
                if (y || b || x) {
                    const o = Math.ceil(.5 * x), l = Math.max(n, f ? 0 : o), c = pe(e, {
                        id: e.id + "shadow",
                        blur: x,
                        paddingTop: l,
                        paddingRight: l,
                        paddingBottom: l,
                        paddingLeft: l
                    });
                    if (c && !e._prerender) {
                        t.push(c);
                        const o = j.textureGetSize(c), l = {x: 0, y: 0},
                            d = {width: o.width / R * a, height: o.height / R * a}, u = n * a / i;
                        let h;
                        if (f) h = {...$}, l.x = y - u, l.y = b - u; else if (h = {
                            x: e.x * a + s.x - u,
                            y: e.y * a + s.y - u,
                            width: d.width,
                            height: d.height
                        }, r) {
                            const t = ye($, h, e.rotation);
                            h.x += t.x, h.y += t.y;
                            const o = $e(he(y, b), e.rotation);
                            h.x += o.x, h.y += o.y
                        } else h.x += y, h.y += b;
                        j.drawRect(h, e.rotation, e.flipX, e.flipY, [0, 0, 0, 0], void 0, c, d, l, !1, void 0, void 0, void 0, e.opacity, void 0, 0, e.textShadowColor)
                    }
                }
                if (e.textOutlineWidth) {
                    const o = Math.ceil(.5 * e.textOutlineWidth), l = n + o, c = pe(e, {
                        id: e.id + "outline",
                        outline: e.textOutlineWidth,
                        paddingTop: l,
                        paddingRight: l,
                        paddingBottom: l,
                        paddingLeft: l
                    });
                    if (c && !e._prerender) {
                        t.push(c);
                        const l = j.textureGetSize(c), d = {x: 0, y: 0},
                            u = {width: l.width / R * a, height: l.height / R * a}, h = (n + o) * a / i, p = {
                                x: e.x * a + s.x - h,
                                y: e.y * a + s.y - h,
                                width: u.width,
                                height: e.height ? g + h : u.height
                            };
                        if (r) {
                            const t = ye($, p, e.rotation);
                            p.x += t.x, p.y += t.y
                        }
                        j.drawRect(p, e.rotation, e.flipX, e.flipY, [0, 0, 0, 0], void 0, c, u, d, !1, void 0, void 0, void 0, e.opacity, void 0, 0, e.textOutlineColor)
                    }
                }
                const v = pe(e, {id: e.id + "text", paddingTop: n, paddingRight: n, paddingBottom: n, paddingLeft: n});
                if (v && !e._prerender) {
                    t.push(v);
                    const o = j.textureGetSize(v), l = {x: 0, y: 0},
                        c = {width: o.width / R * a, height: o.height / R * a}, d = n * a / i, u = {
                            x: e.x * a + s.x - d,
                            y: e.y * a + s.y - d,
                            width: c.width,
                            height: e.height ? g + d : c.height
                        };
                    if (r) {
                        const t = ye($, u, e.rotation);
                        u.x += t.x, u.y += t.y
                    }
                    const h = e.color || [0, 0, 0];
                    e._prerender && (h[3] = 0), j.drawRect(u, e.rotation, e.flipX, e.flipY, p, !1, v, c, l, !1, !1, void 0, void 0, e.opacity, void 0, e.feather, h, e.inverted)
                }
            } else if (d) {
                o && t.push(o);
                const d = ot(e);
                let u, h;
                a && s && (d.x *= a, d.y *= a, d.x += s.x, d.y += s.y, d.width *= a, d.height *= a);
                const {backgroundRepeat: p = "no-repeat"} = e, m = r && j.textureGetSize(r);
                if (m && e.backgroundImage && (e.backgroundSize || e.backgroundPosition || e.backgroundRepeat)) {
                    const t = be(e, d, m);
                    u = t.backgroundSize, h = t.backgroundPosition
                }
                if (j.drawRect(d, e.rotation, e.flipX, e.flipY, c, e.backgroundColor || [0, 0, 0, 0], r, u, h, "repeat" === p, e.backgroundCorners && Hc(e.backgroundCorners), l, e.strokeColor, e.opacity, void 0, e.feather, e.fillColor, e.inverted), i || n) {
                    if (!(e.backgroundColor && 0 !== e.backgroundColor[3] || e.strokeColor && e.strokeWidth)) {
                        const t = e.opacity || 1;
                        j.drawRect(d, e.rotation, e.flipX, e.flipY, c, n ? [1, .2549, .2118, .25 * t] : [0, 0, 0, .25 * t])
                    }
                    const t = st(d);
                    n && Te(t), i && Ce(t)
                }
            } else o && t.push(o)
        }))
    };
    let ve = 0;
    const we = [{x: -5, y: -5}, {x: 5, y: 5}], Se = [{x: 5, y: -5}, {x: -5, y: 5}],
        ke = Dt({x: 0, y: 0}, 10, 10, 0, !1, !1, 16);
    ke.length = 9;
    const Ce = e => {
        ve = Date.now() / 50, j.drawEllipse(e, 15, 15, 0, !1, !1, [0, 0, 0, .5]);
        const t = Le(ke.map((t => ({x: t.x + e.x, y: t.y + e.y}))), ve, e.x, e.y);
        j.drawPath(t, 0, !1, !1, 2, [1, 1, 1])
    }, Te = e => {
        j.drawEllipse(e, 13, 13, 0, !1, !1, [1, .2549, .2118, .75]);
        const t = we.map((t => ({x: t.x + e.x, y: t.y + e.y}))), o = Se.map((t => ({x: t.x + e.x, y: t.y + e.y})));
        j.drawPath(t, 0, !1, !1, 3, [1, 1, 1]), j.drawPath(o, 0, !1, !1, 3, [1, 1, 1])
    }, Me = (e, t, o, i, n, r) => j.drawRect(t, 0, !1, !1, p, p, e, i, o, !0, void 0, 0, void 0, r, void 0, void 0, n);
    let Pe = !1, Re = !0, Ie = !1;
    const Ee = [], Ae = [], Fe = [], ze = e => !e.aboveFrame, Oe = e => e.aboveFrame, We = () => {
        Fe.length = 0;
        const e = _[0], {
                manipulationShapes: t,
                manipulationShapesDirty: o,
                annotationShapes: i,
                annotationShapesDirty: n,
                interfaceShapes: r,
                decorationShapes: l,
                frameShapes: h,
                selectionShapes: m
            } = E({
                opacity: e.opacity,
                rotation: e.rotation,
                scale: e.scale,
                images: _,
                size: Ve(U, X),
                backgroundColor: [...u],
                selectionRect: d
            }), g = [...u], $ = d, f = gs(c, 0, 1), b = s, x = Math.abs(e.rotation.x / Math.PI * 2 - 1),
            v = Math.abs(e.rotation.y / Math.PI * 2 - 1), k = x < .99 || v < .99, C = {...e.size},
            P = e.backgroundColor, I = e.backgroundImage, L = t.length > 0, F = i.length > 0,
            z = i.filter(Oe).length > 0, D = l.filter(Oe).length > 0, G = P[3] > 0, Z = !!M && T >= 1;
        if (f < 1 && G) {
            const e = g[0], t = g[1], o = g[2], i = 1 - f, n = P[0] * i, r = P[1] * i, a = P[2] * i, s = 1 - i;
            g[0] = n + e * s, g[1] = r + t * s, g[2] = a + o * s, g[3] = 1
        }
        j.setCanvasColor(w ? p : g);
        L && (o || Pe) ? (j.disableMask(), j.drawToImageBlendBuffer(C), Ee.length = 0, xe(t, Ee)) : L || (Ee.length = 0), Fe.push(...Ee), Re && (j.drawToImageOverlayBuffer(C, R), Re = !1);
        if (k) {
            if (F && (n || Pe) || !Ie) {
                j.disableMask(), j.drawToImageOverlayBuffer(C, R), Ae.length = 0;
                const e = z ? i.filter(ze) : i;
                xe(e, Ae)
            } else F || (Ae.length = 0);
            Ie = !0
        } else Ie = !1;
        if (j.drawToCanvas(), j.enableMask($, f), B && W >= 1 && 2 === O.length && V && ((e, t, o, i, n) => {
            const r = Ve(t, t), a = de(y, "pixelated", "repeat"), s = he(-e.x % t, -e.y % t),
                l = he(s.x + .5 * r.width, s.y);
            Me(a, e, s, r, o, n), Me(a, e, l, r, i, n)
        })($, W, O[0], O[1], V), G && j.drawRect($, 0, !1, !1, p, P), I) {
            j.enableMask($, 1);
            const e = Math.max(S.width / I.width, S.height / I.height), t = I.width * e, o = I.height * e,
                i = {x: S.x + .5 * S.width - .5 * t, y: S.y + .5 * S.height - .5 * o, width: t, height: o};
            j.drawRect(i, 0, !1, !1, p, p, de(I, "linear")), j.enableMask($, f)
        }
        if (Z && j.enablePreviewStencil(), Fe.push(...[..._].reverse().map((e => fe({
            ...e,
            texture: de(e.data),
            enableOverlay: k && F,
            enableManipulation: L,
            enableAntialiasing: !0,
            mask: $,
            maskOpacity: f,
            overlayColor: b
        })))), j.enableMask($, T), !k) {
            Z && j.applyPreviewStencil(), j.resetCanvasMatrix(), j.updateCanvasMatrix(C, e.origin, e.translation, e.scale, e.rotation), Ae.length = 0;
            const t = z ? i.filter(ze) : i;
            xe(t, Ae), Z && j.disablePreviewStencil()
        }
        if (Fe.push(...Ae), j.resetCanvasMatrix(), j.enableMask($, T), xe(D ? l.filter(ze) : l, Fe), h.length) {
            j.enableMask($, 1);
            const e = h.filter((e => !e.expandsCanvas)), t = h.filter((e => e.expandsCanvas));
            e.length && xe(e, Fe), t.length && (j.enableMask({
                x: $.x + .5,
                y: $.y + .5,
                width: $.width - 1,
                height: $.height - 1
            }, a), xe(t, Fe))
        }
        if (z && (j.resetCanvasMatrix(), j.updateCanvasMatrix(C, e.origin, e.translation, e.scale, e.rotation), xe(i.filter(Oe), Fe), j.resetCanvasMatrix()), D && (j.resetCanvasMatrix(), xe(l.filter(Oe), Fe), j.resetCanvasMatrix()), H && m.length && !k) {
            j.resetCanvasMatrix(), j.updateCanvasMatrix(C, e.origin, e.translation, e.scale, e.rotation);
            const t = [...H];
            t[3] = .5;
            const o = [{id: "selection", color: t, actions: [...m]}].map((e => ne(e, C)));
            xe(o, Fe), j.resetCanvasMatrix()
        }
        j.disableMask(), xe(r, Fe), N.forEach((e => {
            if (j.enableMask(e.mask, e.maskOpacity), e.backgroundColor) {
                const t = I && xt({...e.mask}, I.width / I.height), o = I && de(I, "linear");
                j.drawRect(e.mask, 0, !1, !1, e.maskCornerRadius, e.backgroundColor, o, t, t, void 0, void 0, void 0, void 0, e.opacity, e.maskFeather), o && Fe.push(o)
            }
            const t = fe({
                ...e,
                texture: de(e.data),
                enableAntialiasing: !1,
                translation: {x: e.translation.x + e.offset.x - .5 * U, y: e.translation.y + e.offset.y - .5 * X}
            });
            Fe.push(t)
        })), j.disableMask(), (e => {
            se.forEach(((t, o) => {
                !e.find((e => e === t)) && Nc(t) && (Array.from(le.values()).includes(t) || (se.delete(o), j.textureDelete(t)))
            }))
        })(Fe), A(), Pe = !1
    };
    let _e, Ne = 0;
    const He = () => {
        clearTimeout(_e);
        const e = Date.now();
        e - Ne < 48 ? _e = setTimeout(He, 48) : (Ne = e, We())
    };
    ra((() => r())), na((() => o(31, j = cc(x, {alpha: w})))), aa((() => {
        j && (me.forEach((({canvas: e}) => $(e))), me.clear(), j.release(), o(31, j = void 0), o(0, x = void 0))
    }));
    return e.$$set = e => {
        "isAnimated" in e && o(9, v = e.isAnimated), "isTransparent" in e && o(10, w = e.isTransparent), "maskRect" in e && o(11, S = e.maskRect), "maskOpacity" in e && o(12, k = e.maskOpacity), "maskFrameOpacity" in e && o(13, C = e.maskFrameOpacity), "maskMarkupOpacity" in e && o(14, T = e.maskMarkupOpacity), "clipAnnotationsToImage" in e && o(15, M = e.clipAnnotationsToImage), "pixelRatio" in e && o(16, P = e.pixelRatio), "textPixelRatio" in e && o(17, R = e.textPixelRatio), "backgroundColor" in e && o(18, I = e.backgroundColor), "willRender" in e && o(19, E = e.willRender), "didRender" in e && o(20, A = e.didRender), "willRequest" in e && o(21, L = e.willRequest), "csp" in e && o(22, F = e.csp), "loadImageData" in e && o(23, D = e.loadImageData), "enableGrid" in e && o(24, B = e.enableGrid), "gridColors" in e && o(25, O = e.gridColors), "gridSize" in e && o(26, W = e.gridSize), "gridOpacity" in e && o(27, V = e.gridOpacity), "images" in e && o(28, _ = e.images), "interfaceImages" in e && o(29, N = e.interfaceImages), "selectionColor" in e && o(30, H = e.selectionColor)
    }, e.$$.update = () => {
        if (1 & e.$$.dirty[0] && x) {
            const e = getComputedStyle(x).getPropertyValue("--color-transition-duration");
            o(32, K = (e => {
                let t = parseFloat(e);
                return /^[0-9]+s$/.test(e) ? 1e3 * t : t
            })(e))
        }
        262656 & e.$$.dirty[0] | 2 & e.$$.dirty[1] && I && J.set(I, {duration: v ? K : 0}), 4096 & e.$$.dirty[0] && Y(Q, zo(k) ? k : 1), 8192 & e.$$.dirty[0] && Y(ee, zo(C) ? C : 1), 2048 & e.$$.dirty[0] && S && te.set(S), 48 & e.$$.dirty[1] && u && oe.set([u[0], u[1], u[2], gs(c, 0, 1)]), 268435462 & e.$$.dirty[0] | 1 & e.$$.dirty[1] && o(34, n = !!(j && U && X && _.length)), 65542 & e.$$.dirty[0] | 1 & e.$$.dirty[1] && U && X && j && (Ne = 0, j.resize(U, X, P)), 8 & e.$$.dirty[1] && o(33, r = n ? _c() ? He : We : i), 12 & e.$$.dirty[1] && n && r && r()
    }, [x, U, X, b, J, Q, ee, te, oe, v, w, S, k, C, T, M, P, R, I, E, A, L, F, D, B, O, W, V, _, N, H, j, K, r, n, c, u, function (e) {
        ha[e ? "unshift" : "push"]((() => {
            x = e, o(0, x)
        }))
    }, e => {
        o(1, U = e.detail.width), o(2, X = e.detail.height), b("measure", {width: U, height: X})
    }]
}

class Gc extends Ga {
    constructor(e) {
        super(), Ua(this, e, Uc, jc, lr, {
            isAnimated: 9,
            isTransparent: 10,
            maskRect: 11,
            maskOpacity: 12,
            maskFrameOpacity: 13,
            maskMarkupOpacity: 14,
            clipAnnotationsToImage: 15,
            pixelRatio: 16,
            textPixelRatio: 17,
            backgroundColor: 18,
            willRender: 19,
            didRender: 20,
            willRequest: 21,
            csp: 22,
            loadImageData: 23,
            enableGrid: 24,
            gridColors: 25,
            gridSize: 26,
            gridOpacity: 27,
            images: 28,
            interfaceImages: 29,
            selectionColor: 30
        }, null, [-1, -1, -1])
    }
}

var Zc = (e, t = Boolean, o = " ") => e.filter(t).join(o);

function Xc(e, t, o) {
    const i = e.slice();
    return i[17] = t[o], i
}

const Yc = e => ({tab: 4 & e}), qc = e => ({tab: e[17]});

function Kc(e) {
    let t, o, i, n = [], r = new Map, a = e[2];
    const s = e => e[17].id;
    for (let t = 0; t < a.length; t += 1) {
        let o = Xc(e, a, t), i = s(o);
        r.set(i, n[t] = Jc(i, o))
    }
    return {
        c() {
            t = Fr("div");
            for (let e = 0; e < n.length; e += 1) n[e].c();
            Nr(t, "class", o = Zc(["PinturaTabList", e[0]])), Nr(t, "role", "tablist"), Nr(t, "data-layout", e[1])
        }, m(o, r) {
            Ar(o, t, r);
            for (let e = 0; e < n.length; e += 1) n[e].m(t, null);
            e[14](t), i = !0
        }, p(e, l) {
            1124 & l && (a = e[2], Ra(), n = Oa(n, l, s, 1, e, a, r, t, Ba, Jc, null, Xc), Ia()), (!i || 1 & l && o !== (o = Zc(["PinturaTabList", e[0]]))) && Nr(t, "class", o), (!i || 2 & l) && Nr(t, "data-layout", e[1])
        }, i(e) {
            if (!i) {
                for (let e = 0; e < a.length; e += 1) Ea(n[e]);
                i = !0
            }
        }, o(e) {
            for (let e = 0; e < n.length; e += 1) Aa(n[e]);
            i = !1
        }, d(o) {
            o && Lr(t);
            for (let e = 0; e < n.length; e += 1) n[e].d();
            e[14](null)
        }
    }
}

function Jc(e, t) {
    let o, i, n, r, a, s, l, c, d;
    const u = t[11].default, h = mr(u, t, t[10], qc);

    function p(...e) {
        return t[12](t[17], ...e)
    }

    function m(...e) {
        return t[13](t[17], ...e)
    }

    return {
        key: e, first: null, c() {
            o = Fr("button"), h && h.c(), i = Br(), Nr(o, "role", "tab"), Nr(o, "id", n = t[17].tabId), Nr(o, "aria-controls", r = t[17].href.substring(1)), Nr(o, "aria-selected", a = t[17].selected), o.disabled = s = t[17].disabled, Nr(o, "type", "button"), this.first = o
        }, m(e, t) {
            Ar(e, o, t), h && h.m(o, null), Rr(o, i), l = !0, c || (d = [Wr(o, "keydown", p), Wr(o, "click", m)], c = !0)
        }, p(e, i) {
            t = e, h && h.p && (!l || 1028 & i) && fr(h, u, t, t[10], l ? $r(u, t[10], i, Yc) : yr(t[10]), qc), (!l || 4 & i && n !== (n = t[17].tabId)) && Nr(o, "id", n), (!l || 4 & i && r !== (r = t[17].href.substring(1))) && Nr(o, "aria-controls", r), (!l || 4 & i && a !== (a = t[17].selected)) && Nr(o, "aria-selected", a), (!l || 4 & i && s !== (s = t[17].disabled)) && (o.disabled = s)
        }, i(e) {
            l || (Ea(h, e), l = !0)
        }, o(e) {
            Aa(h, e), l = !1
        }, d(e) {
            e && Lr(o), h && h.d(e), c = !1, ar(d)
        }
    }
}

function Qc(e) {
    let t, o, i = e[4] && Kc(e);
    return {
        c() {
            i && i.c(), t = Or()
        }, m(e, n) {
            i && i.m(e, n), Ar(e, t, n), o = !0
        }, p(e, [o]) {
            e[4] ? i ? (i.p(e, o), 16 & o && Ea(i, 1)) : (i = Kc(e), i.c(), Ea(i, 1), i.m(t.parentNode, t)) : i && (Ra(), Aa(i, 1, 1, (() => {
                i = null
            })), Ia())
        }, i(e) {
            o || (Ea(i), o = !0)
        }, o(e) {
            Aa(i), o = !1
        }, d(e) {
            i && i.d(e), e && Lr(t)
        }
    }
}

function ed(e, t, o) {
    let i, n, r, {
        $$slots: a = {},
        $$scope: s
    } = t, {class: l} = t, {name: c} = t, {selected: d} = t, {tabs: u = []} = t, {layout: h} = t;
    const p = sa(), m = e => {
        const t = r.querySelectorAll('[role="tab"] button')[e];
        t && t.focus()
    }, g = (e, t) => {
        e.preventDefault(), e.stopPropagation(), p("select", t)
    }, $ = ({key: e}, t) => {
        if (!/arrow/i.test(e)) return;
        const o = u.findIndex((e => e.id === t));
        return /right|down/i.test(e) ? m(o < u.length - 1 ? o + 1 : 0) : /left|up/i.test(e) ? m(o > 0 ? o - 1 : u.length - 1) : void 0
    };
    return e.$$set = e => {
        "class" in e && o(0, l = e.class), "name" in e && o(7, c = e.name), "selected" in e && o(8, d = e.selected), "tabs" in e && o(9, u = e.tabs), "layout" in e && o(1, h = e.layout), "$$scope" in e && o(10, s = e.$$scope)
    }, e.$$.update = () => {
        896 & e.$$.dirty && o(2, i = u.map((e => {
            const t = e.id === d;
            return {...e, tabId: `tab-${c}-${e.id}`, href: `#panel-${c}-${e.id}`, selected: t}
        }))), 4 & e.$$.dirty && o(4, n = i.length > 1)
    }, [l, h, i, r, n, g, $, c, d, u, s, a, (e, t) => $(t, e.id), (e, t) => g(t, e.id), function (e) {
        ha[e ? "unshift" : "push"]((() => {
            r = e, o(3, r)
        }))
    }]
}

class td extends Ga {
    constructor(e) {
        super(), Ua(this, e, ed, Qc, lr, {class: 0, name: 7, selected: 8, tabs: 9, layout: 1})
    }
}

var od = (e, t) => {
    if (!t) return;
    const o = t => {
        p(e, t)
    };
    return o(t), {update: o}
};
const id = e => ({panel: 16 & e}), nd = e => ({panel: e[4][0].id, panelIsActive: !0});

function rd(e, t, o) {
    const i = e.slice();
    return i[14] = t[o].id, i[15] = t[o].shouldDraw, i[16] = t[o].panelId, i[17] = t[o].labelledBy, i[18] = t[o].isActive, i[19] = t[o].hidden, i[3] = t[o].visible, i
}

const ad = e => ({panel: 16 & e, panelIsActive: 16 & e}), sd = e => ({panel: e[14], panelIsActive: e[18]});

function ld(e) {
    let t, o, i, n, r, a, s;
    const l = e[11].default, c = mr(l, e, e[10], nd);
    return {
        c() {
            t = Fr("div"), o = Fr("div"), c && c.c(), Nr(o, "class", i = Zc([e[1]])), Nr(t, "class", e[0])
        }, m(i, l) {
            Ar(i, t, l), Rr(t, o), c && c.m(o, null), r = !0, a || (s = [wr(n = od.call(null, t, e[2])), Wr(t, "measure", e[13]), wr(zc.call(null, t))], a = !0)
        }, p(e, a) {
            c && c.p && (!r || 1040 & a) && fr(c, l, e, e[10], r ? $r(l, e[10], a, id) : yr(e[10]), nd), (!r || 2 & a && i !== (i = Zc([e[1]]))) && Nr(o, "class", i), (!r || 1 & a) && Nr(t, "class", e[0]), n && sr(n.update) && 4 & a && n.update.call(null, e[2])
        }, i(e) {
            r || (Ea(c, e), r = !0)
        }, o(e) {
            Aa(c, e), r = !1
        }, d(e) {
            e && Lr(t), c && c.d(e), a = !1, ar(s)
        }
    }
}

function cd(e) {
    let t, o, i, n, r, a, s = [], l = new Map, c = e[4];
    const d = e => e[14];
    for (let t = 0; t < c.length; t += 1) {
        let o = rd(e, c, t), i = d(o);
        l.set(i, s[t] = ud(i, o))
    }
    return {
        c() {
            t = Fr("div");
            for (let e = 0; e < s.length; e += 1) s[e].c();
            Nr(t, "class", o = Zc(["PinturaTabPanels", e[0]]))
        }, m(o, l) {
            Ar(o, t, l);
            for (let e = 0; e < s.length; e += 1) s[e].m(t, null);
            n = !0, r || (a = [wr(i = od.call(null, t, e[2])), Wr(t, "measure", e[12]), wr(zc.call(null, t, {observePosition: !0}))], r = !0)
        }, p(e, r) {
            1042 & r && (c = e[4], Ra(), s = Oa(s, r, d, 1, e, c, l, t, Ba, ud, null, rd), Ia()), (!n || 1 & r && o !== (o = Zc(["PinturaTabPanels", e[0]]))) && Nr(t, "class", o), i && sr(i.update) && 4 & r && i.update.call(null, e[2])
        }, i(e) {
            if (!n) {
                for (let e = 0; e < c.length; e += 1) Ea(s[e]);
                n = !0
            }
        }, o(e) {
            for (let e = 0; e < s.length; e += 1) Aa(s[e]);
            n = !1
        }, d(e) {
            e && Lr(t);
            for (let e = 0; e < s.length; e += 1) s[e].d();
            r = !1, ar(a)
        }
    }
}

function dd(e) {
    let t;
    const o = e[11].default, i = mr(o, e, e[10], sd);
    return {
        c() {
            i && i.c()
        }, m(e, o) {
            i && i.m(e, o), t = !0
        }, p(e, n) {
            i && i.p && (!t || 1040 & n) && fr(i, o, e, e[10], t ? $r(o, e[10], n, ad) : yr(e[10]), sd)
        }, i(e) {
            t || (Ea(i, e), t = !0)
        }, o(e) {
            Aa(i, e), t = !1
        }, d(e) {
            i && i.d(e)
        }
    }
}

function ud(e, t) {
    let o, i, n, r, a, s, l, c, d = t[15] && dd(t);
    return {
        key: e, first: null, c() {
            o = Fr("div"), d && d.c(), i = Br(), Nr(o, "class", n = Zc(["PinturaTabPanel", t[1]])), o.hidden = r = t[19], Nr(o, "id", a = t[16]), Nr(o, "aria-labelledby", s = t[17]), Nr(o, "data-inert", l = !t[3]), Nr(o, "role", "tabpanel"), this.first = o
        }, m(e, t) {
            Ar(e, o, t), d && d.m(o, null), Rr(o, i), c = !0
        }, p(e, u) {
            (t = e)[15] ? d ? (d.p(t, u), 16 & u && Ea(d, 1)) : (d = dd(t), d.c(), Ea(d, 1), d.m(o, i)) : d && (Ra(), Aa(d, 1, 1, (() => {
                d = null
            })), Ia()), (!c || 2 & u && n !== (n = Zc(["PinturaTabPanel", t[1]]))) && Nr(o, "class", n), (!c || 16 & u && r !== (r = t[19])) && (o.hidden = r), (!c || 16 & u && a !== (a = t[16])) && Nr(o, "id", a), (!c || 16 & u && s !== (s = t[17])) && Nr(o, "aria-labelledby", s), (!c || 16 & u && l !== (l = !t[3])) && Nr(o, "data-inert", l)
        }, i(e) {
            c || (Ea(d), c = !0)
        }, o(e) {
            Aa(d), c = !1
        }, d(e) {
            e && Lr(o), d && d.d()
        }
    }
}

function hd(e) {
    let t, o, i, n;
    const r = [cd, ld], a = [];

    function s(e, t) {
        return e[5] ? 0 : 1
    }

    return t = s(e), o = a[t] = r[t](e), {
        c() {
            o.c(), i = Or()
        }, m(e, o) {
            a[t].m(e, o), Ar(e, i, o), n = !0
        }, p(e, [n]) {
            let l = t;
            t = s(e), t === l ? a[t].p(e, n) : (Ra(), Aa(a[l], 1, 1, (() => {
                a[l] = null
            })), Ia(), o = a[t], o ? o.p(e, n) : (o = a[t] = r[t](e), o.c()), Ea(o, 1), o.m(i.parentNode, i))
        }, i(e) {
            n || (Ea(o), n = !0)
        }, o(e) {
            Aa(o), n = !1
        }, d(e) {
            a[t].d(e), e && Lr(i)
        }
    }
}

function pd(e, t, o) {
    let i, n, {
        $$slots: r = {},
        $$scope: a
    } = t, {class: s} = t, {name: l} = t, {selected: c} = t, {panelClass: d} = t, {panels: u = []} = t, {visible: h} = t, {style: p} = t;
    const m = {};
    return e.$$set = e => {
        "class" in e && o(0, s = e.class), "name" in e && o(6, l = e.name), "selected" in e && o(7, c = e.selected), "panelClass" in e && o(1, d = e.panelClass), "panels" in e && o(8, u = e.panels), "visible" in e && o(3, h = e.visible), "style" in e && o(2, p = e.style), "$$scope" in e && o(10, a = e.$$scope)
    }, e.$$.update = () => {
        968 & e.$$.dirty && o(4, i = u.map((e => {
            const t = e === c;
            t && o(9, m[e] = !0, m);
            const i = h ? -1 !== h.indexOf(e) : t;
            return {
                id: e,
                panelId: `panel-${l}-${e}`,
                labelledBy: `tab-${l}-${e}`,
                isActive: t,
                hidden: !t,
                visible: i,
                shouldDraw: t || m[e]
            }
        }))), 16 & e.$$.dirty && o(5, n = i.length > 1)
    }, [s, d, p, h, i, n, l, c, u, m, a, r, function (t) {
        da.call(this, e, t)
    }, function (t) {
        da.call(this, e, t)
    }]
}

class md extends Ga {
    constructor(e) {
        super(), Ua(this, e, pd, hd, lr, {
            class: 0,
            name: 6,
            selected: 7,
            panelClass: 1,
            panels: 8,
            visible: 3,
            style: 2
        })
    }
}

var gd = e => {
    const t = Object.getOwnPropertyDescriptors(e.prototype);
    return Object.keys(t).filter((e => !!t[e].get))
};

function $d(e) {
    let t, o, i, n;
    const r = [e[5], {locale: e[1]}];

    function a(t) {
        e[22](t)
    }

    var s = e[10];

    function l(e) {
        let t = {};
        for (let e = 0; e < r.length; e += 1) t = ir(t, r[e]);
        return void 0 !== e[3] && (t.name = e[3]), {props: t}
    }

    return s && (t = qr(s, l(e)), ha.push((() => _a(t, "name", a))), e[23](t), t.$on("measure", e[11])), {
        c() {
            t && Na(t.$$.fragment), i = Or()
        }, m(e, o) {
            t && Ha(t, e, o), Ar(e, i, o), n = !0
        }, p(e, n) {
            const c = 34 & n[0] ? Wa(r, [32 & n[0] && Va(e[5]), 2 & n[0] && {locale: e[1]}]) : {};
            if (!o && 8 & n[0] && (o = !0, c.name = e[3], xa((() => o = !1))), s !== (s = e[10])) {
                if (t) {
                    Ra();
                    const e = t;
                    Aa(e.$$.fragment, 1, 0, (() => {
                        ja(e, 1)
                    })), Ia()
                }
                s ? (t = qr(s, l(e)), ha.push((() => _a(t, "name", a))), e[23](t), t.$on("measure", e[11]), Na(t.$$.fragment), Ea(t.$$.fragment, 1), Ha(t, i.parentNode, i)) : t = null
            } else s && t.$set(c)
        }, i(e) {
            n || (t && Ea(t.$$.fragment, e), n = !0)
        }, o(e) {
            t && Aa(t.$$.fragment, e), n = !1
        }, d(o) {
            e[23](null), o && Lr(i), t && ja(t, o)
        }
    }
}

function fd(e) {
    let t, o, i, n = e[6] && $d(e);
    return {
        c() {
            t = Fr("div"), n && n.c(), Nr(t, "data-util", e[3]), Nr(t, "class", o = Zc(["PinturaUtilPanel", e[2]])), Zr(t, "opacity", e[7])
        }, m(o, r) {
            Ar(o, t, r), n && n.m(t, null), e[24](t), i = !0
        }, p(e, r) {
            e[6] ? n ? (n.p(e, r), 64 & r[0] && Ea(n, 1)) : (n = $d(e), n.c(), Ea(n, 1), n.m(t, null)) : n && (Ra(), Aa(n, 1, 1, (() => {
                n = null
            })), Ia()), (!i || 8 & r[0]) && Nr(t, "data-util", e[3]), (!i || 4 & r[0] && o !== (o = Zc(["PinturaUtilPanel", e[2]]))) && Nr(t, "class", o), 128 & r[0] && Zr(t, "opacity", e[7])
        }, i(e) {
            i || (Ea(n), i = !0)
        }, o(e) {
            Aa(n), i = !1
        }, d(o) {
            o && Lr(t), n && n.d(), e[24](null)
        }
    }
}

function yd(e, t, o) {
    let i, n, r, a, s;
    const l = sa();
    let {isActive: c = !0} = t, {stores: d} = t, {view: u} = t, {props: h} = t, {component: p} = t, {locale: m} = t, {class: g} = t;
    const $ = ca("isAnimated");
    let f;
    pr(e, $, (e => o(21, s = e)));
    const y = bc(0), b = qa(y, (e => gs(e, 0, 1)));
    pr(e, b, (e => o(20, a = e)));
    let x = !c;
    const v = Ya(c), w = {
            isActive: qa(v, (async (e, t) => {
                if (!e) return t(e);
                await ya(), t(e)
            }), !1), isActiveFraction: qa(b, (e => e)), isVisible: qa(b, (e => e > 0))
        }, S = u, k = gd(S), C = Object.keys(h || {}).reduce(((e, t) => k.includes(t) ? (e[t] = h[t], e) : e), {}),
        T = Object.keys(w).reduce(((e, t) => k.includes(t) ? (e[t] = w[t], e) : e), {});
    let M, P;
    const R = e => {
        o(17, f = {...e.detail}), E && c && l("measure", {...f})
    };
    la("measurable", zc);
    const I = ia().$$.context;
    let E = !1;
    return na((() => {
        if (o(19, E = !0), r) return;
        o(0, p = new S({target: P, props: {...n, locale: m}, context: I})), o(3, M = p.name);
        const e = p.$on("measure", R);
        return () => {
            e(), p.$destroy()
        }
    })), e.$$set = e => {
        "isActive" in e && o(12, c = e.isActive), "stores" in e && o(13, d = e.stores), "view" in e && o(14, u = e.view), "props" in e && o(15, h = e.props), "component" in e && o(0, p = e.component), "locale" in e && o(1, m = e.locale), "class" in e && o(2, g = e.class)
    }, e.$$.update = () => {
        135169 & e.$$.dirty[0] && f && c && p && l("measure", f), 2101248 & e.$$.dirty[0] && y.set(c ? 1 : 0, {hard: !1 === s}), 1310720 & e.$$.dirty[0] && (a <= 0 && !x ? o(18, x = !0) : a > 0 && x && o(18, x = !1)), 786432 & e.$$.dirty[0] && E && l(x ? "hide" : "show"), 1048576 & e.$$.dirty[0] && l("fade", a), 1048576 & e.$$.dirty[0] && o(7, i = a), 4096 & e.$$.dirty[0] && v.set(c), 8192 & e.$$.dirty[0] && o(5, n = {
            ...C, ...T,
            stores: d
        })
    }, o(6, r = !k.includes("external")), [p, m, g, M, P, n, r, i, $, b, S, R, c, d, u, h, y, f, x, E, a, s, function (e) {
        M = e, o(3, M)
    }, function (e) {
        ha[e ? "unshift" : "push"]((() => {
            p = e, o(0, p)
        }))
    }, function (e) {
        ha[e ? "unshift" : "push"]((() => {
            P = e, o(4, P)
        }))
    }]
}

class bd extends Ga {
    constructor(e) {
        super(), Ua(this, e, yd, fd, lr, {
            isActive: 12,
            stores: 13,
            view: 14,
            props: 15,
            component: 0,
            locale: 1,
            class: 2,
            opacity: 16
        }, null, [-1, -1])
    }

    get opacity() {
        return this.$$.ctx[16]
    }
}

function xd(e) {
    let t, o, i, n, r, a;
    const s = e[5].default, l = mr(s, e, e[4], null);
    return {
        c() {
            t = zr("svg"), l && l.c(), Nr(t, "class", e[3]), Nr(t, "width", e[0]), Nr(t, "height", e[1]), Nr(t, "viewBox", o = "0 0 " + e[0] + "\n    " + e[1]), Nr(t, "xmlns", "http://www.w3.org/2000/svg"), Nr(t, "aria-hidden", "true"), Nr(t, "focusable", "false"), Nr(t, "stroke-linecap", "round"), Nr(t, "stroke-linejoin", "round")
        }, m(o, s) {
            Ar(o, t, s), l && l.m(t, null), n = !0, r || (a = wr(i = od.call(null, t, e[2])), r = !0)
        }, p(e, [r]) {
            l && l.p && (!n || 16 & r) && fr(l, s, e, e[4], n ? $r(s, e[4], r, null) : yr(e[4]), null), (!n || 8 & r) && Nr(t, "class", e[3]), (!n || 1 & r) && Nr(t, "width", e[0]), (!n || 2 & r) && Nr(t, "height", e[1]), (!n || 3 & r && o !== (o = "0 0 " + e[0] + "\n    " + e[1])) && Nr(t, "viewBox", o), i && sr(i.update) && 4 & r && i.update.call(null, e[2])
        }, i(e) {
            n || (Ea(l, e), n = !0)
        }, o(e) {
            Aa(l, e), n = !1
        }, d(e) {
            e && Lr(t), l && l.d(e), r = !1, a()
        }
    }
}

function vd(e, t, o) {
    let {$$slots: i = {}, $$scope: n} = t, {width: r = 24} = t, {height: a = 24} = t, {style: s} = t, {class: l} = t;
    return e.$$set = e => {
        "width" in e && o(0, r = e.width), "height" in e && o(1, a = e.height), "style" in e && o(2, s = e.style), "class" in e && o(3, l = e.class), "$$scope" in e && o(4, n = e.$$scope)
    }, [r, a, s, l, n, i]
}

class wd extends Ga {
    constructor(e) {
        super(), Ua(this, e, vd, xd, lr, {width: 0, height: 1, style: 2, class: 3})
    }
}

var Sd = (e, t) => t === e.target || t.contains(e.target), kd = (e, t, o) => {
    const i = h(t) ? t : e;
    return o ? `${i} (${n = o, n.map((e => "CMD" === e ? fo() ? "⌘" : "Ctrl" : e)).join("+")})` : i;
    var n
};
const {document: Cd} = za;

function Td(e) {
    let t, o, i, n;
    return {
        c() {
            t = Br(), o = Fr("button"), Nr(o, "class", "PinturaImageButton"), Nr(o, "type", "button"), Nr(o, "title", e[1]), o.disabled = e[2]
        }, m(r, a) {
            Ar(r, t, a), Ar(r, o, a), o.innerHTML = e[0], e[11](o), i || (n = [Wr(Cd.body, "load", e[5], !0), Wr(Cd.body, "error", e[6], !0), Wr(o, "pointerdown", e[4])], i = !0)
        }, p(e, [t]) {
            1 & t && (o.innerHTML = e[0]), 2 & t && Nr(o, "title", e[1]), 4 & t && (o.disabled = e[2])
        }, i: tr, o: tr, d(r) {
            r && Lr(t), r && Lr(o), e[11](null), i = !1, ar(n)
        }
    }
}

function Md(e, t, o) {
    let n, {html: r} = t, {title: a} = t, {onclick: s} = t, {disabled: l = !1} = t, {ongrab: c = i} = t, {ondrag: d = i} = t, {ondrop: u = i} = t;
    const h = e => Pe(p, he(e.pageX, e.pageY)) < 256;
    let p;
    const m = e => {
        document.documentElement.removeEventListener("pointermove", g), document.documentElement.removeEventListener("pointerup", m);
        const t = he(e.pageX, e.pageY);
        if (Pe(p, t) < 32) return s(e);
        h(e) || u(e)
    }, g = e => {
        h(e) || d(e)
    }, $ = e => n && n.contains(e) && "IMG" === e.nodeName;
    return e.$$set = e => {
        "html" in e && o(0, r = e.html), "title" in e && o(1, a = e.title), "onclick" in e && o(7, s = e.onclick), "disabled" in e && o(2, l = e.disabled), "ongrab" in e && o(8, c = e.ongrab), "ondrag" in e && o(9, d = e.ondrag), "ondrop" in e && o(10, u = e.ondrop)
    }, e.$$.update = () => {
        8 & e.$$.dirty && n && n.querySelector("img") && o(3, n.dataset.loader = !0, n)
    }, [r, a, l, n, e => {
        p = he(e.pageX, e.pageY), c(e), document.documentElement.addEventListener("pointermove", g), document.documentElement.addEventListener("pointerup", m)
    }, ({target: e}) => {
        $(e) && o(3, n.dataset.load = !0, n)
    }, ({target: e}) => {
        $(e) && o(3, n.dataset.error = !0, n)
    }, s, c, d, u, function (e) {
        ha[e ? "unshift" : "push"]((() => {
            n = e, o(3, n)
        }))
    }]
}

class Pd extends Ga {
    constructor(e) {
        super(), Ua(this, e, Md, Td, lr, {html: 0, title: 1, onclick: 7, disabled: 2, ongrab: 8, ondrag: 9, ondrop: 10})
    }
}

function Rd(e, t, o) {
    const i = e.slice();
    return i[13] = t[o], i
}

function Id(e, t) {
    let o, i, n, r, a, s, l;

    function c() {
        return t[9](t[13])
    }

    function d(...e) {
        return t[10](t[13], ...e)
    }

    function u(...e) {
        return t[11](t[13], ...e)
    }

    function h(...e) {
        return t[12](t[13], ...e)
    }

    return i = new Pd({
        props: {
            onclick: c,
            ongrab: d,
            ondrag: u,
            ondrop: h,
            disabled: t[1] || t[13].disabled,
            title: t[13].title,
            html: t[13].thumb
        }
    }), {
        key: e, first: null, c() {
            o = Fr("li"), Na(i.$$.fragment), n = Br(), Zr(o, "opacity", t[6]), this.first = o
        }, m(e, c) {
            Ar(e, o, c), Ha(i, o, null), Rr(o, n), a = !0, s || (l = wr(r = t[8].call(null, o, t[13])), s = !0)
        }, p(e, n) {
            t = e;
            const a = {};
            5 & n && (a.onclick = c), 9 & n && (a.ongrab = d), 17 & n && (a.ondrag = u), 33 & n && (a.ondrop = h), 3 & n && (a.disabled = t[1] || t[13].disabled), 1 & n && (a.title = t[13].title), 1 & n && (a.html = t[13].thumb), i.$set(a), r && sr(r.update) && 1 & n && r.update.call(null, t[13]), 64 & n && Zr(o, "opacity", t[6])
        }, i(e) {
            a || (Ea(i.$$.fragment, e), a = !0)
        }, o(e) {
            Aa(i.$$.fragment, e), a = !1
        }, d(e) {
            e && Lr(o), ja(i), s = !1, l()
        }
    }
}

function Ed(e) {
    let t, o, i = [], n = new Map, r = e[0];
    const a = e => e[13].id;
    for (let t = 0; t < r.length; t += 1) {
        let o = Rd(e, r, t), s = a(o);
        n.set(s, i[t] = Id(s, o))
    }
    return {
        c() {
            t = Fr("ul");
            for (let e = 0; e < i.length; e += 1) i[e].c();
            Nr(t, "class", "PinturaImageButtonList")
        }, m(e, n) {
            Ar(e, t, n);
            for (let e = 0; e < i.length; e += 1) i[e].m(t, null);
            o = !0
        }, p(e, [o]) {
            127 & o && (r = e[0], Ra(), i = Oa(i, o, a, 1, e, r, n, t, Ba, Id, null, Rd), Ia())
        }, i(e) {
            if (!o) {
                for (let e = 0; e < r.length; e += 1) Ea(i[e]);
                o = !0
            }
        }, o(e) {
            for (let e = 0; e < i.length; e += 1) Aa(i[e]);
            o = !1
        }, d(e) {
            e && Lr(t);
            for (let e = 0; e < i.length; e += 1) i[e].d()
        }
    }
}

function Ad(e, t, o) {
    let i, {items: n} = t, {disabled: r} = t, {onclickitem: a} = t, {ongrabitem: s} = t, {ondragitem: l} = t, {ondropitem: c} = t;
    const d = bc(0, {stiffness: .25, damping: .9});
    pr(e, d, (e => o(6, i = e)));
    na((() => d.set(1)));
    return e.$$set = e => {
        "items" in e && o(0, n = e.items), "disabled" in e && o(1, r = e.disabled), "onclickitem" in e && o(2, a = e.onclickitem), "ongrabitem" in e && o(3, s = e.ongrabitem), "ondragitem" in e && o(4, l = e.ondragitem), "ondropitem" in e && o(5, c = e.ondropitem)
    }, [n, r, a, s, l, c, i, d, (e, t) => t.mount && t.mount(e.firstChild, t), e => a(e.id), (e, t) => s && s(e.id, t), (e, t) => l && l(e.id, t), (e, t) => c && c(e.id, t)]
}

class Ld extends Ga {
    constructor(e) {
        super(), Ua(this, e, Ad, Ed, lr, {
            items: 0,
            disabled: 1,
            onclickitem: 2,
            ongrabitem: 3,
            ondragitem: 4,
            ondropitem: 5
        })
    }
}

var Fd = () => l() && window.devicePixelRatio || 1;
let zd = null;
var Dd = e => (null === zd && (zd = 1 === Fd() ? Math.round : e => e), zd(e)), Bd = (e, t = {}) => {
        if (e) {
            if (t.preventScroll && Kt()) {
                const t = document.body.scrollTop;
                return e.focus(), void (document.body.scrollTop = t)
            }
            e.focus(t)
        }
    }, Od = e => /date|email|number|search|text|url/.test(e.type),
    Wd = e => (e => /textarea/i.test(e.nodeName))(e) || Od(e) || e.isContentEditable;
const Vd = e => ({}), _d = e => ({}), Nd = e => ({}), Hd = e => ({});

function jd(e) {
    let t, o;
    const i = [e[7]];
    let n = {$$slots: {default: [Gd]}, $$scope: {ctx: e}};
    for (let e = 0; e < i.length; e += 1) n = ir(n, i[e]);
    return t = new xp({props: n}), e[53](t), {
        c() {
            Na(t.$$.fragment)
        }, m(e, i) {
            Ha(t, e, i), o = !0
        }, p(e, o) {
            const n = 128 & o[0] ? Wa(i, [Va(e[7])]) : {};
            67108864 & o[1] && (n.$$scope = {dirty: o, ctx: e}), t.$set(n)
        }, i(e) {
            o || (Ea(t.$$.fragment, e), o = !0)
        }, o(e) {
            Aa(t.$$.fragment, e), o = !1
        }, d(o) {
            e[53](null), ja(t, o)
        }
    }
}

function Ud(e) {
    let t, o;
    const i = [e[7]];
    let n = {};
    for (let e = 0; e < i.length; e += 1) n = ir(n, i[e]);
    return t = new xp({props: n}), e[52](t), {
        c() {
            Na(t.$$.fragment)
        }, m(e, i) {
            Ha(t, e, i), o = !0
        }, p(e, o) {
            const n = 128 & o[0] ? Wa(i, [Va(e[7])]) : {};
            t.$set(n)
        }, i(e) {
            o || (Ea(t.$$.fragment, e), o = !0)
        }, o(e) {
            Aa(t.$$.fragment, e), o = !1
        }, d(o) {
            e[52](null), ja(t, o)
        }
    }
}

function Gd(e) {
    let t;
    const o = e[51].label, i = mr(o, e, e[57], Hd);
    return {
        c() {
            i && i.c()
        }, m(e, o) {
            i && i.m(e, o), t = !0
        }, p(e, n) {
            i && i.p && (!t || 67108864 & n[1]) && fr(i, o, e, e[57], t ? $r(o, e[57], n, Nd) : yr(e[57]), Hd)
        }, i(e) {
            t || (Ea(i, e), t = !0)
        }, o(e) {
            Aa(i, e), t = !1
        }, d(e) {
            i && i.d(e)
        }
    }
}

function Zd(e) {
    let t, o, i, n, r, a, s;
    const l = e[51].details, c = mr(l, e, e[57], _d);
    return {
        c() {
            t = Fr("div"), c && c.c(), o = Br(), i = Fr("span"), Nr(i, "class", "PinturaPanelTip"), Nr(i, "data-top", e[10]), Zr(i, "opacity", e[14]), Zr(i, "transform", e[13]), Zr(i, "top", e[12]), Zr(i, "left", e[11]), Nr(t, "class", n = Zc(["PinturaPanel", "pintura-editor-panel", e[2]])), Nr(t, "tabindex", "-1"), Zr(t, "opacity", e[18]), Zr(t, "pointer-events", e[17]), Zr(t, "transform", e[16]), Zr(t, "max-height", e[15])
        }, m(n, l) {
            Ar(n, t, l), c && c.m(t, null), Rr(t, o), Rr(t, i), e[54](t), r = !0, a || (s = [Wr(t, "close", e[55]), Wr(t, "keydown", e[25]), Wr(t, "measure", e[56]), wr(zc.call(null, t))], a = !0)
        }, p(e, o) {
            c && c.p && (!r || 67108864 & o[1]) && fr(c, l, e, e[57], r ? $r(l, e[57], o, Vd) : yr(e[57]), _d), (!r || 1024 & o[0]) && Nr(i, "data-top", e[10]), 16384 & o[0] && Zr(i, "opacity", e[14]), 8192 & o[0] && Zr(i, "transform", e[13]), 4096 & o[0] && Zr(i, "top", e[12]), 2048 & o[0] && Zr(i, "left", e[11]), (!r || 4 & o[0] && n !== (n = Zc(["PinturaPanel", "pintura-editor-panel", e[2]]))) && Nr(t, "class", n), 262144 & o[0] && Zr(t, "opacity", e[18]), 131072 & o[0] && Zr(t, "pointer-events", e[17]), 65536 & o[0] && Zr(t, "transform", e[16]), 32768 & o[0] && Zr(t, "max-height", e[15])
        }, i(e) {
            r || (Ea(c, e), r = !0)
        }, o(e) {
            Aa(c, e), r = !1
        }, d(o) {
            o && Lr(t), c && c.d(o), e[54](null), a = !1, ar(s)
        }
    }
}

function Xd(e) {
    let t, o, i, n, r, a, s, l, c;
    const d = [Ud, jd], u = [];

    function h(e, t) {
        return e[1] ? 0 : 1
    }

    o = h(e), i = u[o] = d[o](e);
    let p = e[6] && Zd(e);
    return {
        c() {
            t = Br(), i.c(), n = Br(), p && p.c(), r = Br(), a = Or()
        }, m(i, d) {
            Ar(i, t, d), u[o].m(i, d), Ar(i, n, d), p && p.m(i, d), Ar(i, r, d), Ar(i, a, d), s = !0, l || (c = [Wr(document.body, "pointerdown", (function () {
                sr(e[9]) && e[9].apply(this, arguments)
            })), Wr(document.body, "pointerup", (function () {
                sr(e[8]) && e[8].apply(this, arguments)
            }))], l = !0)
        }, p(t, a) {
            let s = o;
            o = h(e = t), o === s ? u[o].p(e, a) : (Ra(), Aa(u[s], 1, 1, (() => {
                u[s] = null
            })), Ia(), i = u[o], i ? i.p(e, a) : (i = u[o] = d[o](e), i.c()), Ea(i, 1), i.m(n.parentNode, n)), e[6] ? p ? (p.p(e, a), 64 & a[0] && Ea(p, 1)) : (p = Zd(e), p.c(), Ea(p, 1), p.m(r.parentNode, r)) : p && (Ra(), Aa(p, 1, 1, (() => {
                p = null
            })), Ia())
        }, i(e) {
            s || (Ea(i), Ea(p), Ea(false), s = !0)
        }, o(e) {
            Aa(i), Aa(p), Aa(false), s = !1
        }, d(e) {
            e && Lr(t), u[o].d(e), e && Lr(n), p && p.d(e), e && Lr(r), e && Lr(a), l = !1, ar(c)
        }
    }
}

function Yd(e, t, o) {
    let n, r, a, s, l, c, d, u, h, p, m, g, $, f, y, b, x, v, w, S, k, C, T, M, P, R, {
        $$slots: I = {},
        $$scope: E
    } = t, {buttonClass: A} = t, {buttonLabel: L} = t, {buttonLabelClass: F} = t, {buttonHideLabel: z} = t, {buttonIcon: D} = t, {buttonTitle: B} = t, {panelClass: O} = t, {isActive: W = !1} = t, {onshow: V = (({panel: e}) => Bd(e, {preventScroll: !0}))} = t, {onhide: _ = i} = t;
    const N = ca("isAnimated");
    pr(e, N, (e => o(50, R = e)));
    const H = ca("rootPortal");
    pr(e, H, (e => o(45, k = e)));
    const j = ca("rootRect");
    let U, G, Z;
    pr(e, j, (e => o(48, M = e)));
    const X = () => o(33, Z = n && n.getBoundingClientRect());
    let Y = ue(), q = bc(0);
    pr(e, q, (e => o(47, T = e)));
    let K = ue();
    const J = Ya({x: 0, y: 0});
    pr(e, J, (e => o(46, C = e)));
    const Q = bc(-5, {stiffness: .1, damping: .35, precision: .001});
    pr(e, Q, (e => o(49, P = e)));
    let ee = !0;
    const te = e => Sd(e, k) || G.isEventTarget(e);
    let oe, ie, ne = !1;
    const re = e => {
        Wd(e.target) || (W || X(), o(38, ie = e), o(0, W = !W))
    }, ae = e => {
        /down/i.test(e.key) && (o(0, W = !0), o(38, ie = e))
    };
    aa((() => {
        if (!k) return;
        if (!oe) return;
        const e = oe;
        ya().then((() => {
            e.parentNode && e.remove()
        }))
    }));
    return e.$$set = e => {
        "buttonClass" in e && o(26, A = e.buttonClass), "buttonLabel" in e && o(1, L = e.buttonLabel), "buttonLabelClass" in e && o(27, F = e.buttonLabelClass), "buttonHideLabel" in e && o(28, z = e.buttonHideLabel), "buttonIcon" in e && o(29, D = e.buttonIcon), "buttonTitle" in e && o(30, B = e.buttonTitle), "panelClass" in e && o(2, O = e.panelClass), "isActive" in e && o(0, W = e.isActive), "onshow" in e && o(31, V = e.onshow), "onhide" in e && o(32, _ = e.onhide), "$$scope" in e && o(57, E = e.$$scope)
    }, e.$$.update = () => {
        if (16 & e.$$.dirty[0] && (n = G && G.getElement()), 1 & e.$$.dirty[0] | 64 & e.$$.dirty[1] && o(8, w = W ? e => {
            ne && (o(37, ne = !1), te(e) || o(0, W = !1))
        } : void 0), 1 & e.$$.dirty[0] | 524288 & e.$$.dirty[1] && q.set(W ? 1 : 0, {hard: !1 === R}), 1 & e.$$.dirty[0] | 524288 & e.$$.dirty[1] && Q.set(W ? 0 : -5, {hard: !1 === R}), 262144 & e.$$.dirty[1] && o(42, r = 1 - P / -5), 1 & e.$$.dirty[0] | 131072 & e.$$.dirty[1] && M && W && X(), 9 & e.$$.dirty[0] | 131076 & e.$$.dirty[1] && M && U && Z && W) {
            o(36, ee = !0);
            let e = Z.x - M.x + .5 * Z.width - .5 * U.width, t = Z.y - M.y + Z.height;
            const i = 12, n = 12, r = M.width - 12, a = M.height - 12, s = e, l = t, c = s + U.width, d = l + U.height;
            if (s < i && (o(35, K.x = s - i, K), e = i), c > r && (o(35, K.x = c - r, K), e = r - U.width), d > a) {
                o(34, Y.y = -1, Y);
                n < t - U.height - Z.height ? (o(35, K.y = 0, K), t -= U.height + Z.height) : (o(35, K.y = t - (d - a), K), t -= d - a - 12, o(36, ee = !1))
            } else o(34, Y.y = 1, Y);
            vr(J, C = ve(he(e, t), Dd), C)
        }
        65536 & e.$$.dirty[1] && o(6, a = T > 0), 294920 & e.$$.dirty[1] && o(44, s = `translateX(${Math.round(C.x) + 12 * Y.x}px) translateY(${Math.round(C.y) + 12 * Y.y + Y.y * P}px)`), 131072 & e.$$.dirty[1] && o(43, l = `--panel-max-height:${M.height - 24}px`), 65536 & e.$$.dirty[1] && o(18, c = T), 65536 & e.$$.dirty[1] && o(17, d = T < 1 ? "none" : "all"), 8192 & e.$$.dirty[1] && o(16, u = s), 4096 & e.$$.dirty[1] && o(15, h = l), 2048 & e.$$.dirty[1] && o(40, p = .5 + .5 * r), 2048 & e.$$.dirty[1] && o(41, m = r), 8 & e.$$.dirty[0] | 32768 & e.$$.dirty[1] && o(39, g = U && C), 1312 & e.$$.dirty[1] && o(14, $ = g && ee ? m : 0), 768 & e.$$.dirty[1] && o(13, f = g ? `scaleX(${p})rotate(45deg)` : "none"), 8 & e.$$.dirty[0] | 280 & e.$$.dirty[1] && o(12, y = g ? (Y.y < 0 ? K.y + U.height : 0) + "px" : "0"), 8 & e.$$.dirty[0] | 272 & e.$$.dirty[1] && o(11, b = g ? K.x + .5 * U.width + "px" : "0"), 8 & e.$$.dirty[1] && o(10, x = Y.y >= 0), 1 & e.$$.dirty[0] && o(9, v = W ? e => {
            te(e) || o(37, ne = !0)
        } : void 0), 96 & e.$$.dirty[0] | 16384 & e.$$.dirty[1] && a && k && oe && oe.parentNode !== k && k.append(oe), 1 & e.$$.dirty[0] && (W || o(38, ie = void 0)), 97 & e.$$.dirty[0] | 129 & e.$$.dirty[1] && W && a && oe && V({
            e: ie,
            panel: oe
        }), 65 & e.$$.dirty[0] | 2 & e.$$.dirty[1] && a && !W && _(), 2080374786 & e.$$.dirty[0] && o(7, S = {
            label: L,
            icon: D,
            class: Zc(["PinturaPanelButton", A]),
            onkeydown: ae,
            onclick: re,
            hideLabel: z,
            labelClass: F,
            title: B
        })
    }, [W, L, O, U, G, oe, a, S, w, v, x, b, y, f, $, h, u, d, c, N, H, j, q, J, Q, e => {
        /esc/i.test(e.key) && (o(0, W = !1), n.focus())
    }, A, F, z, D, B, V, _, Z, Y, K, ee, ne, ie, g, p, m, r, l, s, k, C, T, M, P, R, I, function (e) {
        ha[e ? "unshift" : "push"]((() => {
            G = e, o(4, G)
        }))
    }, function (e) {
        ha[e ? "unshift" : "push"]((() => {
            G = e, o(4, G)
        }))
    }, function (e) {
        ha[e ? "unshift" : "push"]((() => {
            oe = e, o(5, oe)
        }))
    }, e => {
        e.stopPropagation(), o(0, W = !1)
    }, e => o(3, U = De(e.detail)), E]
}

class qd extends Ga {
    constructor(e) {
        super(), Ua(this, e, Yd, Xd, lr, {
            buttonClass: 26,
            buttonLabel: 1,
            buttonLabelClass: 27,
            buttonHideLabel: 28,
            buttonIcon: 29,
            buttonTitle: 30,
            panelClass: 2,
            isActive: 0,
            onshow: 31,
            onhide: 32
        }, null, [-1, -1, -1])
    }
}

var Kd = {Up: 38, Down: 40, Left: 37, Right: 39};

function Jd(e) {
    let t, o, i, n, r, a, s, l;
    const c = e[15].default, d = mr(c, e, e[14], null);
    return {
        c() {
            t = Fr("li"), o = Fr("input"), i = Br(), n = Fr("label"), d && d.c(), Nr(o, "type", "radio"), Nr(o, "class", "implicit"), Nr(o, "id", e[7]), Nr(o, "name", e[0]), o.value = e[3], o.disabled = e[6], o.hidden = e[5], o.checked = e[4], Nr(n, "for", e[7]), Nr(n, "title", e[2]), Nr(t, "class", r = Zc(["PinturaRadioGroupOption", e[1]])), Nr(t, "data-hidden", e[5]), Nr(t, "data-disabled", e[6]), Nr(t, "data-selected", e[4])
        }, m(r, c) {
            Ar(r, t, c), Rr(t, o), Rr(t, i), Rr(t, n), d && d.m(n, null), a = !0, s || (l = [Wr(o, "change", _r(e[16])), Wr(o, "keydown", e[9]), Wr(o, "click", e[10])], s = !0)
        }, p(e, [i]) {
            (!a || 128 & i) && Nr(o, "id", e[7]), (!a || 1 & i) && Nr(o, "name", e[0]), (!a || 8 & i) && (o.value = e[3]), (!a || 64 & i) && (o.disabled = e[6]), (!a || 32 & i) && (o.hidden = e[5]), (!a || 16 & i) && (o.checked = e[4]), d && d.p && (!a || 16384 & i) && fr(d, c, e, e[14], a ? $r(c, e[14], i, null) : yr(e[14]), null), (!a || 128 & i) && Nr(n, "for", e[7]), (!a || 4 & i) && Nr(n, "title", e[2]), (!a || 2 & i && r !== (r = Zc(["PinturaRadioGroupOption", e[1]]))) && Nr(t, "class", r), (!a || 32 & i) && Nr(t, "data-hidden", e[5]), (!a || 64 & i) && Nr(t, "data-disabled", e[6]), (!a || 16 & i) && Nr(t, "data-selected", e[4])
        }, i(e) {
            a || (Ea(d, e), a = !0)
        }, o(e) {
            Aa(d, e), a = !1
        }, d(e) {
            e && Lr(t), d && d.d(e), s = !1, ar(l)
        }
    }
}

function Qd(e, t, o) {
    let i, n, {
        $$slots: r = {},
        $$scope: a
    } = t, {name: s} = t, {class: l} = t, {label: c} = t, {id: d} = t, {value: u} = t, {checked: h} = t, {onkeydown: p} = t, {onclick: m} = t, {hidden: g = !1} = t, {disabled: $ = !1} = t;
    const f = Object.values(Kd), y = ca("keysPressed");
    pr(e, y, (e => o(17, n = e)));
    return e.$$set = e => {
        "name" in e && o(0, s = e.name), "class" in e && o(1, l = e.class), "label" in e && o(2, c = e.label), "id" in e && o(11, d = e.id), "value" in e && o(3, u = e.value), "checked" in e && o(4, h = e.checked), "onkeydown" in e && o(12, p = e.onkeydown), "onclick" in e && o(13, m = e.onclick), "hidden" in e && o(5, g = e.hidden), "disabled" in e && o(6, $ = e.disabled), "$$scope" in e && o(14, a = e.$$scope)
    }, e.$$.update = () => {
        2049 & e.$$.dirty && o(7, i = `${s}-${d}`)
    }, [s, l, c, u, h, g, $, i, y, e => {
        p(e)
    }, e => {
        n.some((e => f.includes(e))) || m(e)
    }, d, p, m, a, r, function (t) {
        da.call(this, e, t)
    }]
}

class eu extends Ga {
    constructor(e) {
        super(), Ua(this, e, Qd, Jd, lr, {
            name: 0,
            class: 1,
            label: 2,
            id: 11,
            value: 3,
            checked: 4,
            onkeydown: 12,
            onclick: 13,
            hidden: 5,
            disabled: 6
        })
    }
}

var tu = (e = []) => e.reduce(((e, t) => (Oo(t) ? Oo(t[1]) : !!t.options) ? e.concat(Oo(t) ? t[1] : t.options) : (e.push(t), e)), []);
const ou = (e, t, o) => {
    let i;
    return Oo(e) ? i = {
        id: t,
        value: e[0],
        label: e[1], ...e[2] || {}
    } : (i = e, i.id = null != i.id ? i.id : t), o ? o(i) : i
};
var iu = (e, t, o) => M(e) ? e(t, o) : e;
const nu = (e, t) => e.map((([e, o, i]) => {
    if (Oo(o)) return [iu(e, t), nu(o, t)];
    {
        const n = [e, iu(o, t)];
        if (i) {
            let e = {...i};
            i.icon && (e.icon = iu(i.icon, t)), n.push(e)
        }
        return n
    }
}));
var ru = (e, t) => nu(e, t), au = (e, t) => Array.isArray(e) && Array.isArray(t) ? xs(e, t) : e === t;

function su(e, t, o) {
    const i = e.slice();
    return i[27] = t[o], i
}

const lu = e => ({option: 1024 & e[0]}), cu = e => ({option: e[27]});

function du(e, t, o) {
    const i = e.slice();
    return i[27] = t[o], i
}

const uu = e => ({option: 1024 & e[0]}), hu = e => ({option: e[27]}), pu = e => ({option: 1024 & e[0]}),
    mu = e => ({option: e[27]});

function gu(e) {
    let t, o, i, n, r, a = [], s = new Map, l = e[1] && $u(e), c = e[10];
    const d = e => e[27].id;
    for (let t = 0; t < c.length; t += 1) {
        let o = su(e, c, t), i = d(o);
        s.set(i, a[t] = Pu(i, o))
    }
    return {
        c() {
            t = Fr("fieldset"), l && l.c(), o = Br(), i = Fr("ul");
            for (let e = 0; e < a.length; e += 1) a[e].c();
            Nr(i, "class", "PinturaRadioGroupOptions"), Nr(t, "class", n = Zc(["PinturaRadioGroup", e[3]])), Nr(t, "data-layout", e[5]), Nr(t, "title", e[7])
        }, m(e, n) {
            Ar(e, t, n), l && l.m(t, null), Rr(t, o), Rr(t, i);
            for (let e = 0; e < a.length; e += 1) a[e].m(i, null);
            r = !0
        }, p(e, u) {
            e[1] ? l ? l.p(e, u) : (l = $u(e), l.c(), l.m(t, o)) : l && (l.d(1), l = null), 8419153 & u[0] && (c = e[10], Ra(), a = Oa(a, u, d, 1, e, c, s, i, Ba, Pu, null, su), Ia()), (!r || 8 & u[0] && n !== (n = Zc(["PinturaRadioGroup", e[3]]))) && Nr(t, "class", n), (!r || 32 & u[0]) && Nr(t, "data-layout", e[5]), (!r || 128 & u[0]) && Nr(t, "title", e[7])
        }, i(e) {
            if (!r) {
                for (let e = 0; e < c.length; e += 1) Ea(a[e]);
                r = !0
            }
        }, o(e) {
            for (let e = 0; e < a.length; e += 1) Aa(a[e]);
            r = !1
        }, d(e) {
            e && Lr(t), l && l.d();
            for (let e = 0; e < a.length; e += 1) a[e].d()
        }
    }
}

function $u(e) {
    let t, o, i;
    return {
        c() {
            t = Fr("legend"), o = Dr(e[1]), Nr(t, "class", i = e[2] && "implicit")
        }, m(e, i) {
            Ar(e, t, i), Rr(t, o)
        }, p(e, n) {
            2 & n[0] && Ur(o, e[1]), 4 & n[0] && i !== (i = e[2] && "implicit") && Nr(t, "class", i)
        }, d(e) {
            e && Lr(t)
        }
    }
}

function fu(e) {
    let t, o;
    return t = new eu({
        props: {
            name: e[4],
            label: e[27].label,
            id: e[27].id,
            value: e[27].value,
            disabled: e[27].disabled,
            hidden: e[27].hidden,
            class: e[8],
            checked: e[12](e[27]) === e[0],
            onkeydown: e[13](e[27]),
            onclick: e[14](e[27]),
            $$slots: {default: [wu]},
            $$scope: {ctx: e}
        }
    }), {
        c() {
            Na(t.$$.fragment)
        }, m(e, i) {
            Ha(t, e, i), o = !0
        }, p(e, o) {
            const i = {};
            16 & o[0] && (i.name = e[4]), 1024 & o[0] && (i.label = e[27].label), 1024 & o[0] && (i.id = e[27].id), 1024 & o[0] && (i.value = e[27].value), 1024 & o[0] && (i.disabled = e[27].disabled), 1024 & o[0] && (i.hidden = e[27].hidden), 256 & o[0] && (i.class = e[8]), 1025 & o[0] && (i.checked = e[12](e[27]) === e[0]), 1024 & o[0] && (i.onkeydown = e[13](e[27])), 1024 & o[0] && (i.onclick = e[14](e[27])), 8389696 & o[0] && (i.$$scope = {
                dirty: o,
                ctx: e
            }), t.$set(i)
        }, i(e) {
            o || (Ea(t.$$.fragment, e), o = !0)
        }, o(e) {
            Aa(t.$$.fragment, e), o = !1
        }, d(e) {
            ja(t, e)
        }
    }
}

function yu(e) {
    let t, o, i, n, r, a, s = [], l = new Map;
    const c = e[22].group, d = mr(c, e, e[23], mu), u = d || function (e) {
        let t, o, i = e[27].label + "";
        return {
            c() {
                t = Fr("span"), o = Dr(i), Nr(t, "class", "PinturaRadioGroupOptionGroupLabel")
            }, m(e, i) {
                Ar(e, t, i), Rr(t, o)
            }, p(e, t) {
                1024 & t[0] && i !== (i = e[27].label + "") && Ur(o, i)
            }, d(e) {
                e && Lr(t)
            }
        }
    }(e);
    let h = e[27].options;
    const p = e => e[27].id;
    for (let t = 0; t < h.length; t += 1) {
        let o = du(e, h, t), i = p(o);
        l.set(i, s[t] = Mu(i, o))
    }
    return {
        c() {
            t = Fr("li"), u && u.c(), o = Br(), i = Fr("ul");
            for (let e = 0; e < s.length; e += 1) s[e].c();
            n = Br(), Nr(i, "class", "PinturaRadioGroupOptions"), Nr(t, "class", r = Zc(["PinturaRadioGroupOptionGroup", e[9]]))
        }, m(e, r) {
            Ar(e, t, r), u && u.m(t, null), Rr(t, o), Rr(t, i);
            for (let e = 0; e < s.length; e += 1) s[e].m(i, null);
            Rr(t, n), a = !0
        }, p(e, o) {
            d ? d.p && (!a || 8389632 & o[0]) && fr(d, c, e, e[23], a ? $r(c, e[23], o, pu) : yr(e[23]), mu) : u && u.p && (!a || 1024 & o[0]) && u.p(e, a ? o : [-1, -1]), 8418641 & o[0] && (h = e[27].options, Ra(), s = Oa(s, o, p, 1, e, h, l, i, Ba, Mu, null, du), Ia()), (!a || 512 & o[0] && r !== (r = Zc(["PinturaRadioGroupOptionGroup", e[9]]))) && Nr(t, "class", r)
        }, i(e) {
            if (!a) {
                Ea(u, e);
                for (let e = 0; e < h.length; e += 1) Ea(s[e]);
                a = !0
            }
        }, o(e) {
            Aa(u, e);
            for (let e = 0; e < s.length; e += 1) Aa(s[e]);
            a = !1
        }, d(e) {
            e && Lr(t), u && u.d(e);
            for (let e = 0; e < s.length; e += 1) s[e].d()
        }
    }
}

function bu(e) {
    let t, o;
    return t = new wd({props: {$$slots: {default: [xu]}, $$scope: {ctx: e}}}), {
        c() {
            Na(t.$$.fragment)
        }, m(e, i) {
            Ha(t, e, i), o = !0
        }, p(e, o) {
            const i = {};
            8389632 & o[0] && (i.$$scope = {dirty: o, ctx: e}), t.$set(i)
        }, i(e) {
            o || (Ea(t.$$.fragment, e), o = !0)
        }, o(e) {
            Aa(t.$$.fragment, e), o = !1
        }, d(e) {
            ja(t, e)
        }
    }
}

function xu(e) {
    let t, o = e[27].icon + "";
    return {
        c() {
            t = zr("g")
        }, m(e, i) {
            Ar(e, t, i), t.innerHTML = o
        }, p(e, i) {
            1024 & i[0] && o !== (o = e[27].icon + "") && (t.innerHTML = o)
        }, d(e) {
            e && Lr(t)
        }
    }
}

function vu(e) {
    let t, o, i = e[27].label + "";
    return {
        c() {
            t = Fr("span"), o = Dr(i), Nr(t, "class", e[6])
        }, m(e, i) {
            Ar(e, t, i), Rr(t, o)
        }, p(e, n) {
            1024 & n[0] && i !== (i = e[27].label + "") && Ur(o, i), 64 & n[0] && Nr(t, "class", e[6])
        }, d(e) {
            e && Lr(t)
        }
    }
}

function wu(e) {
    let t;
    const o = e[22].option, i = mr(o, e, e[23], cu), n = i || function (e) {
        let t, o, i, n = e[27].icon && bu(e), r = !e[27].hideLabel && vu(e);
        return {
            c() {
                n && n.c(), t = Br(), r && r.c(), o = Br()
            }, m(e, a) {
                n && n.m(e, a), Ar(e, t, a), r && r.m(e, a), Ar(e, o, a), i = !0
            }, p(e, i) {
                e[27].icon ? n ? (n.p(e, i), 1024 & i[0] && Ea(n, 1)) : (n = bu(e), n.c(), Ea(n, 1), n.m(t.parentNode, t)) : n && (Ra(), Aa(n, 1, 1, (() => {
                    n = null
                })), Ia()), e[27].hideLabel ? r && (r.d(1), r = null) : r ? r.p(e, i) : (r = vu(e), r.c(), r.m(o.parentNode, o))
            }, i(e) {
                i || (Ea(n), i = !0)
            }, o(e) {
                Aa(n), i = !1
            }, d(e) {
                n && n.d(e), e && Lr(t), r && r.d(e), e && Lr(o)
            }
        }
    }(e);
    return {
        c() {
            n && n.c()
        }, m(e, o) {
            n && n.m(e, o), t = !0
        }, p(e, r) {
            i ? i.p && (!t || 8389632 & r[0]) && fr(i, o, e, e[23], t ? $r(o, e[23], r, lu) : yr(e[23]), cu) : n && n.p && (!t || 1088 & r[0]) && n.p(e, t ? r : [-1, -1])
        }, i(e) {
            t || (Ea(n, e), t = !0)
        }, o(e) {
            Aa(n, e), t = !1
        }, d(e) {
            n && n.d(e)
        }
    }
}

function Su(e) {
    let t, o;
    return t = new wd({props: {$$slots: {default: [ku]}, $$scope: {ctx: e}}}), {
        c() {
            Na(t.$$.fragment)
        }, m(e, i) {
            Ha(t, e, i), o = !0
        }, p(e, o) {
            const i = {};
            8389632 & o[0] && (i.$$scope = {dirty: o, ctx: e}), t.$set(i)
        }, i(e) {
            o || (Ea(t.$$.fragment, e), o = !0)
        }, o(e) {
            Aa(t.$$.fragment, e), o = !1
        }, d(e) {
            ja(t, e)
        }
    }
}

function ku(e) {
    let t, o = e[27].icon + "";
    return {
        c() {
            t = zr("g")
        }, m(e, i) {
            Ar(e, t, i), t.innerHTML = o
        }, p(e, i) {
            1024 & i[0] && o !== (o = e[27].icon + "") && (t.innerHTML = o)
        }, d(e) {
            e && Lr(t)
        }
    }
}

function Cu(e) {
    let t, o, i = e[27].label + "";
    return {
        c() {
            t = Fr("span"), o = Dr(i), Nr(t, "class", e[6])
        }, m(e, i) {
            Ar(e, t, i), Rr(t, o)
        }, p(e, n) {
            1024 & n[0] && i !== (i = e[27].label + "") && Ur(o, i), 64 & n[0] && Nr(t, "class", e[6])
        }, d(e) {
            e && Lr(t)
        }
    }
}

function Tu(e) {
    let t;
    const o = e[22].option, i = mr(o, e, e[23], hu), n = i || function (e) {
        let t, o, i, n = e[27].icon && Su(e), r = !e[27].hideLabel && Cu(e);
        return {
            c() {
                n && n.c(), t = Br(), r && r.c(), o = Br()
            }, m(e, a) {
                n && n.m(e, a), Ar(e, t, a), r && r.m(e, a), Ar(e, o, a), i = !0
            }, p(e, i) {
                e[27].icon ? n ? (n.p(e, i), 1024 & i[0] && Ea(n, 1)) : (n = Su(e), n.c(), Ea(n, 1), n.m(t.parentNode, t)) : n && (Ra(), Aa(n, 1, 1, (() => {
                    n = null
                })), Ia()), e[27].hideLabel ? r && (r.d(1), r = null) : r ? r.p(e, i) : (r = Cu(e), r.c(), r.m(o.parentNode, o))
            }, i(e) {
                i || (Ea(n), i = !0)
            }, o(e) {
                Aa(n), i = !1
            }, d(e) {
                n && n.d(e), e && Lr(t), r && r.d(e), e && Lr(o)
            }
        }
    }(e);
    return {
        c() {
            n && n.c()
        }, m(e, o) {
            n && n.m(e, o), t = !0
        }, p(e, r) {
            i ? i.p && (!t || 8389632 & r[0]) && fr(i, o, e, e[23], t ? $r(o, e[23], r, uu) : yr(e[23]), hu) : n && n.p && (!t || 1088 & r[0]) && n.p(e, t ? r : [-1, -1])
        }, i(e) {
            t || (Ea(n, e), t = !0)
        }, o(e) {
            Aa(n, e), t = !1
        }, d(e) {
            n && n.d(e)
        }
    }
}

function Mu(e, t) {
    let o, i, n;
    return i = new eu({
        props: {
            name: t[4],
            label: t[27].label,
            id: t[27].id,
            value: t[27].value,
            disabled: t[27].disabled,
            hidden: t[27].hidden,
            class: t[8],
            checked: t[12](t[27]) === t[0],
            onkeydown: t[13](t[27]),
            onclick: t[14](t[27]),
            $$slots: {default: [Tu]},
            $$scope: {ctx: t}
        }
    }), {
        key: e, first: null, c() {
            o = Or(), Na(i.$$.fragment), this.first = o
        }, m(e, t) {
            Ar(e, o, t), Ha(i, e, t), n = !0
        }, p(e, o) {
            t = e;
            const n = {};
            16 & o[0] && (n.name = t[4]), 1024 & o[0] && (n.label = t[27].label), 1024 & o[0] && (n.id = t[27].id), 1024 & o[0] && (n.value = t[27].value), 1024 & o[0] && (n.disabled = t[27].disabled), 1024 & o[0] && (n.hidden = t[27].hidden), 256 & o[0] && (n.class = t[8]), 1025 & o[0] && (n.checked = t[12](t[27]) === t[0]), 1024 & o[0] && (n.onkeydown = t[13](t[27])), 1024 & o[0] && (n.onclick = t[14](t[27])), 8389696 & o[0] && (n.$$scope = {
                dirty: o,
                ctx: t
            }), i.$set(n)
        }, i(e) {
            n || (Ea(i.$$.fragment, e), n = !0)
        }, o(e) {
            Aa(i.$$.fragment, e), n = !1
        }, d(e) {
            e && Lr(o), ja(i, e)
        }
    }
}

function Pu(e, t) {
    let o, i, n, r, a;
    const s = [yu, fu], l = [];

    function c(e, t) {
        return e[27].options ? 0 : 1
    }

    return i = c(t), n = l[i] = s[i](t), {
        key: e, first: null, c() {
            o = Or(), n.c(), r = Or(), this.first = o
        }, m(e, t) {
            Ar(e, o, t), l[i].m(e, t), Ar(e, r, t), a = !0
        }, p(e, o) {
            let a = i;
            i = c(t = e), i === a ? l[i].p(t, o) : (Ra(), Aa(l[a], 1, 1, (() => {
                l[a] = null
            })), Ia(), n = l[i], n ? n.p(t, o) : (n = l[i] = s[i](t), n.c()), Ea(n, 1), n.m(r.parentNode, r))
        }, i(e) {
            a || (Ea(n), a = !0)
        }, o(e) {
            Aa(n), a = !1
        }, d(e) {
            e && Lr(o), l[i].d(e), e && Lr(r)
        }
    }
}

function Ru(e) {
    let t, o, i, n = e[11].length && gu(e);
    return {
        c() {
            n && n.c(), t = Br(), o = Or()
        }, m(e, r) {
            n && n.m(e, r), Ar(e, t, r), Ar(e, o, r), i = !0
        }, p(e, o) {
            e[11].length ? n ? (n.p(e, o), 2048 & o[0] && Ea(n, 1)) : (n = gu(e), n.c(), Ea(n, 1), n.m(t.parentNode, t)) : n && (Ra(), Aa(n, 1, 1, (() => {
                n = null
            })), Ia())
        }, i(e) {
            i || (Ea(n), Ea(false), i = !0)
        }, o(e) {
            Aa(n), Aa(false), i = !1
        }, d(e) {
            n && n.d(e), e && Lr(t), e && Lr(o)
        }
    }
}

function Iu(e, t, o) {
    let i, n, r, {$$slots: a = {}, $$scope: s} = t;
    const l = sa();
    let {label: c} = t, {hideLabel: d = !0} = t, {class: u} = t, {name: h = "radio-group-" + E()} = t, {selectedIndex: p = -1} = t, {options: m = []} = t, {onchange: g} = t, {layout: $} = t, {optionMapper: f} = t, {optionFilter: y} = t, {value: b} = t, {optionLabelClass: x} = t, {title: v} = t, {locale: w} = t, {optionClass: S} = t, {optionGroupClass: k} = t;
    const C = e => r.findIndex((t => t.id === e.id)), T = (e, t) => {
        o(0, p = C(e));
        const i = {index: p, ...e};
        ((e, ...t) => {
            e && e(...t)
        })(g, i, t), l("change", i)
    };
    return e.$$set = e => {
        "label" in e && o(1, c = e.label), "hideLabel" in e && o(2, d = e.hideLabel), "class" in e && o(3, u = e.class), "name" in e && o(4, h = e.name), "selectedIndex" in e && o(0, p = e.selectedIndex), "options" in e && o(15, m = e.options), "onchange" in e && o(16, g = e.onchange), "layout" in e && o(5, $ = e.layout), "optionMapper" in e && o(17, f = e.optionMapper), "optionFilter" in e && o(18, y = e.optionFilter), "value" in e && o(19, b = e.value), "optionLabelClass" in e && o(6, x = e.optionLabelClass), "title" in e && o(7, v = e.title), "locale" in e && o(20, w = e.locale), "optionClass" in e && o(8, S = e.optionClass), "optionGroupClass" in e && o(9, k = e.optionGroupClass), "$$scope" in e && o(23, s = e.$$scope)
    }, e.$$.update = () => {
        1343488 & e.$$.dirty[0] && o(11, i = ru(y ? m.filter(y) : m, w)), 133120 & e.$$.dirty[0] && o(10, n = ((e = [], t) => {
            let o = 0;
            return e.map((e => (o++, Oo(e) ? Oo(e[1]) ? {
                id: o,
                label: e[0],
                options: e[1].map((e => ou(e, ++o, t)))
            } : ou(e, o, t) : e.options ? {
                id: e.id || o,
                label: e.label,
                options: e.options.map((e => ou(e, ++o, t)))
            } : ou(e, o, t))))
        })(i, f)), 1024 & e.$$.dirty[0] && o(21, r = tu(n)), 2654209 & e.$$.dirty[0] && p < 0 && (o(0, p = r.findIndex((e => au(e.value, b)))), p < 0 && o(0, p = (e => e.findIndex((e => void 0 === e[0])))(m)))
    }, [p, c, d, u, h, $, x, v, S, k, n, i, C, e => t => {
        var o;
        (o = t.key, /enter| /i.test(o)) && T(e, t)
    }, e => t => {
        T(e, t)
    }, m, g, f, y, b, w, r, a, s]
}

class Eu extends Ga {
    constructor(e) {
        super(), Ua(this, e, Iu, Ru, lr, {
            label: 1,
            hideLabel: 2,
            class: 3,
            name: 4,
            selectedIndex: 0,
            options: 15,
            onchange: 16,
            layout: 5,
            optionMapper: 17,
            optionFilter: 18,
            value: 19,
            optionLabelClass: 6,
            title: 7,
            locale: 20,
            optionClass: 8,
            optionGroupClass: 9
        }, null, [-1, -1])
    }
}

function Au(e) {
    let t, o, i, n, r, a, s, l, c, d;
    return {
        c() {
            t = Fr("div"), o = Fr("button"), i = Dr("▲"), r = Br(), a = Fr("button"), s = Dr("▼"), Nr(o, "type", "button"), Nr(o, "tabindex", "-1"), Nr(o, "aria-label", n = "increase " + e[7]), Nr(a, "type", "button"), Nr(a, "tabindex", "-1"), Nr(a, "aria-label", l = "decrease " + e[7]), Nr(t, "class", "PinturaInputSpinners")
        }, m(n, l) {
            Ar(n, t, l), Rr(t, o), Rr(o, i), Rr(t, r), Rr(t, a), Rr(a, s), c || (d = [Wr(o, "click", e[18]), Wr(a, "click", e[19])], c = !0)
        }, p(e, t) {
            128 & t[0] && n !== (n = "increase " + e[7]) && Nr(o, "aria-label", n), 128 & t[0] && l !== (l = "decrease " + e[7]) && Nr(a, "aria-label", l)
        }, d(e) {
            e && Lr(t), c = !1, ar(d)
        }
    }
}

function Lu(e) {
    let t, o, i, n, r, a, s = e[14] && e[9] && Au(e);
    return {
        c() {
            t = Fr("div"), o = Fr("input"), n = Br(), s && s.c(), Nr(o, "class", "PinturaInputField"), Nr(o, "title", e[7]), Nr(o, "type", e[1]), Nr(o, "min", e[4]), Nr(o, "max", e[5]), Nr(o, "step", e[6]), Nr(o, "inputmode", e[3]), o.value = i = e[12] ? e[15] : e[0], Nr(o, "placeholder", e[8]), Nr(o, "maxlength", e[13]), o.disabled = e[2], Nr(o, "spellcheck", "false"), Nr(o, "autocorrect", "off"), Nr(o, "autocapitalize", "off"), Zr(o, "min-width", e[11] ? e[11] + "em" : void 0), Nr(t, "class", "PinturaInput")
        }, m(i, l) {
            Ar(i, t, l), Rr(t, o), e[30](o), Rr(t, n), s && s.m(t, null), r || (a = [Wr(o, "input", e[17]), Wr(o, "blur", (function () {
                sr(e[12] && e[16]) && (e[12] && e[16]).apply(this, arguments)
            })), Wr(o, "keydown", e[20]), Wr(o, "keyup", e[21])], r = !0)
        }, p(n, r) {
            e = n, 128 & r[0] && Nr(o, "title", e[7]), 2 & r[0] && Nr(o, "type", e[1]), 16 & r[0] && Nr(o, "min", e[4]), 32 & r[0] && Nr(o, "max", e[5]), 64 & r[0] && Nr(o, "step", e[6]), 8 & r[0] && Nr(o, "inputmode", e[3]), 36865 & r[0] && i !== (i = e[12] ? e[15] : e[0]) && o.value !== i && (o.value = i), 256 & r[0] && Nr(o, "placeholder", e[8]), 8192 & r[0] && Nr(o, "maxlength", e[13]), 4 & r[0] && (o.disabled = e[2]), 2048 & r[0] && Zr(o, "min-width", e[11] ? e[11] + "em" : void 0), e[14] && e[9] ? s ? s.p(e, r) : (s = Au(e), s.c(), s.m(t, null)) : s && (s.d(1), s = null)
        }, i: tr, o: tr, d(o) {
            o && Lr(t), e[30](null), s && s.d(), r = !1, ar(a)
        }
    }
}

function Fu(e, t, o) {
    let n, r, a, s, l, c, d, u,
        h, {value: p} = t, {type: m = "text"} = t, {disabled: g = !1} = t, {inputmode: $} = t, {min: f} = t, {max: y} = t, {step: b} = t, {onchange: x = i} = t, {onkeydown: v = i} = t, {onkeyup: w = i} = t, {title: S} = t, {stepMultiplier: k = 10} = t, {placeholder: C} = t, {enableSpinButtons: T = !0} = t, {enableStopPropagation: M = !1} = t;
    const P = () => {
        let e = u.value;
        return "number" === m && (e = "numeric" === $ ? parseInt(e, 10) : parseFloat(e), !zo(e) || Number.isNaN(e) ? e = f || 0 : r && (e = gs(e, f, y))), e
    };
    let R = p;
    const I = () => {
        const e = gs(P() + (h ? b * k : b), f, y);
        e !== p && (o(27, R = e), o(0, p = e), x(p))
    }, E = () => {
        const e = gs(P() - (h ? b * k : b), f, y);
        e !== p && (o(27, R = e), o(0, p = e), x(p))
    };
    return e.$$set = e => {
        "value" in e && o(0, p = e.value), "type" in e && o(1, m = e.type), "disabled" in e && o(2, g = e.disabled), "inputmode" in e && o(3, $ = e.inputmode), "min" in e && o(4, f = e.min), "max" in e && o(5, y = e.max), "step" in e && o(6, b = e.step), "onchange" in e && o(22, x = e.onchange), "onkeydown" in e && o(23, v = e.onkeydown), "onkeyup" in e && o(24, w = e.onkeyup), "title" in e && o(7, S = e.title), "stepMultiplier" in e && o(25, k = e.stepMultiplier), "placeholder" in e && o(8, C = e.placeholder), "enableSpinButtons" in e && o(9, T = e.enableSpinButtons), "enableStopPropagation" in e && o(26, M = e.enableStopPropagation)
    }, e.$$.update = () => {
        2 & e.$$.dirty[0] && o(29, n = "number" === m), 48 & e.$$.dirty[0] && o(12, r = zo(f) && zo(y)), 64 & e.$$.dirty[0] && o(28, a = zo(b)), 805310464 & e.$$.dirty[0] && o(14, s = n && r && a), 134218753 & e.$$.dirty[0] && o(15, l = u === document.activeElement ? R : p), 32 & e.$$.dirty[0] && o(11, c = y ? (y + "").length : void 0), 2056 & e.$$.dirty[0] && o(13, d = "numeric" === $ && c ? c : void 0)
    }, [p, m, g, $, f, y, b, S, C, T, u, c, r, d, s, l, () => {
        o(27, R = P()), x(p)
    }, () => {
        o(27, R = u.value), x(P())
    }, I, E, e => {
        if (v(e), !s) return;
        h = e.shiftKey;
        const {key: t} = e;
        M && e.stopPropagation(), /up|down/i.test(t) && (/up/i.test(t) && I(), /down/i.test(t) && E(), e.preventDefault(), e.stopPropagation())
    }, e => {
        if (w(e), !s) return;
        const {key: t} = e;
        /up|down/i.test(t) && (e.preventDefault(), e.stopPropagation())
    }, x, v, w, k, M, R, a, n, function (e) {
        ha[e ? "unshift" : "push"]((() => {
            u = e, o(10, u)
        }))
    }]
}

class zu extends Ga {
    constructor(e) {
        super(), Ua(this, e, Fu, Lu, lr, {
            value: 0,
            type: 1,
            disabled: 2,
            inputmode: 3,
            min: 4,
            max: 5,
            step: 6,
            onchange: 22,
            onkeydown: 23,
            onkeyup: 24,
            title: 7,
            stepMultiplier: 25,
            placeholder: 8,
            enableSpinButtons: 9,
            enableStopPropagation: 26
        }, null, [-1, -1])
    }
}

const Du = e => ({}), Bu = e => ({});

function Ou(e) {
    let t, o, i, n, r = (e[2] || e[20]) + "", a = e[6] && Vu(e);
    return {
        c() {
            a && a.c(), t = Br(), o = Fr("span"), Nr(o, "class", i = Zc(["PinturaButtonLabel", e[3], e[5] && "implicit"]))
        }, m(e, i) {
            a && a.m(e, i), Ar(e, t, i), Ar(e, o, i), o.innerHTML = r, n = !0
        }, p(e, s) {
            e[6] ? a ? (a.p(e, s), 64 & s[0] && Ea(a, 1)) : (a = Vu(e), a.c(), Ea(a, 1), a.m(t.parentNode, t)) : a && (Ra(), Aa(a, 1, 1, (() => {
                a = null
            })), Ia()), (!n || 1048580 & s[0]) && r !== (r = (e[2] || e[20]) + "") && (o.innerHTML = r), (!n || 40 & s[0] && i !== (i = Zc(["PinturaButtonLabel", e[3], e[5] && "implicit"]))) && Nr(o, "class", i)
        }, i(e) {
            n || (Ea(a), n = !0)
        }, o(e) {
            Aa(a), n = !1
        }, d(e) {
            a && a.d(e), e && Lr(t), e && Lr(o)
        }
    }
}

function Wu(e) {
    let t, o;
    return t = new zu({
        props: {
            value: e[10],
            onchange: e[16],
            enableStopPropagation: !0,
            type: "number",
            inputmode: "numeric",
            min: e[8].reduce(Ku, 1 / 0),
            max: e[8].reduce(Ju, -1 / 0),
            enableSpinButtons: !1
        }
    }), {
        c() {
            Na(t.$$.fragment)
        }, m(e, i) {
            Ha(t, e, i), o = !0
        }, p(e, o) {
            const i = {};
            1024 & o[0] && (i.value = e[10]), 65536 & o[0] && (i.onchange = e[16]), 256 & o[0] && (i.min = e[8].reduce(Ku, 1 / 0)), 256 & o[0] && (i.max = e[8].reduce(Ju, -1 / 0)), t.$set(i)
        }, i(e) {
            o || (Ea(t.$$.fragment, e), o = !0)
        }, o(e) {
            Aa(t.$$.fragment, e), o = !1
        }, d(e) {
            ja(t, e)
        }
    }
}

function Vu(e) {
    let t, o;
    return t = new wd({props: {class: "PinturaButtonIcon", $$slots: {default: [_u]}, $$scope: {ctx: e}}}), {
        c() {
            Na(t.$$.fragment)
        }, m(e, i) {
            Ha(t, e, i), o = !0
        }, p(e, o) {
            const i = {};
            536870976 & o[0] && (i.$$scope = {dirty: o, ctx: e}), t.$set(i)
        }, i(e) {
            o || (Ea(t.$$.fragment, e), o = !0)
        }, o(e) {
            Aa(t.$$.fragment, e), o = !1
        }, d(e) {
            ja(t, e)
        }
    }
}

function _u(e) {
    let t;
    return {
        c() {
            t = zr("g")
        }, m(o, i) {
            Ar(o, t, i), t.innerHTML = e[6]
        }, p(e, o) {
            64 & o[0] && (t.innerHTML = e[6])
        }, d(e) {
            e && Lr(t)
        }
    }
}

function Nu(e) {
    let t, o, i, n, r;
    const a = [Wu, Ou], s = [];

    function l(e, t) {
        return e[17] ? 0 : 1
    }

    return o = l(e), i = s[o] = a[o](e), {
        c() {
            t = Fr("span"), i.c(), Nr(t, "slot", "label"), Nr(t, "class", n = Zc(["PinturaButtonInner", e[17] && "PinturaComboBox", e[4]]))
        }, m(e, i) {
            Ar(e, t, i), s[o].m(t, null), r = !0
        }, p(e, c) {
            let d = o;
            o = l(e), o === d ? s[o].p(e, c) : (Ra(), Aa(s[d], 1, 1, (() => {
                s[d] = null
            })), Ia(), i = s[o], i ? i.p(e, c) : (i = s[o] = a[o](e), i.c()), Ea(i, 1), i.m(t, null)), (!r || 131088 & c[0] && n !== (n = Zc(["PinturaButtonInner", e[17] && "PinturaComboBox", e[4]]))) && Nr(t, "class", n)
        }, i(e) {
            r || (Ea(i), r = !0)
        }, o(e) {
            Aa(i), r = !1
        }, d(e) {
            e && Lr(t), s[o].d()
        }
    }
}

function Hu(e) {
    let t, o, i = e[31].label + "";
    return {
        c() {
            t = Fr("span"), o = Dr(i), Nr(t, "slot", "group")
        }, m(e, i) {
            Ar(e, t, i), Rr(t, o)
        }, p(e, t) {
            1 & t[1] && i !== (i = e[31].label + "") && Ur(o, i)
        }, d(e) {
            e && Lr(t)
        }
    }
}

function ju(e) {
    let t, o;
    return t = new wd({
        props: {
            style: M(e[14]) ? e[14](e[31].value) : e[14],
            $$slots: {default: [Uu]},
            $$scope: {ctx: e}
        }
    }), {
        c() {
            Na(t.$$.fragment)
        }, m(e, i) {
            Ha(t, e, i), o = !0
        }, p(e, o) {
            const i = {};
            16384 & o[0] | 1 & o[1] && (i.style = M(e[14]) ? e[14](e[31].value) : e[14]), 536870912 & o[0] | 1 & o[1] && (i.$$scope = {
                dirty: o,
                ctx: e
            }), t.$set(i)
        }, i(e) {
            o || (Ea(t.$$.fragment, e), o = !0)
        }, o(e) {
            Aa(t.$$.fragment, e), o = !1
        }, d(e) {
            ja(t, e)
        }
    }
}

function Uu(e) {
    let t, o = e[31].icon + "";
    return {
        c() {
            t = zr("g")
        }, m(e, i) {
            Ar(e, t, i), t.innerHTML = o
        }, p(e, i) {
            1 & i[1] && o !== (o = e[31].icon + "") && (t.innerHTML = o)
        }, d(e) {
            e && Lr(t)
        }
    }
}

function Gu(e) {
    let t, o, i, n, r, a, s, l = e[31].label + "", c = e[31].sublabel && Zu(e);
    return {
        c() {
            t = Fr("span"), o = new Yr(!1), i = Br(), c && c.c(), o.a = i, Nr(t, "class", n = Zc(["PinturaDropdownOptionLabel", e[11]]))
        }, m(n, d) {
            Ar(n, t, d), o.m(l, t), Rr(t, i), c && c.m(t, null), a || (s = wr(r = od.call(null, t, M(e[15]) ? e[15](e[31].value) : e[15])), a = !0)
        }, p(e, i) {
            1 & i[1] && l !== (l = e[31].label + "") && o.p(l), e[31].sublabel ? c ? c.p(e, i) : (c = Zu(e), c.c(), c.m(t, null)) : c && (c.d(1), c = null), 2048 & i[0] && n !== (n = Zc(["PinturaDropdownOptionLabel", e[11]])) && Nr(t, "class", n), r && sr(r.update) && 32768 & i[0] | 1 & i[1] && r.update.call(null, M(e[15]) ? e[15](e[31].value) : e[15])
        }, d(e) {
            e && Lr(t), c && c.d(), a = !1, s()
        }
    }
}

function Zu(e) {
    let t, o = e[31].sublabel + "";
    return {
        c() {
            t = Fr("span"), Nr(t, "class", "PinturaDropdownOptionSublabel")
        }, m(e, i) {
            Ar(e, t, i), t.innerHTML = o
        }, p(e, i) {
            1 & i[1] && o !== (o = e[31].sublabel + "") && (t.innerHTML = o)
        }, d(e) {
            e && Lr(t)
        }
    }
}

function Xu(e) {
    let t, o, i, n = e[31].icon && ju(e), r = !e[31].hideLabel && Gu(e);
    return {
        c() {
            t = Fr("span"), n && n.c(), o = Br(), r && r.c(), Nr(t, "slot", "option")
        }, m(e, a) {
            Ar(e, t, a), n && n.m(t, null), Rr(t, o), r && r.m(t, null), i = !0
        }, p(e, i) {
            e[31].icon ? n ? (n.p(e, i), 1 & i[1] && Ea(n, 1)) : (n = ju(e), n.c(), Ea(n, 1), n.m(t, o)) : n && (Ra(), Aa(n, 1, 1, (() => {
                n = null
            })), Ia()), e[31].hideLabel ? r && (r.d(1), r = null) : r ? r.p(e, i) : (r = Gu(e), r.c(), r.m(t, null))
        }, i(e) {
            i || (Ea(n), i = !0)
        }, o(e) {
            Aa(n), i = !1
        }, d(e) {
            e && Lr(t), n && n.d(), r && r.d()
        }
    }
}

function Yu(e) {
    let t, o, i, n, r, a;
    const s = e[27].controls, l = mr(s, e, e[29], Bu);
    return i = new Eu({
        props: {
            class: "PinturaOptionsList PinturaScrollableContent",
            name: e[7],
            value: e[10],
            selectedIndex: e[9],
            optionFilter: e[12],
            optionMapper: e[13],
            optionLabelClass: Zc(["PinturaDropdownOptionLabel", e[11]]),
            optionGroupClass: "PinturaListOptionGroup",
            optionClass: "PinturaListOption",
            options: e[18],
            onchange: e[21],
            $$slots: {
                option: [Xu, ({option: e}) => ({31: e}), ({option: e}) => [0, e ? 1 : 0]],
                group: [Hu, ({option: e}) => ({31: e}), ({option: e}) => [0, e ? 1 : 0]]
            },
            $$scope: {ctx: e}
        }
    }), {
        c() {
            t = Fr("div"), l && l.c(), o = Br(), Na(i.$$.fragment), Nr(t, "slot", "details"), Nr(t, "class", "PinturaOptionsListWrapper")
        }, m(s, c) {
            Ar(s, t, c), l && l.m(t, null), Rr(t, o), Ha(i, t, null), n = !0, r || (a = Wr(t, "keydown", e[23]), r = !0)
        }, p(e, t) {
            l && l.p && (!n || 536870912 & t[0]) && fr(l, s, e, e[29], n ? $r(s, e[29], t, Du) : yr(e[29]), Bu);
            const o = {};
            128 & t[0] && (o.name = e[7]), 1024 & t[0] && (o.value = e[10]), 512 & t[0] && (o.selectedIndex = e[9]), 4096 & t[0] && (o.optionFilter = e[12]), 8192 & t[0] && (o.optionMapper = e[13]), 2048 & t[0] && (o.optionLabelClass = Zc(["PinturaDropdownOptionLabel", e[11]])), 262144 & t[0] && (o.options = e[18]), 536922112 & t[0] | 1 & t[1] && (o.$$scope = {
                dirty: t,
                ctx: e
            }), i.$set(o)
        }, i(e) {
            n || (Ea(l, e), Ea(i.$$.fragment, e), n = !0)
        }, o(e) {
            Aa(l, e), Aa(i.$$.fragment, e), n = !1
        }, d(e) {
            e && Lr(t), l && l.d(e), ja(i), r = !1, a()
        }
    }
}

function qu(e) {
    let t, o, i;

    function n(t) {
        e[28](t)
    }

    let r = {
        onshow: e[22],
        buttonTitle: kd(e[2], e[1]),
        buttonClass: Zc(["PinturaDropdownButton", e[0], e[5] && "PinturaDropdownIconOnly"]),
        $$slots: {details: [Yu], label: [Nu]},
        $$scope: {ctx: e}
    };
    return void 0 !== e[19] && (r.isActive = e[19]), t = new qd({props: r}), ha.push((() => _a(t, "isActive", n))), {
        c() {
            Na(t.$$.fragment)
        }, m(e, o) {
            Ha(t, e, o), i = !0
        }, p(e, i) {
            const n = {};
            6 & i[0] && (n.buttonTitle = kd(e[2], e[1])), 33 & i[0] && (n.buttonClass = Zc(["PinturaDropdownButton", e[0], e[5] && "PinturaDropdownIconOnly"])), 538443772 & i[0] && (n.$$scope = {
                dirty: i,
                ctx: e
            }), !o && 524288 & i[0] && (o = !0, n.isActive = e[19], xa((() => o = !1))), t.$set(n)
        }, i(e) {
            i || (Ea(t.$$.fragment, e), i = !0)
        }, o(e) {
            Aa(t.$$.fragment, e), i = !1
        }, d(e) {
            ja(t, e)
        }
    }
}

const Ku = (e, [t]) => t < e ? t : e, Ju = (e, [t]) => t > e ? t : e;

function Qu(e, t, o) {
    let n, r, {
        $$slots: a = {},
        $$scope: s
    } = t, {class: l} = t, {title: c} = t, {label: d} = t, {labelClass: u} = t, {innerClass: h} = t, {hideLabel: p = !1} = t, {icon: m} = t, {name: g} = t, {options: $ = []} = t, {selectedIndex: f = -1} = t, {value: y} = t, {optionLabelClass: b} = t, {optionFilter: x} = t, {optionMapper: v} = t, {optionIconStyle: w} = t, {optionLabelStyle: S} = t, {locale: k} = t, {onchange: C = i} = t, {onload: T = i} = t, {ondestroy: M = i} = t, {enableInput: P = !1} = t;
    let R;
    return na((() => T({options: $}))), aa((() => M({options: $}))), e.$$set = e => {
        "class" in e && o(0, l = e.class), "title" in e && o(1, c = e.title), "label" in e && o(2, d = e.label), "labelClass" in e && o(3, u = e.labelClass), "innerClass" in e && o(4, h = e.innerClass), "hideLabel" in e && o(5, p = e.hideLabel), "icon" in e && o(6, m = e.icon), "name" in e && o(7, g = e.name), "options" in e && o(8, $ = e.options), "selectedIndex" in e && o(9, f = e.selectedIndex), "value" in e && o(10, y = e.value), "optionLabelClass" in e && o(11, b = e.optionLabelClass), "optionFilter" in e && o(12, x = e.optionFilter), "optionMapper" in e && o(13, v = e.optionMapper), "optionIconStyle" in e && o(14, w = e.optionIconStyle), "optionLabelStyle" in e && o(15, S = e.optionLabelStyle), "locale" in e && o(24, k = e.locale), "onchange" in e && o(16, C = e.onchange), "onload" in e && o(25, T = e.onload), "ondestroy" in e && o(26, M = e.ondestroy), "enableInput" in e && o(17, P = e.enableInput), "$$scope" in e && o(29, s = e.$$scope)
    }, e.$$.update = () => {
        16777472 & e.$$.dirty[0] && o(18, n = k ? ru($, k) : $), 263168 & e.$$.dirty[0] && o(20, r = n.reduce(((e, t) => {
            if (e) return e;
            const o = Array.isArray(t) ? t : [t, t], [i, n] = o;
            return au(i, y) ? n : void 0
        }), void 0) || (e => {
            const t = e.find((e => void 0 === e[0]));
            if (t) return t[1]
        })(n) || y)
    }, [l, c, d, u, h, p, m, g, $, f, y, b, x, v, w, S, C, P, n, R, r, e => {
        o(20, r = e.value), C(e), o(19, R = !1)
    }, ({e: e, panel: t}) => {
        if (e && e.key && /up|down/i.test(e.key)) return Bd(t.querySelector("input:not([disabled])"));
        Bd(t.querySelector("fieldset"))
    }, e => {
        /tab/i.test(e.key) && e.preventDefault()
    }, k, T, M, a, function (e) {
        R = e, o(19, R)
    }, s]
}

class eh extends Ga {
    constructor(e) {
        super(), Ua(this, e, Qu, qu, lr, {
            class: 0,
            title: 1,
            label: 2,
            labelClass: 3,
            innerClass: 4,
            hideLabel: 5,
            icon: 6,
            name: 7,
            options: 8,
            selectedIndex: 9,
            value: 10,
            optionLabelClass: 11,
            optionFilter: 12,
            optionMapper: 13,
            optionIconStyle: 14,
            optionLabelStyle: 15,
            locale: 24,
            onchange: 16,
            onload: 25,
            ondestroy: 26,
            enableInput: 17
        }, null, [-1, -1])
    }
}

function th(e) {
    let t;
    return {
        c() {
            t = Fr("div"), Nr(t, "slot", "details")
        }, m(o, i) {
            Ar(o, t, i), e[14](t)
        }, p: tr, d(o) {
            o && Lr(t), e[14](null)
        }
    }
}

function oh(e) {
    let t, o, i;

    function n(t) {
        e[15](t)
    }

    let r = {
        buttonLabel: e[0],
        buttonClass: e[1],
        buttonIcon: e[2],
        buttonHideLabel: e[3],
        buttonTitle: e[4],
        buttonLabelClass: e[5],
        onshow: e[6],
        onhide: e[7],
        $$slots: {details: [th]},
        $$scope: {ctx: e}
    };
    return void 0 !== e[9] && (r.isActive = e[9]), t = new qd({props: r}), ha.push((() => _a(t, "isActive", n))), {
        c() {
            Na(t.$$.fragment)
        }, m(e, o) {
            Ha(t, e, o), i = !0
        }, p(e, [i]) {
            const n = {};
            1 & i && (n.buttonLabel = e[0]), 2 & i && (n.buttonClass = e[1]), 4 & i && (n.buttonIcon = e[2]), 8 & i && (n.buttonHideLabel = e[3]), 16 & i && (n.buttonTitle = e[4]), 32 & i && (n.buttonLabelClass = e[5]), 64 & i && (n.onshow = e[6]), 128 & i && (n.onhide = e[7]), 65792 & i && (n.$$scope = {
                dirty: i,
                ctx: e
            }), !o && 512 & i && (o = !0, n.isActive = e[9], xa((() => o = !1))), t.$set(n)
        }, i(e) {
            i || (Ea(t.$$.fragment, e), i = !0)
        }, o(e) {
            Aa(t.$$.fragment, e), i = !1
        }, d(e) {
            ja(t, e)
        }
    }
}

function ih(e, t, o) {
    let {buttonLabel: n} = t, {buttonClass: r} = t, {buttonIcon: a} = t, {buttonHideLabel: s} = t, {buttonTitle: l} = t, {buttonLabelClass: c} = t, {root: d} = t, {ondestroy: u = i} = t, {onshow: h = i} = t, {onhide: p = i} = t;
    let m, g = !1;
    return aa(u), e.$$set = e => {
        "buttonLabel" in e && o(0, n = e.buttonLabel), "buttonClass" in e && o(1, r = e.buttonClass), "buttonIcon" in e && o(2, a = e.buttonIcon), "buttonHideLabel" in e && o(3, s = e.buttonHideLabel), "buttonTitle" in e && o(4, l = e.buttonTitle), "buttonLabelClass" in e && o(5, c = e.buttonLabelClass), "root" in e && o(10, d = e.root), "ondestroy" in e && o(11, u = e.ondestroy), "onshow" in e && o(6, h = e.onshow), "onhide" in e && o(7, p = e.onhide)
    }, e.$$.update = () => {
        1280 & e.$$.dirty && m && d && m.firstChild !== d && (m.hasChildNodes() ? m.replaceChild(d, m.firstChild) : m.append(d))
    }, [n, r, a, s, l, c, h, p, m, g, d, u, () => o(9, g = !1), () => o(9, g = !0), function (e) {
        ha[e ? "unshift" : "push"]((() => {
            m = e, o(8, m)
        }))
    }, function (e) {
        g = e, o(9, g)
    }]
}

class nh extends Ga {
    constructor(e) {
        super(), Ua(this, e, ih, oh, lr, {
            buttonLabel: 0,
            buttonClass: 1,
            buttonIcon: 2,
            buttonHideLabel: 3,
            buttonTitle: 4,
            buttonLabelClass: 5,
            root: 10,
            ondestroy: 11,
            onshow: 6,
            onhide: 7,
            hide: 12,
            show: 13
        })
    }

    get hide() {
        return this.$$.ctx[12]
    }

    get show() {
        return this.$$.ctx[13]
    }
}

var rh = (e, t = {}) => {
    const {
        direction: o,
        shiftMultiplier: i = 10,
        bubbles: n = !1,
        preventDefault: r = !1,
        stopKeydownPropagation: a = !0
    } = t, s = "horizontal" === o, l = "vertical" === o, c = t => {
        const {key: o} = t, c = t.shiftKey, d = /up|down/i.test(o), u = /left|right/i.test(o);
        if (!u && !d) return;
        if (s && d) return;
        if (l && u) return;
        const h = c ? i : 1;
        a && t.stopPropagation(), r && t.preventDefault(), e.dispatchEvent(new CustomEvent("nudge", {
            bubbles: n,
            detail: he((/left/i.test(o) ? -1 : /right/i.test(o) ? 1 : 0) * h, (/up/i.test(o) ? -1 : /down/i.test(o) ? 1 : 0) * h)
        }))
    };
    return e.addEventListener("keydown", c), {
        destroy() {
            e.removeEventListener("keydown", c)
        }
    }
}, ah = (e, t, o) => (e - t) / (o - t);
const sh = e => ({}), lh = e => ({});

function ch(e) {
    let t, o, i;
    return {
        c() {
            t = Fr("label"), o = Dr(e[0]), Nr(t, "for", e[17]), Nr(t, "class", i = e[1] ? "implicit" : void 0)
        }, m(e, i) {
            Ar(e, t, i), Rr(t, o)
        }, p(e, n) {
            1 & n[0] && Ur(o, e[0]), 131072 & n[0] && Nr(t, "for", e[17]), 2 & n[0] && i !== (i = e[1] ? "implicit" : void 0) && Nr(t, "class", i)
        }, d(e) {
            e && Lr(t)
        }
    }
}

function dh(e) {
    let t, o, i, n, r, a, s, l;
    return o = new wd({
        props: {
            $$slots: {default: [uh]},
            $$scope: {ctx: e}
        }
    }), r = new wd({props: {$$slots: {default: [hh]}, $$scope: {ctx: e}}}), {
        c() {
            t = Fr("button"), Na(o.$$.fragment), i = Br(), n = Fr("button"), Na(r.$$.fragment), Nr(t, "type", "button"), Nr(t, "aria-label", "Increase"), Nr(n, "type", "button"), Nr(n, "aria-label", "Decrease")
        }, m(c, d) {
            Ar(c, t, d), Ha(o, t, null), Ar(c, i, d), Ar(c, n, d), Ha(r, n, null), a = !0, s || (l = [Wr(t, "pointerdown", e[20](1)), Wr(n, "pointerdown", e[20](-1))], s = !0)
        }, p(e, t) {
            const i = {};
            256 & t[1] && (i.$$scope = {dirty: t, ctx: e}), o.$set(i);
            const n = {};
            256 & t[1] && (n.$$scope = {dirty: t, ctx: e}), r.$set(n)
        }, i(e) {
            a || (Ea(o.$$.fragment, e), Ea(r.$$.fragment, e), a = !0)
        }, o(e) {
            Aa(o.$$.fragment, e), Aa(r.$$.fragment, e), a = !1
        }, d(e) {
            e && Lr(t), ja(o), e && Lr(i), e && Lr(n), ja(r), s = !1, ar(l)
        }
    }
}

function uh(e) {
    let t;
    return {
        c() {
            t = zr("path"), Nr(t, "d", "M8 12 h8 M12 8 v8")
        }, m(e, o) {
            Ar(e, t, o)
        }, p: tr, d(e) {
            e && Lr(t)
        }
    }
}

function hh(e) {
    let t;
    return {
        c() {
            t = zr("path"), Nr(t, "d", "M9 12 h6")
        }, m(e, o) {
            Ar(e, t, o)
        }, p: tr, d(e) {
            e && Lr(t)
        }
    }
}

function ph(e) {
    let t, o, i, n, r, a, s, l, c, d, u, h, p, m, g, $, f = e[0] && ch(e);
    const y = e[37].default, b = mr(y, e, e[39], null), x = e[37].knob, v = mr(x, e, e[39], lh);
    let w = e[8] && dh(e);
    return {
        c() {
            t = Fr("div"), o = Fr("div"), f && f.c(), i = Br(), n = Fr("input"), r = Br(), a = Fr("div"), b && b.c(), l = Br(), c = Fr("div"), d = Fr("div"), v && v.c(), h = Br(), w && w.c(), Nr(n, "type", "range"), Nr(n, "id", e[17]), Nr(n, "min", e[2]), Nr(n, "max", e[3]), Nr(n, "step", e[4]), n.value = e[13], Zr(n, "pointer-events", e[9] ? "none" : void 0), Nr(a, "class", s = Zc(["PinturaSliderTrack", e[5]])), Nr(d, "class", u = Zc(["PinturaSliderKnob", e[6]])), Nr(c, "class", "PinturaSliderKnobController"), Zr(c, "transform", e[16]), Nr(o, "class", "PinturaSliderControl"), Zr(o, "--slider-position", Math.round(e[14])), Nr(t, "class", p = Zc(["PinturaSlider", e[11]])), Nr(t, "data-direction", e[7])
        }, m(s, u) {
            Ar(s, t, u), Rr(t, o), f && f.m(o, null), Rr(o, i), Rr(o, n), e[38](n), Rr(o, r), Rr(o, a), b && b.m(a, null), Rr(o, l), Rr(o, c), Rr(c, d), v && v.m(d, null), Rr(t, h), w && w.m(t, null), m = !0, g || ($ = [Wr(n, "input", e[18]), Wr(n, "nudge", e[19]), wr(rh.call(null, n)), Wr(o, "pointerdown", (function () {
                sr(e[10] && e[12]) && (e[10] && e[12]).apply(this, arguments)
            }))], g = !0)
        }, p(r, l) {
            (e = r)[0] ? f ? f.p(e, l) : (f = ch(e), f.c(), f.m(o, i)) : f && (f.d(1), f = null), (!m || 131072 & l[0]) && Nr(n, "id", e[17]), (!m || 4 & l[0]) && Nr(n, "min", e[2]), (!m || 8 & l[0]) && Nr(n, "max", e[3]), (!m || 16 & l[0]) && Nr(n, "step", e[4]), (!m || 8192 & l[0]) && (n.value = e[13]), 512 & l[0] && Zr(n, "pointer-events", e[9] ? "none" : void 0), b && b.p && (!m || 256 & l[1]) && fr(b, y, e, e[39], m ? $r(y, e[39], l, null) : yr(e[39]), null), (!m || 32 & l[0] && s !== (s = Zc(["PinturaSliderTrack", e[5]]))) && Nr(a, "class", s), v && v.p && (!m || 256 & l[1]) && fr(v, x, e, e[39], m ? $r(x, e[39], l, sh) : yr(e[39]), lh), (!m || 64 & l[0] && u !== (u = Zc(["PinturaSliderKnob", e[6]]))) && Nr(d, "class", u), 65536 & l[0] && Zr(c, "transform", e[16]), 16384 & l[0] && Zr(o, "--slider-position", Math.round(e[14])), e[8] ? w ? (w.p(e, l), 256 & l[0] && Ea(w, 1)) : (w = dh(e), w.c(), Ea(w, 1), w.m(t, null)) : w && (Ra(), Aa(w, 1, 1, (() => {
                w = null
            })), Ia()), (!m || 2048 & l[0] && p !== (p = Zc(["PinturaSlider", e[11]]))) && Nr(t, "class", p), (!m || 128 & l[0]) && Nr(t, "data-direction", e[7])
        }, i(e) {
            m || (Ea(b, e), Ea(v, e), Ea(w), m = !0)
        }, o(e) {
            Aa(b, e), Aa(v, e), Aa(w), m = !1
        }, d(o) {
            o && Lr(t), f && f.d(), e[38](null), b && b.d(o), v && v.d(o), w && w.d(), g = !1, ar($)
        }
    }
}

function mh(e, t, o) {
    let n, r, a, s, l, c, d, u, p, m, g, $, f, y, b, x, {
        $$slots: v = {},
        $$scope: w
    } = t, {id: S} = t, {label: k} = t, {hideLabel: C = !1} = t, {min: T = 0} = t, {max: M = 100} = t, {step: P = 1} = t, {value: R = 0} = t, {valueMin: I} = t, {valueMax: A} = t, {trackClass: L} = t, {knobClass: F} = t, {ongrab: z = i} = t, {onchange: D = i} = t, {onrelease: B = i} = t, {onexceed: O = i} = t, {direction: W = "x"} = t, {getValue: V = Z} = t, {setValue: _ = Z} = t, {enableSpinButtons: N = !0} = t, {enableForceUseKnob: H = !1} = t, {enableStopPropagation: j = !0} = t, {enablePointerdownListener: U = !0} = t, {maxInteractionDistance: G = 6} = t, {class: X} = t;
    const Y = e => _(((e, t) => (t = 1 / t, Math.round(e * t) / t))(gs(e, T, M), P), R), q = (e, t, i = {}) => {
        const {grabbed: n = !1, released: r = !1} = i, s = Y(T + e / t * a), l = I || T, c = A || M;
        o(21, R = h(s) ? s : gs(s, l, c)), x !== s && (x = s, !h(s) && (s < l || s > c) && O(R, s), R !== b && (b = R, n && z(R), D(R), r && B(R)))
    };
    let K;
    let J;
    const Q = e => {
        const t = e[p] - y;
        q(f + t, $)
    }, ee = e => {
        J = setTimeout((() => {
            $ = void 0
        }), 50), document.documentElement.removeEventListener("pointermove", Q), document.documentElement.removeEventListener("pointerup", ee), D(R), B(R)
    }, te = () => {
        o(21, R = Y(r + ie * P)), D(R)
    };
    let oe, ie = 1, ne = !1;
    const re = e => {
        clearTimeout(oe), ne || te(), B(R), document.removeEventListener("pointerup", re)
    };
    return e.$$set = e => {
        "id" in e && o(22, S = e.id), "label" in e && o(0, k = e.label), "hideLabel" in e && o(1, C = e.hideLabel), "min" in e && o(2, T = e.min), "max" in e && o(3, M = e.max), "step" in e && o(4, P = e.step), "value" in e && o(21, R = e.value), "valueMin" in e && o(23, I = e.valueMin), "valueMax" in e && o(24, A = e.valueMax), "trackClass" in e && o(5, L = e.trackClass), "knobClass" in e && o(6, F = e.knobClass), "ongrab" in e && o(25, z = e.ongrab), "onchange" in e && o(26, D = e.onchange), "onrelease" in e && o(27, B = e.onrelease), "onexceed" in e && o(28, O = e.onexceed), "direction" in e && o(7, W = e.direction), "getValue" in e && o(29, V = e.getValue), "setValue" in e && o(30, _ = e.setValue), "enableSpinButtons" in e && o(8, N = e.enableSpinButtons), "enableForceUseKnob" in e && o(9, H = e.enableForceUseKnob), "enableStopPropagation" in e && o(31, j = e.enableStopPropagation), "enablePointerdownListener" in e && o(10, U = e.enablePointerdownListener), "maxInteractionDistance" in e && o(32, G = e.maxInteractionDistance), "class" in e && o(11, X = e.class), "$$scope" in e && o(39, w = e.$$scope)
    }, e.$$.update = () => {
        4194305 & e.$$.dirty[0] && o(17, n = S || (k ? "PinturaSlider_" + E() : void 0)), 538968064 & e.$$.dirty[0] && o(13, r = void 0 !== R ? V(R) : 0), 12 & e.$$.dirty[0] && (a = M - T), 8204 & e.$$.dirty[0] && o(34, s = ah(r, T, M)), 8 & e.$$.dirty[1] && o(14, l = 100 * s), 128 & e.$$.dirty[0] && o(35, c = W.toUpperCase()), 128 & e.$$.dirty[0] && o(36, d = "x" === W ? "Width" : "Height"), 32 & e.$$.dirty[1] && (u = "offset" + d), 16 & e.$$.dirty[1] && (p = "page" + c), 16384 & e.$$.dirty[0] | 16 & e.$$.dirty[1] && o(16, m = `translate${c}(${l}%)`)
    }, [k, C, T, M, P, L, F, W, N, H, U, X, e => {
        clearTimeout(J);
        let t = !1;
        j && e.stopPropagation(), clearTimeout(K);
        const o = g.getBoundingClientRect();
        if ($ = g[u], y = e[p], f = y - o[W], H) {
            if (Math.abs(f - s * $) > G) return;
            t = !0, e.stopPropagation()
        }
        return document.activeElement !== g && g.focus(), q(f, $, {grabbed: !0}), document.documentElement.addEventListener("pointermove", Q), document.documentElement.addEventListener("pointerup", ee), t
    }, r, l, g, m, n, e => {
        $ || (o(21, R = _(parseFloat(e.target.value))), R !== b && (b = R, D(R)))
    }, e => {
        const t = g[u];
        q(r / a * t + e.detail[W], t), clearTimeout(K), K = setTimeout((() => {
            B(R)
        }), 250)
    }, e => t => {
        clearTimeout(K), ie = e, ne = !1, oe = setInterval((() => {
            ne = !0, te()
        }), 100), document.addEventListener("pointercancel", re), document.addEventListener("pointerup", re)
    }, R, S, I, A, z, D, B, O, V, _, j, G, e => {
        const t = g.getBoundingClientRect(), o = e[p] - t[W], i = g[u];
        return Math.abs(o - s * i)
    }, s, c, d, v, function (e) {
        ha[e ? "unshift" : "push"]((() => {
            g = e, o(15, g)
        }))
    }, w]
}

class gh extends Ga {
    constructor(e) {
        super(), Ua(this, e, mh, ph, lr, {
            id: 22,
            label: 0,
            hideLabel: 1,
            min: 2,
            max: 3,
            step: 4,
            value: 21,
            valueMin: 23,
            valueMax: 24,
            trackClass: 5,
            knobClass: 6,
            ongrab: 25,
            onchange: 26,
            onrelease: 27,
            onexceed: 28,
            direction: 7,
            getValue: 29,
            setValue: 30,
            enableSpinButtons: 8,
            enableForceUseKnob: 9,
            enableStopPropagation: 31,
            enablePointerdownListener: 10,
            maxInteractionDistance: 32,
            class: 11,
            eventDistanceToKnob: 33,
            handlePointerDown: 12
        }, null, [-1, -1])
    }

    get eventDistanceToKnob() {
        return this.$$.ctx[33]
    }

    get handlePointerDown() {
        return this.$$.ctx[12]
    }
}

function $h(e) {
    let t, o;
    return t = new wd({props: {class: "PinturaButtonIcon", $$slots: {default: [fh]}, $$scope: {ctx: e}}}), {
        c() {
            Na(t.$$.fragment)
        }, m(e, i) {
            Ha(t, e, i), o = !0
        }, p(e, o) {
            const i = {};
            1048580 & o && (i.$$scope = {dirty: o, ctx: e}), t.$set(i)
        }, i(e) {
            o || (Ea(t.$$.fragment, e), o = !0)
        }, o(e) {
            Aa(t.$$.fragment, e), o = !1
        }, d(e) {
            ja(t, e)
        }
    }
}

function fh(e) {
    let t;
    return {
        c() {
            t = zr("g")
        }, m(o, i) {
            Ar(o, t, i), t.innerHTML = e[2]
        }, p(e, o) {
            4 & o && (t.innerHTML = e[2])
        }, d(e) {
            e && Lr(t)
        }
    }
}

function yh(e) {
    let t, o, i = iu(e[8], e[6]) + "";
    return {
        c() {
            t = Fr("span"), o = Dr(i), Nr(t, "class", "PinturaButtonLabelPrefix")
        }, m(e, i) {
            Ar(e, t, i), Rr(t, o)
        }, p(e, t) {
            320 & t && i !== (i = iu(e[8], e[6]) + "") && Ur(o, i)
        }, d(e) {
            e && Lr(t)
        }
    }
}

function bh(e) {
    let t, o, i, n, r, a, s, l, c, d = e[2] && $h(e), u = e[8] && yh(e);
    return {
        c() {
            t = Fr("span"), d && d.c(), o = Br(), u && u.c(), i = Br(), n = Fr("span"), r = Dr(e[9]), Nr(n, "class", a = Zc(["PinturaButtonLabel", e[3], e[5] && "implicit"])), Nr(t, "slot", "label"), Nr(t, "title", s = iu(e[1], e[6])), Nr(t, "class", l = Zc(["PinturaButtonInner", e[4]]))
        }, m(e, a) {
            Ar(e, t, a), d && d.m(t, null), Rr(t, o), u && u.m(t, null), Rr(t, i), Rr(t, n), Rr(n, r), c = !0
        }, p(e, h) {
            e[2] ? d ? (d.p(e, h), 4 & h && Ea(d, 1)) : (d = $h(e), d.c(), Ea(d, 1), d.m(t, o)) : d && (Ra(), Aa(d, 1, 1, (() => {
                d = null
            })), Ia()), e[8] ? u ? u.p(e, h) : (u = yh(e), u.c(), u.m(t, i)) : u && (u.d(1), u = null), (!c || 512 & h) && Ur(r, e[9]), (!c || 40 & h && a !== (a = Zc(["PinturaButtonLabel", e[3], e[5] && "implicit"]))) && Nr(n, "class", a), (!c || 66 & h && s !== (s = iu(e[1], e[6]))) && Nr(t, "title", s), (!c || 16 & h && l !== (l = Zc(["PinturaButtonInner", e[4]]))) && Nr(t, "class", l)
        }, i(e) {
            c || (Ea(d), c = !0)
        }, o(e) {
            Aa(d), c = !1
        }, d(e) {
            e && Lr(t), d && d.d(), u && u.d()
        }
    }
}

function xh(e) {
    let t, o, i, n, r;
    const a = [{label: iu(e[1], e[6])}, {hideLabel: !0}, e[12], {value: e[7]}, {onchange: e[11]}];
    let s = {};
    for (let e = 0; e < a.length; e += 1) s = ir(s, a[e]);
    return o = new gh({props: s}), {
        c() {
            t = Fr("div"), Na(o.$$.fragment), Nr(t, "slot", "details")
        }, m(a, s) {
            Ar(a, t, s), Ha(o, t, null), i = !0, n || (r = Wr(t, "keydown", e[10]), n = !0)
        }, p(e, t) {
            const i = 6338 & t ? Wa(a, [66 & t && {label: iu(e[1], e[6])}, a[1], 4096 & t && Va(e[12]), 128 & t && {value: e[7]}, 2048 & t && {onchange: e[11]}]) : {};
            o.$set(i)
        }, i(e) {
            i || (Ea(o.$$.fragment, e), i = !0)
        }, o(e) {
            Aa(o.$$.fragment, e), i = !1
        }, d(e) {
            e && Lr(t), ja(o), n = !1, r()
        }
    }
}

function vh(e) {
    let t, o;
    return t = new qd({
        props: {
            panelClass: "PinturaSliderPanel",
            buttonClass: Zc(["PinturaSliderButton", e[0], e[5] && "PinturaSliderIconOnly"]),
            $$slots: {details: [xh], label: [bh]},
            $$scope: {ctx: e}
        }
    }), {
        c() {
            Na(t.$$.fragment)
        }, m(e, i) {
            Ha(t, e, i), o = !0
        }, p(e, [o]) {
            const i = {};
            33 & o && (i.buttonClass = Zc(["PinturaSliderButton", e[0], e[5] && "PinturaSliderIconOnly"])), 1053694 & o && (i.$$scope = {
                dirty: o,
                ctx: e
            }), t.$set(i)
        }, i(e) {
            o || (Ea(t.$$.fragment, e), o = !0)
        }, o(e) {
            Aa(t.$$.fragment, e), o = !1
        }, d(e) {
            ja(t, e)
        }
    }
}

function wh(e, t, o) {
    const n = ["class", "title", "label", "icon", "labelClass", "innerClass", "hideLabel", "locale", "value", "onchange", "labelPrefix"];
    let r = xr(t, n), {class: a} = t, {title: s} = t, {label: l = Math.round} = t, {icon: c} = t, {labelClass: d} = t, {innerClass: u} = t, {hideLabel: h = !1} = t, {locale: p} = t, {value: m} = t, {onchange: g = i} = t, {labelPrefix: $} = t;
    const {min: f, max: y, getValue: b = Z} = r;
    let x;
    const v = e => o(9, x = (e => M(l) ? l(b(e), f, y, e) : l)(e));
    return e.$$set = e => {
        t = ir(ir({}, t), br(e)), o(12, r = xr(t, n)), "class" in e && o(0, a = e.class), "title" in e && o(1, s = e.title), "label" in e && o(13, l = e.label), "icon" in e && o(2, c = e.icon), "labelClass" in e && o(3, d = e.labelClass), "innerClass" in e && o(4, u = e.innerClass), "hideLabel" in e && o(5, h = e.hideLabel), "locale" in e && o(6, p = e.locale), "value" in e && o(7, m = e.value), "onchange" in e && o(14, g = e.onchange), "labelPrefix" in e && o(8, $ = e.labelPrefix)
    }, e.$$.update = () => {
        8320 & e.$$.dirty && v(m)
    }, [a, s, c, d, u, h, p, m, $, x, e => {
        /tab/i.test(e.key) && e.preventDefault()
    }, e => {
        v(e), g(e)
    }, r, l, g]
}

class Sh extends Ga {
    constructor(e) {
        super(), Ua(this, e, wh, vh, lr, {
            class: 0,
            title: 1,
            label: 13,
            icon: 2,
            labelClass: 3,
            innerClass: 4,
            hideLabel: 5,
            locale: 6,
            value: 7,
            onchange: 14,
            labelPrefix: 8
        })
    }
}

function kh(e) {
    let t, o, i, n, r, a, s, l;
    return {
        c() {
            t = Fr("span"), o = zr("svg"), i = zr("g"), n = zr("circle"), r = zr("circle"), a = Br(), s = Fr("span"), l = Dr(e[3]), Nr(n, "class", "PinturaProgressIndicatorBar"), Nr(n, "r", "8.5"), Nr(n, "cx", "10"), Nr(n, "cy", "10"), Nr(n, "stroke-linecap", "round"), Nr(n, "opacity", ".25"), Nr(r, "class", "PinturaProgressIndicatorFill"), Nr(r, "r", "8.5"), Nr(r, "stroke-dasharray", e[2]), Nr(r, "cx", "10"), Nr(r, "cy", "10"), Nr(r, "transform", "rotate(-90) translate(-20)"), Nr(i, "fill", "none"), Nr(i, "stroke", "currentColor"), Nr(i, "stroke-width", "2.5"), Nr(i, "stroke-linecap", "round"), Nr(i, "opacity", e[1]), Nr(o, "width", "20"), Nr(o, "height", "20"), Nr(o, "viewBox", "0 0 20 20"), Nr(o, "xmlns", "http://www.w3.org/2000/svg"), Nr(o, "aria-hidden", "true"), Nr(o, "focusable", "false"), Nr(s, "class", "implicit"), Nr(t, "class", "PinturaProgressIndicator"), Nr(t, "data-status", e[0]), Zr(t, "opacity", e[4])
        }, m(e, c) {
            Ar(e, t, c), Rr(t, o), Rr(o, i), Rr(i, n), Rr(i, r), Rr(t, a), Rr(t, s), Rr(s, l)
        }, p(e, [o]) {
            4 & o && Nr(r, "stroke-dasharray", e[2]), 2 & o && Nr(i, "opacity", e[1]), 8 & o && Ur(l, e[3]), 1 & o && Nr(t, "data-status", e[0]), 16 & o && Zr(t, "opacity", e[4])
        }, i: tr, o: tr, d(e) {
            e && Lr(t)
        }
    }
}

function Ch(e, t, o) {
    let i, n, r, a, s, l, c, d;
    const u = sa();
    let {progress: h} = t, {min: p = 0} = t, {max: m = 100} = t, {labelBusy: g = "Busy"} = t, {opacity: $} = t;
    const f = ca("isAnimated");
    pr(e, f, (e => o(14, s = e)));
    const y = bc($, {precision: .01});
    pr(e, y, (e => o(4, d = e)));
    const b = bc(0, {precision: .01}), x = bc(0, {precision: .01});
    pr(e, x, (e => o(15, l = e)));
    const v = qa([b], (e => gs(e, p, m)));
    pr(e, v, (e => o(16, c = e)));
    const w = v.subscribe((e => {
        1 === h && Math.round(e) >= 100 && u("complete")
    }));
    return na((() => {
        x.set(1, {hard: !s})
    })), aa((() => {
        w()
    })), e.$$set = e => {
        "progress" in e && o(9, h = e.progress), "min" in e && o(10, p = e.min), "max" in e && o(11, m = e.max), "labelBusy" in e && o(12, g = e.labelBusy), "opacity" in e && o(13, $ = e.opacity)
    }, e.$$.update = () => {
        24576 & e.$$.dirty && zo($) && y.set($, {hard: !s}), 16896 & e.$$.dirty && h && h !== 1 / 0 && b.set(100 * h, {hard: !s}), 70144 & e.$$.dirty && o(3, i = h === 1 / 0 ? g : Math.round(c) + "%"), 66048 & e.$$.dirty && o(2, n = h === 1 / 0 ? "26.5 53" : c / 100 * 53 + " 53"), 32768 & e.$$.dirty && o(1, r = l), 512 & e.$$.dirty && o(0, a = h === 1 / 0 ? "busy" : "loading")
    }, [a, r, n, i, d, f, y, x, v, h, p, m, g, $, s, l, c]
}

class Th extends Ga {
    constructor(e) {
        super(), Ua(this, e, Ch, kh, lr, {progress: 9, min: 10, max: 11, labelBusy: 12, opacity: 13})
    }
}

function Mh(e) {
    let t, o, i = iu(e[0], e[1]) + "";
    return {
        c() {
            t = Fr("span"), o = Dr(i), Nr(t, "class", e[3])
        }, m(e, i) {
            Ar(e, t, i), Rr(t, o)
        }, p(e, n) {
            3 & n && i !== (i = iu(e[0], e[1]) + "") && Ur(o, i), 8 & n && Nr(t, "class", e[3])
        }, d(e) {
            e && Lr(t)
        }
    }
}

function Ph(e) {
    let t, o, i, n, r = e[0] && Mh(e);
    return i = new pp({props: {items: e[2]}}), {
        c() {
            t = Fr("li"), r && r.c(), o = Br(), Na(i.$$.fragment), Nr(t, "class", "PinturaShapeStyle")
        }, m(e, a) {
            Ar(e, t, a), r && r.m(t, null), Rr(t, o), Ha(i, t, null), n = !0
        }, p(e, [n]) {
            e[0] ? r ? r.p(e, n) : (r = Mh(e), r.c(), r.m(t, o)) : r && (r.d(1), r = null);
            const a = {};
            4 & n && (a.items = e[2]), i.$set(a)
        }, i(e) {
            n || (Ea(i.$$.fragment, e), n = !0)
        }, o(e) {
            Aa(i.$$.fragment, e), n = !1
        }, d(e) {
            e && Lr(t), r && r.d(), ja(i)
        }
    }
}

function Rh(e, t, o) {
    let i, {title: n} = t, {locale: r} = t, {items: a} = t, {hideTitle: s = !1} = t;
    return e.$$set = e => {
        "title" in e && o(0, n = e.title), "locale" in e && o(1, r = e.locale), "items" in e && o(2, a = e.items), "hideTitle" in e && o(4, s = e.hideTitle)
    }, e.$$.update = () => {
        16 & e.$$.dirty && o(3, i = "PinturaShapeStyleLabel" + (s ? " implicit" : ""))
    }, [n, r, a, i, s]
}

class Ih extends Ga {
    constructor(e) {
        super(), Ua(this, e, Rh, Ph, lr, {title: 0, locale: 1, items: 2, hideTitle: 4})
    }
}

var Eh = (e, t, o) => {
    let i, n, r;
    const a = Math.floor(6 * e), s = 6 * e - a, l = o * (1 - t), c = o * (1 - s * t), d = o * (1 - (1 - s) * t);
    switch (a % 6) {
        case 0:
            i = o, n = d, r = l;
            break;
        case 1:
            i = c, n = o, r = l;
            break;
        case 2:
            i = l, n = o, r = d;
            break;
        case 3:
            i = l, n = c, r = o;
            break;
        case 4:
            i = d, n = l, r = o;
            break;
        case 5:
            i = o, n = l, r = c
    }
    return [i, n, r]
};

function Ah(e) {
    let t, o;
    return {
        c() {
            t = Fr("div"), o = Fr("span"), Nr(t, "class", "PinturaColorPreview"), Nr(t, "title", e[0]), Zr(t, "--color", e[1])
        }, m(e, i) {
            Ar(e, t, i), Rr(t, o)
        }, p(e, [o]) {
            1 & o && Nr(t, "title", e[0]), 2 & o && Zr(t, "--color", e[1])
        }, i: tr, o: tr, d(e) {
            e && Lr(t)
        }
    }
}

function Lh(e, t, o) {
    let i, {color: n} = t, {title: r} = t;
    return e.$$set = e => {
        "color" in e && o(2, n = e.color), "title" in e && o(0, r = e.title)
    }, e.$$.update = () => {
        4 & e.$$.dirty && o(1, i = n ? Go(n) : "transparent")
    }, [r, i, n]
}

class Fh extends Ga {
    constructor(e) {
        super(), Ua(this, e, Lh, Ah, lr, {color: 2, title: 0})
    }
}

var zh = e => (e = e.trim(), /^rgba/.test(e) ? e.substring(5).split(",").map(parseFloat).map(((e, t) => e / (3 === t ? 1 : 255))) : /^rgb/.test(e) ? e.substring(4).split(",").map(parseFloat).map((e => e / 255)) : /^#/.test(e) ? (e => {
    const [, t, o, i, n] = e.split("");
    e = e.length >= 4 && e.length <= 5 ? `#${t}${t}${o}${o}${i}${i}${n ? `${n}${n}` : ""}` : e;
    const [r, a, s, l, c] = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})?$/i.exec(e) || [];
    if (r) return [a, s, l, c].filter((e => void 0 !== e)).map((e => parseInt(e, 16) / 255))
})(e) : /[0-9]{1,3}\s?,\s?[0-9]{1,3}\s?,\s?[0-9]{1,3}/.test(e) ? e.split(",").map((e => parseInt(e, 10))).map((e => e / 255)) : void 0);
let Dh = null;

function Bh(e) {
    let t, o;
    return {
        c() {
            t = Fr("span"), o = Dr(e[0])
        }, m(e, i) {
            Ar(e, t, i), Rr(t, o)
        }, p(e, t) {
            1 & t[0] && Ur(o, e[0])
        }, d(e) {
            e && Lr(t)
        }
    }
}

function Oh(e) {
    let t, o, i, n;
    o = new Fh({props: {color: e[4], title: iu(e[8], e[10])}});
    let r = !e[9] && Bh(e);
    return {
        c() {
            t = Fr("span"), Na(o.$$.fragment), i = Br(), r && r.c(), Nr(t, "slot", "label"), Nr(t, "class", "PinturaButtonLabel")
        }, m(e, a) {
            Ar(e, t, a), Ha(o, t, null), Rr(t, i), r && r.m(t, null), n = !0
        }, p(e, i) {
            const n = {};
            16 & i[0] && (n.color = e[4]), 1280 & i[0] && (n.title = iu(e[8], e[10])), o.$set(n), e[9] ? r && (r.d(1), r = null) : r ? r.p(e, i) : (r = Bh(e), r.c(), r.m(t, null))
        }, i(e) {
            n || (Ea(o.$$.fragment, e), n = !0)
        }, o(e) {
            Aa(o.$$.fragment, e), n = !1
        }, d(e) {
            e && Lr(t), ja(o), r && r.d()
        }
    }
}

function Wh(e) {
    let t, o, i, n, r, a, s, l, c, d, u, h;
    s = new gh({
        props: {
            label: "Hue",
            hideLabel: !0,
            class: "PinturaHuePicker",
            onchange: e[27],
            value: e[16],
            min: 0,
            max: 1,
            step: .01
        }
    });
    let p = e[11] && Vh(e), m = (e[14] || e[15]) && _h(e);
    return {
        c() {
            t = Fr("div"), o = Fr("div"), i = Fr("div"), n = Fr("div"), r = Br(), a = Fr("div"), Na(s.$$.fragment), l = Br(), p && p.c(), c = Br(), m && m.c(), Nr(n, "role", "button"), Nr(n, "aria-label", "Saturation slider"), Nr(n, "class", "PinturaPickerKnob"), Nr(n, "tabindex", "0"), Zr(n, "background-color", e[20]), Nr(i, "class", "PinturaPickerKnobController"), Zr(i, "transform", `translate(${e[25]}%,${e[24]}%)`), Nr(o, "class", "PinturaSaturationPicker"), Zr(o, "background-color", e[21]), Zr(a, "--knob-background", e[21]), Nr(t, "class", "PinturaPicker")
        }, m(g, $) {
            Ar(g, t, $), Rr(t, o), Rr(o, i), Rr(i, n), e[41](o), Rr(t, r), Rr(t, a), Ha(s, a, null), Rr(t, l), p && p.m(t, null), Rr(t, c), m && m.m(t, null), d = !0, u || (h = [Wr(n, "nudge", e[30]), wr(rh.call(null, n, {preventDefault: !0})), Wr(o, "pointerdown", e[29])], u = !0)
        }, p(e, r) {
            1048576 & r[0] && Zr(n, "background-color", e[20]), 50331648 & r[0] && Zr(i, "transform", `translate(${e[25]}%,${e[24]}%)`), 2097152 & r[0] && Zr(o, "background-color", e[21]);
            const l = {};
            65536 & r[0] && (l.value = e[16]), s.$set(l), 2097152 & r[0] && Zr(a, "--knob-background", e[21]), e[11] ? p ? (p.p(e, r), 2048 & r[0] && Ea(p, 1)) : (p = Vh(e), p.c(), Ea(p, 1), p.m(t, c)) : p && (Ra(), Aa(p, 1, 1, (() => {
                p = null
            })), Ia()), e[14] || e[15] ? m ? (m.p(e, r), 49152 & r[0] && Ea(m, 1)) : (m = _h(e), m.c(), Ea(m, 1), m.m(t, null)) : m && (Ra(), Aa(m, 1, 1, (() => {
                m = null
            })), Ia())
        }, i(e) {
            d || (Ea(s.$$.fragment, e), Ea(p), Ea(m), d = !0)
        }, o(e) {
            Aa(s.$$.fragment, e), Aa(p), Aa(m), d = !1
        }, d(o) {
            o && Lr(t), e[41](null), ja(s), p && p.d(), m && m.d(), u = !1, ar(h)
        }
    }
}

function Vh(e) {
    let t, o, i;
    return o = new gh({
        props: {
            label: "Opacity",
            hideLabel: !0,
            class: "PinturaOpacityPicker",
            onchange: e[28],
            value: e[17],
            min: 0,
            max: 1,
            step: .01
        }
    }), {
        c() {
            t = Fr("div"), Na(o.$$.fragment), Zr(t, "--knob-background", e[18]), Zr(t, "--track-background", `linear-gradient(to right,${e[19]},${e[20]})`)
        }, m(e, n) {
            Ar(e, t, n), Ha(o, t, null), i = !0
        }, p(e, i) {
            const n = {};
            131072 & i[0] && (n.value = e[17]), o.$set(n), 262144 & i[0] && Zr(t, "--knob-background", e[18]), 1572864 & i[0] && Zr(t, "--track-background", `linear-gradient(to right,${e[19]},${e[20]})`)
        }, i(e) {
            i || (Ea(o.$$.fragment, e), i = !0)
        }, o(e) {
            Aa(o.$$.fragment, e), i = !1
        }, d(e) {
            e && Lr(t), ja(o)
        }
    }
}

function _h(e) {
    let t, o, i, n, r, a, s, l = e[15] && Nh(e);
    return {
        c() {
            t = Fr("div"), o = Fr("input"), n = Br(), l && l.c(), Nr(o, "class", "PinturaColorPickerInput"), Nr(o, "type", "text"), o.disabled = i = !e[14], o.value = e[23], Nr(t, "class", "PinturColorPickerInputGroup")
        }, m(i, c) {
            Ar(i, t, c), Rr(t, o), Rr(t, n), l && l.m(t, null), r = !0, a || (s = [Wr(o, "keydown", e[32]), Wr(o, "input", e[31])], a = !0)
        }, p(e, n) {
            (!r || 16384 & n[0] && i !== (i = !e[14])) && (o.disabled = i), (!r || 8388608 & n[0] && o.value !== e[23]) && (o.value = e[23]), e[15] ? l ? (l.p(e, n), 32768 & n[0] && Ea(l, 1)) : (l = Nh(e), l.c(), Ea(l, 1), l.m(t, null)) : l && (Ra(), Aa(l, 1, 1, (() => {
                l = null
            })), Ia())
        }, i(e) {
            r || (Ea(l), r = !0)
        }, o(e) {
            Aa(l), r = !1
        }, d(e) {
            e && Lr(t), l && l.d(), a = !1, ar(s)
        }
    }
}

function Nh(e) {
    let t, o;
    return t = new xp({
        props: {
            icon: '<path stroke="currentColor" stroke-linecap="square" d="m13 14-7 7a2.704 2.704 0 0 1-3 0 2.704 2.704 0 0 1 0-3l7-7"/><path fill="currentColor" d="M9.475 9.475 14.5 14.5c.263.263.69.265.955.005l.783-.767a4.209 4.209 0 0 0 1.262-3.006V10l4-4c.5-.5.375-2.125-.5-3s-2.5-1-3-.5l-4 4h-.732a4.329 4.329 0 0 0-3.03 1.238l-.758.742a.7.7 0 0 0-.005.995Z"/>',
            hideLabel: !0,
            label: "Pick a color",
            class: "PinturaEyeDropper",
            onclick: e[33]
        }
    }), {
        c() {
            Na(t.$$.fragment)
        }, m(e, i) {
            Ha(t, e, i), o = !0
        }, p: tr, i(e) {
            o || (Ea(t.$$.fragment, e), o = !0)
        }, o(e) {
            Aa(t.$$.fragment, e), o = !1
        }, d(e) {
            ja(t, e)
        }
    }
}

function Hh(e) {
    let t, o;
    return t = new Eu({
        props: {
            label: iu(e[10].labelColorPalette, e[10]),
            class: Zc(["PinturaColorPresets", e[9] ? "PinturaColorPresetsGrid" : "PinturaColorPresetsList"]),
            hideLabel: !1,
            name: e[1],
            value: e[4],
            optionGroupClass: "PinturaListOptionGroup",
            optionClass: "PinturaListOption",
            options: e[2].map(e[42]),
            selectedIndex: e[3],
            optionMapper: e[7],
            optionLabelClass: e[6],
            onchange: e[43],
            $$slots: {
                option: [Gh, ({option: e}) => ({59: e}), ({option: e}) => [0, e ? 268435456 : 0]],
                group: [jh, ({option: e}) => ({59: e}), ({option: e}) => [0, e ? 268435456 : 0]]
            },
            $$scope: {ctx: e}
        }
    }), {
        c() {
            Na(t.$$.fragment)
        }, m(e, i) {
            Ha(t, e, i), o = !0
        }, p(e, o) {
            const i = {};
            1024 & o[0] && (i.label = iu(e[10].labelColorPalette, e[10])), 512 & o[0] && (i.class = Zc(["PinturaColorPresets", e[9] ? "PinturaColorPresetsGrid" : "PinturaColorPresetsList"])), 2 & o[0] && (i.name = e[1]), 16 & o[0] && (i.value = e[4]), 1028 & o[0] && (i.options = e[2].map(e[42])), 8 & o[0] && (i.selectedIndex = e[3]), 128 & o[0] && (i.optionMapper = e[7]), 64 & o[0] && (i.optionLabelClass = e[6]), 512 & o[0] | 805306368 & o[1] && (i.$$scope = {
                dirty: o,
                ctx: e
            }), t.$set(i)
        }, i(e) {
            o || (Ea(t.$$.fragment, e), o = !0)
        }, o(e) {
            Aa(t.$$.fragment, e), o = !1
        }, d(e) {
            ja(t, e)
        }
    }
}

function jh(e) {
    let t, o, i = e[59].label + "";
    return {
        c() {
            t = Fr("span"), o = Dr(i), Nr(t, "slot", "group")
        }, m(e, i) {
            Ar(e, t, i), Rr(t, o)
        }, p(e, t) {
            268435456 & t[1] && i !== (i = e[59].label + "") && Ur(o, i)
        }, d(e) {
            e && Lr(t)
        }
    }
}

function Uh(e) {
    let t, o, i = e[59].label + "";
    return {
        c() {
            t = Fr("span"), o = Dr(i), Nr(t, "class", "PinturaButtonLabel")
        }, m(e, i) {
            Ar(e, t, i), Rr(t, o)
        }, p(e, t) {
            268435456 & t[1] && i !== (i = e[59].label + "") && Ur(o, i)
        }, d(e) {
            e && Lr(t)
        }
    }
}

function Gh(e) {
    let t, o, i, n;
    o = new Fh({props: {title: e[59].label, color: e[59].value}});
    let r = !e[9] && Uh(e);
    return {
        c() {
            t = Fr("span"), Na(o.$$.fragment), i = Br(), r && r.c(), Nr(t, "slot", "option")
        }, m(e, a) {
            Ar(e, t, a), Ha(o, t, null), Rr(t, i), r && r.m(t, null), n = !0
        }, p(e, i) {
            const n = {};
            268435456 & i[1] && (n.title = e[59].label), 268435456 & i[1] && (n.color = e[59].value), o.$set(n), e[9] ? r && (r.d(1), r = null) : r ? r.p(e, i) : (r = Uh(e), r.c(), r.m(t, null))
        }, i(e) {
            n || (Ea(o.$$.fragment, e), n = !0)
        }, o(e) {
            Aa(o.$$.fragment, e), n = !1
        }, d(e) {
            e && Lr(t), ja(o), r && r.d()
        }
    }
}

function Zh(e) {
    let t, o, i, n = e[13] && Wh(e), r = e[12] && Hh(e);
    return {
        c() {
            t = Fr("div"), n && n.c(), o = Br(), r && r.c(), Nr(t, "slot", "details"), Nr(t, "class", "PinturaColorPickerPanel")
        }, m(e, a) {
            Ar(e, t, a), n && n.m(t, null), Rr(t, o), r && r.m(t, null), i = !0
        }, p(e, i) {
            e[13] ? n ? (n.p(e, i), 8192 & i[0] && Ea(n, 1)) : (n = Wh(e), n.c(), Ea(n, 1), n.m(t, o)) : n && (Ra(), Aa(n, 1, 1, (() => {
                n = null
            })), Ia()), e[12] ? r ? (r.p(e, i), 4096 & i[0] && Ea(r, 1)) : (r = Hh(e), r.c(), Ea(r, 1), r.m(t, null)) : r && (Ra(), Aa(r, 1, 1, (() => {
                r = null
            })), Ia())
        }, i(e) {
            i || (Ea(n), Ea(r), i = !0)
        }, o(e) {
            Aa(n), Aa(r), i = !1
        }, d(e) {
            e && Lr(t), n && n.d(), r && r.d()
        }
    }
}

function Xh(e) {
    let t, o;
    return t = new qd({
        props: {
            buttonClass: Zc(["PinturaColorPickerButton", e[5]]),
            $$slots: {details: [Zh], label: [Oh]},
            $$scope: {ctx: e}
        }
    }), {
        c() {
            Na(t.$$.fragment)
        }, m(e, i) {
            Ha(t, e, i), o = !0
        }, p(e, o) {
            const i = {};
            32 & o[0] && (i.buttonClass = Zc(["PinturaColorPickerButton", e[5]])), 67108831 & o[0] | 536870912 & o[1] && (i.$$scope = {
                dirty: o,
                ctx: e
            }), t.$set(i)
        }, i(e) {
            o || (Ea(t.$$.fragment, e), o = !0)
        }, o(e) {
            Aa(t.$$.fragment, e), o = !1
        }, d(e) {
            ja(t, e)
        }
    }
}

function Yh(e, t, o) {
    let i, n, r, a, s, c, d, u, h, p, m, g,
        $, {label: f} = t, {name: y} = t, {options: b = []} = t, {selectedIndex: x = -1} = t, {value: v} = t, {buttonClass: w} = t, {optionLabelClass: S} = t, {optionMapper: k} = t, {onchange: C} = t, {title: T} = t, {hidePresetLabel: P = !0} = t, {locale: R} = t, {enableOpacity: I = !0} = t, {enablePresets: E = !0} = t, {enablePicker: A = !0} = t, {enableInput: L = !1} = t, {enableEyeDropper: F = !1} = t,
        z = "transparent", D = "transparent";
    const B = (e, t) => {
        if (p = [e[0], e[1], e[2]], t) {
            let t = ((e, t, o) => {
                let i = Math.max(e, t, o), n = i - Math.min(e, t, o),
                    r = n && (i == e ? (t - o) / n : i == t ? 2 + (o - e) / n : 4 + (e - t) / n);
                return [60 * (r < 0 ? r + 6 : r) / 360, i && n / i, i]
            })(...p), i = t[0], n = t[1], r = t[2];
            zo(H) && (i = H), zo(_) && (n = _), zo(N) && (r = N), o(16, c = i), o(36, d = n), o(37, u = r), o(17, h = zo(e[3]) ? e[3] : 1)
        }
        o(18, m = Go(e)), o(19, g = Go([...p, 0])), o(20, z = Go([...p, 1])), o(21, D = Go(Eh(c, 1, 1)))
    }, O = () => {
        const e = [...Eh(c, d, u), h];
        B(e), C(e)
    }, W = e => {
        const t = 3 === e.length ? [...e, 1] : e;
        V(), B(t, !0), C(t)
    }, V = () => {
        _ = void 0, N = void 0, H = void 0
    };
    let _, N, H;
    const j = (e, t) => {
        const i = gs(e.x / t.width, 0, 1), n = gs(e.y / t.height, 0, 1);
        var r, a;
        a = 1 - n, o(36, d = r = i), o(37, u = a), _ = r, N = a, O()
    };
    let U, G, Z, X;
    const Y = e => {
        const t = Se(pe(e), X);
        j(we(me(Z), t), G)
    }, q = e => {
        G = void 0, document.documentElement.removeEventListener("pointermove", Y), document.documentElement.removeEventListener("pointerup", q)
    };
    let K;
    return e.$$set = e => {
        "label" in e && o(0, f = e.label), "name" in e && o(1, y = e.name), "options" in e && o(2, b = e.options), "selectedIndex" in e && o(3, x = e.selectedIndex), "value" in e && o(4, v = e.value), "buttonClass" in e && o(5, w = e.buttonClass), "optionLabelClass" in e && o(6, S = e.optionLabelClass), "optionMapper" in e && o(7, k = e.optionMapper), "onchange" in e && o(34, C = e.onchange), "title" in e && o(8, T = e.title), "hidePresetLabel" in e && o(9, P = e.hidePresetLabel), "locale" in e && o(10, R = e.locale), "enableOpacity" in e && o(11, I = e.enableOpacity), "enablePresets" in e && o(12, E = e.enablePresets), "enablePicker" in e && o(13, A = e.enablePicker), "enableInput" in e && o(14, L = e.enableInput), "enableEyeDropper" in e && o(35, F = e.enableEyeDropper)
    }, e.$$.update = () => {
        16 & e.$$.dirty[1] && o(15, i = F && (null === Dh && (Dh = l() && "EyeDropper" in window), Dh)), 16 & e.$$.dirty[0] | 128 & e.$$.dirty[1] && (!v || $ && xs(v, $) || (o(38, $ = [...v]), B(v, !0))), 32 & e.$$.dirty[1] && o(25, n = 100 * d), 64 & e.$$.dirty[1] && o(24, r = 100 - 100 * u), 256 & e.$$.dirty[1] && o(40, a = !!K && (K.length >= 4 && K.length <= 5)), 51216 & e.$$.dirty[0] | 512 & e.$$.dirty[1] && o(23, s = (L || i) && v ? ((e, t, o) => {
            let i = e.map((e => Math.round(255 * e).toString(16).toLowerCase().padStart(2, "0")));
            return (!t && i.length > 3 || "ff" === i[3]) && i.pop(), o && (i = i.map((e => e.substring(0, 1)))), "#" + i.join("")
        })(v, I, a) : void 0)
    }, [f, y, b, x, v, w, S, k, T, P, R, I, E, A, L, i, c, h, m, g, z, D, U, s, r, n, W, e => {
        o(16, c = e), H = e, O()
    }, e => {
        o(17, h = e), O()
    }, e => {
        e.stopPropagation(), G = Ve(U.offsetWidth, U.offsetHeight), Z = (e => he(e.offsetX, e.offsetY))(e), X = pe(e), j(Z, G), document.documentElement.addEventListener("pointermove", Y), document.documentElement.addEventListener("pointerup", q)
    }, e => {
        G = Ve(U.offsetWidth, U.offsetHeight);
        const t = n / 100 * G.width, o = r / 100 * G.height;
        j({x: t + e.detail.x, y: o + e.detail.y}, G)
    }, e => {
        const {value: t} = e.target, i = t.length;
        if (!t.startsWith("#") || i < 4 || 6 === i || 8 === i || i > 9) return;
        if (!I && i > 7) return;
        const n = zh(t);
        n && (o(39, K = t), V(), B(n), C(n))
    }, e => {
        e.stopPropagation()
    }, e => {
        (new EyeDropper).open().then((({sRGBHex: e}) => {
            const t = zh(e);
            t && (t[3] = 1, o(39, K = v), V(), B(t), C(t))
        })).catch((e => {
        }))
    }, C, F, d, u, $, K, a, function (e) {
        ha[e ? "unshift" : "push"]((() => {
            U = e, o(22, U)
        }))
    }, ([e, t]) => [e, M(t) ? t(R) : t], e => W(e.value)]
}

class qh extends Ga {
    constructor(e) {
        super(), Ua(this, e, Yh, Xh, lr, {
            label: 0,
            name: 1,
            options: 2,
            selectedIndex: 3,
            value: 4,
            buttonClass: 5,
            optionLabelClass: 6,
            optionMapper: 7,
            onchange: 34,
            title: 8,
            hidePresetLabel: 9,
            locale: 10,
            enableOpacity: 11,
            enablePresets: 12,
            enablePicker: 13,
            enableInput: 14,
            enableEyeDropper: 35
        }, null, [-1, -1])
    }
}

function Kh(e) {
    let t, o, i;
    return o = new pp({props: {items: e[0]}}), {
        c() {
            t = Fr("div"), Na(o.$$.fragment), Nr(t, "class", "PinturaShorthandControl PinturaShapeStyle")
        }, m(e, n) {
            Ar(e, t, n), Ha(o, t, null), i = !0
        }, p(e, [t]) {
            const i = {};
            1 & t && (i.items = e[0]), o.$set(i)
        }, i(e) {
            i || (Ea(o.$$.fragment, e), i = !0)
        }, o(e) {
            Aa(o.$$.fragment, e), i = !1
        }, d(e) {
            e && Lr(t), ja(o)
        }
    }
}

function Jh(e, t, o) {
    let i, n, {value: r} = t, {onchange: a} = t, {controls: s = []} = t;
    return e.$$set = e => {
        o(6, t = ir(ir({}, t), br(e))), "value" in e && o(1, r = e.value), "onchange" in e && o(2, a = e.onchange), "controls" in e && o(3, s = e.controls)
    }, e.$$.update = () => {
        o(4, i = (e => {
            const {controls: t, ...o} = e;
            return o
        })(t)), 30 & e.$$.dirty && o(0, n = s.map(((e, t) => {
            const [o, n, s] = e;
            return [o, n, {
                ...i, ...s, value: r[t], onchange: e => {
                    const o = [...r];
                    o[t] = e, a(o)
                }
            }]
        })))
    }, t = br(t), [n, r, a, s, i]
}

class Qh extends Ga {
    constructor(e) {
        super(), Ua(this, e, Jh, Kh, lr, {value: 1, onchange: 2, controls: 3})
    }
}

function ep(e) {
    let t, o;
    return t = new eh({props: {label: e[4], options: e[1], title: e[2], selectedIndex: e[5], onchange: e[10]}}), {
        c() {
            Na(t.$$.fragment)
        }, m(e, i) {
            Ha(t, e, i), o = !0
        }, p(e, [o]) {
            const i = {};
            16 & o && (i.label = e[4]), 2 & o && (i.options = e[1]), 4 & o && (i.title = e[2]), 32 & o && (i.selectedIndex = e[5]), 9 & o && (i.onchange = e[10]), t.$set(i)
        }, i(e) {
            o || (Ea(t.$$.fragment, e), o = !0)
        }, o(e) {
            Aa(t.$$.fragment, e), o = !1
        }, d(e) {
            ja(t, e)
        }
    }
}

function tp(e, t, o) {
    let i, n, r,
        a, {options: s} = t, {title: l} = t, {onchange: c} = t, {selectedIndex: d = -1} = t, {value: u} = t, {label: h} = t;
    return e.$$set = e => {
        "options" in e && o(1, s = e.options), "title" in e && o(2, l = e.title), "onchange" in e && o(3, c = e.onchange), "selectedIndex" in e && o(0, d = e.selectedIndex), "value" in e && o(6, u = e.value), "label" in e && o(7, h = e.label)
    }, e.$$.update = () => {
        67 & e.$$.dirty && o(9, i = ((e, t, o) => {
            if (e) return t > -1 ? e[t] : void 0 !== o ? e.find((e => e[0] === o)) : e[0]
        })(s, d, u)), 514 & e.$$.dirty && o(5, n = s && s.findIndex((e => e === i))), 512 & e.$$.dirty && o(8, r = i && i[1]), 384 & e.$$.dirty && o(4, a = h || r)
    }, [d, s, l, c, a, n, u, h, r, i, e => {
        o(0, d = e.index), c && c(e)
    }]
}

class op extends Ga {
    constructor(e) {
        super(), Ua(this, e, tp, ep, lr, {options: 1, title: 2, onchange: 3, selectedIndex: 0, value: 6, label: 7})
    }
}

function ip(e, t, o) {
    const i = e.slice();
    return i[9] = t[o][0], i[0] = t[o][1], i[10] = t[o][2], i[2] = t[o][3], i
}

function np(e) {
    let t, o, i;
    const n = [e[10]];
    var r = e[3][e[9]] || e[9];

    function a(e) {
        let t = {};
        for (let e = 0; e < n.length; e += 1) t = ir(t, n[e]);
        return {props: t}
    }

    return r && (t = qr(r, a())), {
        c() {
            t && Na(t.$$.fragment), o = Or()
        }, m(e, n) {
            t && Ha(t, e, n), Ar(e, o, n), i = !0
        }, p(e, i) {
            const s = 4 & i ? Wa(n, [Va(e[10])]) : {};
            if (r !== (r = e[3][e[9]] || e[9])) {
                if (t) {
                    Ra();
                    const e = t;
                    Aa(e.$$.fragment, 1, 0, (() => {
                        ja(e, 1)
                    })), Ia()
                }
                r ? (t = qr(r, a()), Na(t.$$.fragment), Ea(t.$$.fragment, 1), Ha(t, o.parentNode, o)) : t = null
            } else r && t.$set(s)
        }, i(e) {
            i || (t && Ea(t.$$.fragment, e), i = !0)
        }, o(e) {
            t && Aa(t.$$.fragment, e), i = !1
        }, d(e) {
            e && Lr(o), t && ja(t, e)
        }
    }
}

function rp(e) {
    let t, o = e[9], i = e[9] && cp(e);
    return {
        c() {
            i && i.c(), t = Or()
        }, m(e, o) {
            i && i.m(e, o), Ar(e, t, o)
        }, p(e, n) {
            e[9] ? o ? lr(o, e[9]) ? (i.d(1), i = cp(e), i.c(), i.m(t.parentNode, t)) : i.p(e, n) : (i = cp(e), i.c(), i.m(t.parentNode, t)) : o && (i.d(1), i = null), o = e[9]
        }, i: tr, o(e) {
            Aa(i)
        }, d(e) {
            e && Lr(t), i && i.d(e)
        }
    }
}

function ap(e) {
    let t, o, i = e[10].innerHTML + "";
    return {
        c() {
            t = new Yr(!1), o = Or(), t.a = o
        }, m(e, n) {
            t.m(i, e, n), Ar(e, o, n)
        }, p(e, o) {
            4 & o && i !== (i = e[10].innerHTML + "") && t.p(i)
        }, i: tr, o: tr, d(e) {
            e && Lr(o), e && t.d()
        }
    }
}

function sp(e) {
    let t, o = e[10].textContent + "";
    return {
        c() {
            t = Dr(o)
        }, m(e, o) {
            Ar(e, t, o)
        }, p(e, i) {
            4 & i && o !== (o = e[10].textContent + "") && Ur(t, o)
        }, i: tr, o: tr, d(e) {
            e && Lr(t)
        }
    }
}

function lp(e) {
    let t, o;
    return t = new pp({props: {items: e[2], discardEmptyItems: !0}}), {
        c() {
            Na(t.$$.fragment)
        }, m(e, i) {
            Ha(t, e, i), o = !0
        }, p(e, o) {
            const i = {};
            4 & o && (i.items = e[2]), t.$set(i)
        }, i(e) {
            o || (Ea(t.$$.fragment, e), o = !0)
        }, o(e) {
            Aa(t.$$.fragment, e), o = !1
        }, d(e) {
            ja(t, e)
        }
    }
}

function cp(e) {
    let t, o, i, n, r;
    const a = [lp, sp, ap], s = [];

    function l(e, t) {
        return e[2] && e[2].length ? 0 : e[10].textContent ? 1 : e[10].innerHTML ? 2 : -1
    }

    ~(o = l(e)) && (i = s[o] = a[o](e));
    let c = [e[4](e[10])], d = {};
    for (let e = 0; e < c.length; e += 1) d = ir(d, c[e]);
    return {
        c() {
            t = Fr(e[9]), i && i.c(), n = Br(), /-/.test(e[9]) ? jr(t, d) : Hr(t, d)
        }, m(e, i) {
            Ar(e, t, i), ~o && s[o].m(t, null), Rr(t, n), r = !0
        }, p(e, r) {
            let u = o;
            o = l(e), o === u ? ~o && s[o].p(e, r) : (i && (Ra(), Aa(s[u], 1, 1, (() => {
                s[u] = null
            })), Ia()), ~o ? (i = s[o], i ? i.p(e, r) : (i = s[o] = a[o](e), i.c()), Ea(i, 1), i.m(t, n)) : i = null), d = Wa(c, [4 & r && e[4](e[10])]), /-/.test(e[9]) ? jr(t, d) : Hr(t, d)
        }, i(e) {
            r || (Ea(i), r = !0)
        }, o(e) {
            Aa(i), r = !1
        }, d(e) {
            e && Lr(t), ~o && s[o].d()
        }
    }
}

function dp(e, t) {
    let o, i, n, r, a, s;
    const l = [rp, np], c = [];

    function d(e, t) {
        return 4 & t && (i = null), null == i && (i = !e[5](e[9])), i ? 0 : 1
    }

    return n = d(t, -1), r = c[n] = l[n](t), {
        key: e, first: null, c() {
            o = Or(), r.c(), a = Or(), this.first = o
        }, m(e, t) {
            Ar(e, o, t), c[n].m(e, t), Ar(e, a, t), s = !0
        }, p(e, o) {
            let i = n;
            n = d(t = e, o), n === i ? c[n].p(t, o) : (Ra(), Aa(c[i], 1, 1, (() => {
                c[i] = null
            })), Ia(), r = c[n], r ? r.p(t, o) : (r = c[n] = l[n](t), r.c()), Ea(r, 1), r.m(a.parentNode, a))
        }, i(e) {
            s || (Ea(r), s = !0)
        }, o(e) {
            Aa(r), s = !1
        }, d(e) {
            e && Lr(o), c[n].d(e), e && Lr(a)
        }
    }
}

function up(e) {
    let t, o, i = [], n = new Map, r = e[2];
    const a = e => e[0] + e[1];
    for (let t = 0; t < r.length; t += 1) {
        let o = ip(e, r, t), s = a(o);
        n.set(s, i[t] = dp(s, o))
    }
    return {
        c() {
            for (let e = 0; e < i.length; e += 1) i[e].c();
            t = Or()
        }, m(e, n) {
            for (let t = 0; t < i.length; t += 1) i[t].m(e, n);
            Ar(e, t, n), o = !0
        }, p(e, [o]) {
            62 & o && (r = e[2], Ra(), i = Oa(i, o, a, 1, e, r, n, t.parentNode, Ba, dp, t, ip), Ia())
        }, i(e) {
            if (!o) {
                for (let e = 0; e < r.length; e += 1) Ea(i[e]);
                o = !0
            }
        }, o(e) {
            for (let e = 0; e < i.length; e += 1) Aa(i[e]);
            o = !1
        }, d(e) {
            for (let t = 0; t < i.length; t += 1) i[t].d(e);
            e && Lr(t)
        }
    }
}

function hp(e, t, o) {
    let i, n, {items: r} = t, {discardEmptyItems: a = !0} = t, {key: s = ""} = t;
    const l = {
        Button: xp,
        ImageButton: Pd,
        ImageButtonList: Ld,
        Dropdown: eh,
        Select: op,
        RadioGroup: Eu,
        Input: zu,
        Panel: nh,
        ProgressIndicator: Th,
        ShapeStyle: Ih,
        ToggleSlider: Sh,
        ColorPicker: qh,
        ShorthandControl: Qh
    }, c = e => !h(e) || !!l[e], d = e => {
        if (!e) return !1;
        const [t, , o, i = []] = e;
        return !!c(t) || (i.some(d) || o.textContent || o.innerHTML)
    };
    return e.$$set = e => {
        "items" in e && o(6, r = e.items), "discardEmptyItems" in e && o(7, a = e.discardEmptyItems), "key" in e && o(0, s = e.key)
    }, e.$$.update = () => {
        1 & e.$$.dirty && o(1, i = s), 192 & e.$$.dirty && o(2, n = (r && a ? r.filter(d) : r) || [])
    }, [s, i, n, l, (e = {}) => {
        const {textContent: t, innerHTML: o, ...i} = e;
        return i
    }, c, r, a]
}

class pp extends Ga {
    constructor(e) {
        super(), Ua(this, e, hp, up, lr, {items: 6, discardEmptyItems: 7, key: 0})
    }

    get items() {
        return this.$$.ctx[6]
    }

    set items(e) {
        this.$$set({items: e}), ka()
    }

    get discardEmptyItems() {
        return this.$$.ctx[7]
    }

    set discardEmptyItems(e) {
        this.$$set({discardEmptyItems: e}), ka()
    }

    get key() {
        return this.$$.ctx[0]
    }

    set key(e) {
        this.$$set({key: e}), ka()
    }
}

function mp(e) {
    let t, o;
    return t = new wd({props: {class: "PinturaButtonIcon", $$slots: {default: [gp]}, $$scope: {ctx: e}}}), {
        c() {
            Na(t.$$.fragment)
        }, m(e, i) {
            Ha(t, e, i), o = !0
        }, p(e, o) {
            const i = {};
            536870920 & o && (i.$$scope = {dirty: o, ctx: e}), t.$set(i)
        }, i(e) {
            o || (Ea(t.$$.fragment, e), o = !0)
        }, o(e) {
            Aa(t.$$.fragment, e), o = !1
        }, d(e) {
            ja(t, e)
        }
    }
}

function gp(e) {
    let t;
    return {
        c() {
            t = zr("g")
        }, m(o, i) {
            Ar(o, t, i), t.innerHTML = e[3]
        }, p(e, o) {
            8 & o && (t.innerHTML = e[3])
        }, d(e) {
            e && Lr(t)
        }
    }
}

function $p(e) {
    let t;
    return {
        c() {
            t = Fr("span"), Nr(t, "class", e[11])
        }, m(o, i) {
            Ar(o, t, i), t.innerHTML = e[0]
        }, p(e, o) {
            1 & o && (t.innerHTML = e[0]), 2048 & o && Nr(t, "class", e[11])
        }, i: tr, o: tr, d(e) {
            e && Lr(t)
        }
    }
}

function fp(e) {
    let t, o, i;
    return o = new pp({props: {items: e[0]}}), {
        c() {
            t = Fr("span"), Na(o.$$.fragment), Nr(t, "class", e[11])
        }, m(e, n) {
            Ar(e, t, n), Ha(o, t, null), i = !0
        }, p(e, n) {
            const r = {};
            1 & n && (r.items = e[0]), o.$set(r), (!i || 2048 & n) && Nr(t, "class", e[11])
        }, i(e) {
            i || (Ea(o.$$.fragment, e), i = !0)
        }, o(e) {
            Aa(o.$$.fragment, e), i = !1
        }, d(e) {
            e && Lr(t), ja(o)
        }
    }
}

function yp(e) {
    let t, o, i, n, r, a;
    const s = e[27].default, l = mr(s, e, e[29], null), c = l || function (e) {
        let t, o, i, n, r, a, s = e[3] && mp(e);
        const l = [fp, $p], c = [];

        function d(e, t) {
            return 1 & t && (i = null), null == i && (i = !!Oo(e[0])), i ? 0 : 1
        }

        return n = d(e, -1), r = c[n] = l[n](e), {
            c() {
                t = Fr("span"), s && s.c(), o = Br(), r.c(), Nr(t, "class", e[13])
            }, m(e, i) {
                Ar(e, t, i), s && s.m(t, null), Rr(t, o), c[n].m(t, null), a = !0
            }, p(e, i) {
                e[3] ? s ? (s.p(e, i), 8 & i && Ea(s, 1)) : (s = mp(e), s.c(), Ea(s, 1), s.m(t, o)) : s && (Ra(), Aa(s, 1, 1, (() => {
                    s = null
                })), Ia());
                let u = n;
                n = d(e, i), n === u ? c[n].p(e, i) : (Ra(), Aa(c[u], 1, 1, (() => {
                    c[u] = null
                })), Ia(), r = c[n], r ? r.p(e, i) : (r = c[n] = l[n](e), r.c()), Ea(r, 1), r.m(t, null)), (!a || 8192 & i) && Nr(t, "class", e[13])
            }, i(e) {
                a || (Ea(s), Ea(r), a = !0)
            }, o(e) {
                Aa(s), Aa(r), a = !1
            }, d(e) {
                e && Lr(t), s && s.d(), c[n].d()
            }
        }
    }(e);
    return {
        c() {
            t = Fr("button"), c && c.c(), Nr(t, "type", e[6]), t.disabled = e[5], Nr(t, "class", e[12]), Nr(t, "title", o = kd(e[0], e[1], e[2]))
        }, m(o, s) {
            Ar(o, t, s), c && c.m(t, null), e[28](t), n = !0, r || (a = [Wr(t, "keydown", (function () {
                sr(e[8]) && e[8].apply(this, arguments)
            })), Wr(t, "click", (function () {
                sr(e[7]) && e[7].apply(this, arguments)
            })), Wr(t, "pointerdown", (function () {
                sr(e[14]) && e[14].apply(this, arguments)
            })), wr(i = od.call(null, t, e[4])), wr(e[9].call(null, t))], r = !0)
        }, p(r, [a]) {
            e = r, l ? l.p && (!n || 536870912 & a) && fr(l, s, e, e[29], n ? $r(s, e[29], a, null) : yr(e[29]), null) : c && c.p && (!n || 10249 & a) && c.p(e, n ? a : -1), (!n || 64 & a) && Nr(t, "type", e[6]), (!n || 32 & a) && (t.disabled = e[5]), (!n || 4096 & a) && Nr(t, "class", e[12]), (!n || 7 & a && o !== (o = kd(e[0], e[1], e[2]))) && Nr(t, "title", o), i && sr(i.update) && 16 & a && i.update.call(null, e[4])
        }, i(e) {
            n || (Ea(c, e), n = !0)
        }, o(e) {
            Aa(c, e), n = !1
        }, d(o) {
            o && Lr(t), c && c.d(o), e[28](null), r = !1, ar(a)
        }
    }
}

function bp(e, t, o) {
    let n, r, a, s, l, c, {
        $$slots: d = {},
        $$scope: u
    } = t, {class: h} = t, {label: p} = t, {title: m} = t, {shortcut: g} = t, {labelClass: $} = t, {innerClass: f} = t, {hideLabel: y = !1} = t, {icon: b} = t, {style: x} = t, {disabled: v} = t, {type: w = "button"} = t, {onclick: S} = t, {onkeydown: k} = t, {onhold: C} = t, {
        action: T = (() => {
        })
    } = t, {holdThreshold: M = 500} = t, {holdSpeedUpFactor: P = .5} = t, {holdSpeedMin: R = 20} = t;
    const I = e => {
        o(25, c = setTimeout((() => {
            C(), I(Math.max(e * P, R))
        }), e))
    };
    let E;
    return e.$$set = e => {
        "class" in e && o(15, h = e.class), "label" in e && o(0, p = e.label), "title" in e && o(1, m = e.title), "shortcut" in e && o(2, g = e.shortcut), "labelClass" in e && o(16, $ = e.labelClass), "innerClass" in e && o(17, f = e.innerClass), "hideLabel" in e && o(18, y = e.hideLabel), "icon" in e && o(3, b = e.icon), "style" in e && o(4, x = e.style), "disabled" in e && o(5, v = e.disabled), "type" in e && o(6, w = e.type), "onclick" in e && o(7, S = e.onclick), "onkeydown" in e && o(8, k = e.onkeydown), "onhold" in e && o(19, C = e.onhold), "action" in e && o(9, T = e.action), "holdThreshold" in e && o(20, M = e.holdThreshold), "holdSpeedUpFactor" in e && o(21, P = e.holdSpeedUpFactor), "holdSpeedMin" in e && o(22, R = e.holdSpeedMin), "$$scope" in e && o(29, u = e.$$scope)
    }, e.$$.update = () => {
        101187584 & e.$$.dirty && o(26, r = C ? () => {
            c && (clearTimeout(c), o(25, c = void 0), document.documentElement.removeEventListener("pointerup", r))
        } : i), 68681728 & e.$$.dirty && o(14, n = C ? () => {
            document.documentElement.addEventListener("pointerup", r), I(M)
        } : i), 131072 & e.$$.dirty && o(13, a = Zc(["PinturaButtonInner", f])), 294912 & e.$$.dirty && o(12, s = Zc(["PinturaButton", y && "PinturaButtonIconOnly", h])), 327680 & e.$$.dirty && o(11, l = Zc([y ? "implicit" : "PinturaButtonLabel", $]))
    }, [p, m, g, b, x, v, w, S, k, T, E, l, s, a, n, h, $, f, y, C, M, P, R, e => Sd(e, E), () => E, c, r, d, function (e) {
        ha[e ? "unshift" : "push"]((() => {
            E = e, o(10, E)
        }))
    }, u]
}

class xp extends Ga {
    constructor(e) {
        super(), Ua(this, e, bp, yp, lr, {
            class: 15,
            label: 0,
            title: 1,
            shortcut: 2,
            labelClass: 16,
            innerClass: 17,
            hideLabel: 18,
            icon: 3,
            style: 4,
            disabled: 5,
            type: 6,
            onclick: 7,
            onkeydown: 8,
            onhold: 19,
            action: 9,
            holdThreshold: 20,
            holdSpeedUpFactor: 21,
            holdSpeedMin: 22,
            isEventTarget: 23,
            getElement: 24
        })
    }

    get isEventTarget() {
        return this.$$.ctx[23]
    }

    get getElement() {
        return this.$$.ctx[24]
    }
}

var vp = (e, t) => {
    const o = e.findIndex(t);
    if (o >= 0) return e.splice(o, 1)
};
const wp = 80;
var Sp = (e, t = {}) => {
    const {
        inertia: o = !1,
        inertiaDurationMultiplier: i = wp,
        shouldStartInteraction: n = (() => !0),
        pinch: r = !1,
        multiTouch: a,
        getEventPosition: s = (e => he(e.clientX, e.clientY)),
        observeKeys: l = !1
    } = t;

    function c(t, o) {
        e.dispatchEvent(new CustomEvent(t, {detail: o}))
    }

    function d() {
        w && w(), w = void 0
    }

    const u = [], h = e => 0 === e.timeStamp ? Date.now() : e.timeStamp, p = () => {
        const e = me(u[0].position);
        if (u[1]) {
            const t = .5 * (u[1].position.x - e.x), o = .5 * (u[1].position.y - e.y);
            e.x += t, e.y += o
        }
        return e
    }, m = e => {
        e.origin.x = e.position.x, e.origin.y = e.position.y, e.translation.x = 0, e.translation.y = 0
    }, g = e => {
        const t = (e => u.findIndex((t => t.event.pointerId === e.pointerId)))(e);
        if (!(t < 0)) return u[t]
    }, $ = () => 1 === u.length, f = () => 2 === u.length, y = e => {
        const t = Ee(e.map((e => e.position)));
        return {
            center: t,
            distance: ((e, t) => e.reduce(((e, o) => e + Re(t, o.position)), 0) / e.length)(e, t),
            velocity: Ee(e.map((e => e.velocity))),
            translation: Ee(e.map((e => e.translation)))
        }
    };
    let b, x, v, w, S, k, C, T, M = 0, P = void 0;
    e.addEventListener("pointerdown", L);
    const R = ["Meta", "Control", "Alt", "Shift"];

    function I(e) {
        if (!R.includes(e.key)) return;
        const {metaKey: t, ctrlKey: o, altKey: i, shiftKey: n} = e;
        A({metaKey: t, ctrlKey: o, altKey: i, shiftKey: n})
    }

    let E = Date.now();
    const A = e => {
        const t = me(u[0].translation);
        let o = C;
        if (r && f()) {
            o *= Re(u[0].position, u[1].position) / S, we(t, u[1].translation)
        }
        we(t, k);
        const i = Date.now();
        i - E < 16 || (E = i, c("interactionupdate", {
            position: p(),
            translation: t,
            scalar: r ? o : void 0,
            isMultiTouching: f(), ...e
        }))
    };

    function L(t) {
        if (!f() && !(e => zo(e.button) && 0 !== e.button)(t) && n(t, e)) if (d(), (e => {
            const t = h(e), o = {
                timeStamp: t,
                timeStampInitial: t,
                position: s(e),
                origin: s(e),
                velocity: ue(),
                velocityHistory: [],
                velocityAverage: ue(),
                translation: ue(),
                interactionState: void 0,
                event: e
            };
            u.push(o), o.interactionState = y(u)
        })(t), l && (window.addEventListener("keydown", I), window.addEventListener("keyup", I)), $()) document.documentElement.addEventListener("pointermove", F), document.documentElement.addEventListener("pointerup", z), document.documentElement.addEventListener("pointercancel", z), document.addEventListener("visibilitychange", B), T = !1, C = 1, k = ue(), S = void 0, c("interactionstart", {origin: me(g(t).origin)}); else if (r) T = !0, S = Re(u[0].position, u[1].position), k.x += u[0].translation.x, k.y += u[0].translation.y, m(u[0]); else if (!1 === a) return u.length = 0, W(), c("interactioncancel")
    }

    function F(e) {
        e.preventDefault(), (e => {
            const t = g(e);
            if (!t) return;
            const o = h(e), i = s(e), n = Math.max(1, o - t.timeStamp);
            t.velocity.x = (i.x - t.position.x) / n, t.velocity.y = (i.y - t.position.y) / n, t.velocityHistory.push(me(t.velocity)), t.velocityHistory = t.velocityHistory.slice(-3), t.velocityAverage = t.velocityHistory.reduce(((e, t, o, i) => (e.x += t.x / i.length, e.y += t.y / i.length, e)), ue()), t.translation.x = i.x - t.origin.x, t.translation.y = i.y - t.origin.y, t.timeStamp = o, t.position.x = i.x, t.position.y = i.y, t.event = e
        })(e);
        const {metaKey: t = !1, ctrlKey: o = !1, altKey: i = !1, shiftKey: n = !1} = l ? e : {};
        A({metaKey: t, ctrlKey: o, altKey: i, shiftKey: n})
    }

    function z(e) {
        if (!g(e)) return;
        const t = p(), n = (e => {
            const t = vp(u, (t => t.event.pointerId === e.pointerId));
            if (t) return t[0]
        })(e);
        if (r && $()) {
            const e = Re(u[0].position, n.position);
            C *= e / S, k.x += u[0].translation.x + n.translation.x, k.y += u[0].translation.y + n.translation.y, m(u[0])
        }
        let a = !1, s = !1;
        if (!T && n) {
            const e = performance.now(), t = e - n.timeStampInitial, o = Pe(n.translation);
            a = o < 64 && t < 300, s = !!(P && a && e - M < 700 && Pe(P, n.position) < 128), a && (P = me(n.position), M = e)
        }
        if (u.length > 0) return;
        W();
        const l = me(n.translation), d = me(n.velocityAverage);
        let h = !1;
        c("interactionrelease", {
            isTap: a,
            isDoubleTap: s,
            position: t,
            translation: l,
            scalar: C,
            preventInertia: () => h = !0
        });
        const f = Re(d);
        if (h || !o || f < .25) return O(l, {isTap: a, isDoubleTap: s});
        x = me(t), v = me(l), b = fc(me(l), {easing: mc, duration: f * i}), b.set({
            x: l.x + 50 * d.x,
            y: l.y + 50 * d.y
        }).then((() => {
            w && O(hr(b), {isTap: a, isDoubleTap: s})
        })), w = b.subscribe(D)
    }

    function D(e) {
        e && c("interactionupdate", {
            position: he(x.x + (e.x - v.x), x.y + (e.y - v.y)),
            translation: e,
            scalar: r ? C : void 0
        })
    }

    function B(e) {
        if ("visible" === document.visibilityState || !u.length) return;
        const t = y(u);
        d(), c("interactionend", {...t}), u.length = 0, W()
    }

    function O(e, t) {
        d(), c("interactionend", {...t, translation: e, scalar: r ? C : void 0})
    }

    function W() {
        l && window.removeEventListener("keydown", I), l && window.removeEventListener("keyup", I), document.documentElement.removeEventListener("pointermove", F), document.documentElement.removeEventListener("pointerup", z), document.documentElement.removeEventListener("pointercancel", z), document.removeEventListener("visibilitychange", B)
    }

    return {
        destroy() {
            d(), e.removeEventListener("pointerdown", L)
        }
    }
};

function kp(e, t) {
    return t ? t * Math.sign(e) * Math.log10(1 + Math.abs(e) / t) : e
}

const Cp = (e, t, o) => {
    if (!t || !o) return {...e};
    const i = e.x + kp(t.x - e.x, o), n = e.x + e.width + kp(t.x + t.width - (e.x + e.width), o),
        r = e.y + kp(t.y - e.y, o);
    return {x: i, y: r, width: n - i, height: e.y + e.height + kp(t.y + t.height - (e.y + e.height), o) - r}
}, Tp = (e, t, o) => t && o ? he(e.x + kp(t.x - e.x, o), e.y + kp(t.y - e.y, o)) : {...e};
var Mp = (e, t) => {
    if (e) return /em/.test(e) ? 16 * parseInt(e, 10) : /px/.test(e) ? parseInt(e, 10) : void 0
}, Pp = (e, t) => {
    let o = e.detail || 0;
    const {
        deltaX: i,
        deltaY: n,
        wheelDelta: r,
        wheelDeltaX: a,
        wheelDeltaY: s
    } = e, {fixScrollDirection: l = !1} = t || {};
    return zo(a) && Math.abs(a) > Math.abs(s) ? o = a / -120 : zo(i) && Math.abs(i) > Math.abs(n) ? o = i / 20 : (r || s) && (o = (r || s) / -120), o || (o = n / 20), (z() || Kt()) && (o *= 2), l && fo() && (o *= -1), o
};

function Rp(e) {
    let t, o, i, n, r, a, s;
    const l = e[38].default, c = mr(l, e, e[37], null);
    return {
        c() {
            t = Fr("div"), o = Fr("div"), c && c.c(), Zr(o, "transform", e[6]), Nr(t, "class", i = Zc(["PinturaScrollable", e[0]])), Nr(t, "data-direction", e[1]), Nr(t, "data-state", e[7]), Zr(t, "--scrollable-feather-start-opacity", e[4]), Zr(t, "--scrollable-feather-end-opacity", e[5])
        }, m(i, l) {
            Ar(i, t, l), Rr(t, o), c && c.m(o, null), e[40](t), r = !0, a || (s = [Wr(o, "interactionstart", e[10]), Wr(o, "interactionupdate", e[12]), Wr(o, "interactionend", e[13]), Wr(o, "interactionrelease", e[11]), wr(Sp.call(null, o, {inertia: !0})), Wr(o, "measure", e[39]), wr(zc.call(null, o)), Wr(t, "wheel", e[15], {passive: !1}), Wr(t, "scroll", e[17]), Wr(t, "focusin", e[16]), Wr(t, "nudge", e[18]), Wr(t, "measure", e[14]), wr(zc.call(null, t, {observePosition: !0})), wr(n = rh.call(null, t, {
                direction: "x" === e[1] ? "horizontal" : "vertical",
                stopKeydownPropagation: !1
            }))], a = !0)
        }, p(e, a) {
            c && c.p && (!r || 64 & a[1]) && fr(c, l, e, e[37], r ? $r(l, e[37], a, null) : yr(e[37]), null), 64 & a[0] && Zr(o, "transform", e[6]), (!r || 1 & a[0] && i !== (i = Zc(["PinturaScrollable", e[0]]))) && Nr(t, "class", i), (!r || 2 & a[0]) && Nr(t, "data-direction", e[1]), (!r || 128 & a[0]) && Nr(t, "data-state", e[7]), n && sr(n.update) && 2 & a[0] && n.update.call(null, {
                direction: "x" === e[1] ? "horizontal" : "vertical",
                stopKeydownPropagation: !1
            }), 16 & a[0] && Zr(t, "--scrollable-feather-start-opacity", e[4]), 32 & a[0] && Zr(t, "--scrollable-feather-end-opacity", e[5])
        }, i(e) {
            r || (Ea(c, e), r = !0)
        }, o(e) {
            Aa(c, e), r = !1
        }, d(o) {
            o && Lr(t), c && c.d(o), e[40](null), a = !1, ar(s)
        }
    }
}

function Ip(e, t, o) {
    let n, r, a, s, l, c, d, u, h, {$$slots: p = {}, $$scope: m} = t;
    const g = sa();
    let $, f, y, b, x = "idle", v = bc(0);
    pr(e, v, (e => o(36, u = e)));
    let {class: w} = t, {scrollBlockInteractionDist: S = 5} = t, {scrollStep: k = 10} = t, {scrollFocusMargin: C = 64} = t, {scrollDirection: T = "x"} = t, {scrollAutoCancel: M = !1} = t, {elasticity: P = 0} = t, {onscroll: R = i} = t, {maskFeatherSize: I} = t, {maskFeatherStartOpacity: E} = t, {maskFeatherEndOpacity: A} = t, {scroll: L} = t;
    const F = ca("fixScrollDirection");
    let z;
    pr(e, F, (e => o(47, h = e)));
    let D = void 0, B = void 0, O = !0;
    const W = v.subscribe((e => {
        const t = ue();
        t[T] = e, R(t)
    })), V = e => Math.max(Math.min(0, e), y[n] - f[n]);
    let _, N, H;
    const j = (e, t = {}) => {
        const {elastic: i = !1, animate: n = !1, preventScrollState: r = !1} = t;
        Math.abs(e - $) > S && "idle" === x && !b && !r && o(29, x = "scrolling");
        const a = V(e), s = i && P && !b ? a + kp(e - a, P) : a;
        let l = !0;
        n ? l = !1 : O || (l = !b), O = !1, v.set(s, {hard: l}).then((e => {
            b && (O = !0)
        }))
    };
    aa((() => {
        W()
    }));
    return e.$$set = e => {
        "class" in e && o(0, w = e.class), "scrollBlockInteractionDist" in e && o(22, S = e.scrollBlockInteractionDist), "scrollStep" in e && o(23, k = e.scrollStep), "scrollFocusMargin" in e && o(24, C = e.scrollFocusMargin), "scrollDirection" in e && o(1, T = e.scrollDirection), "scrollAutoCancel" in e && o(25, M = e.scrollAutoCancel), "elasticity" in e && o(26, P = e.elasticity), "onscroll" in e && o(27, R = e.onscroll), "maskFeatherSize" in e && o(21, I = e.maskFeatherSize), "maskFeatherStartOpacity" in e && o(19, E = e.maskFeatherStartOpacity), "maskFeatherEndOpacity" in e && o(20, A = e.maskFeatherEndOpacity), "scroll" in e && o(28, L = e.scroll), "$$scope" in e && o(37, m = e.$$scope)
    }, e.$$.update = () => {
        if (2 & e.$$.dirty[0] && o(33, n = "x" === T ? "width" : "height"), 2 & e.$$.dirty[0] && o(31, r = T.toUpperCase()), 8 & e.$$.dirty[0] && o(35, a = z && getComputedStyle(z)), 8 & e.$$.dirty[0] | 16 & e.$$.dirty[1] && o(34, s = a && Mp(a.getPropertyValue("--scrollable-feather-size"))), 1075314692 & e.$$.dirty[0] | 44 & e.$$.dirty[1] && null != u && y && null != s && f) {
            const e = -1 * u / s, t = -(y[n] - f[n] - u) / s;
            o(19, E = gs(1 - e, 0, 1)), o(20, A = gs(1 - t, 0, 1)), o(21, I = s), o(4, D = E), o(5, B = A)
        }
        268435464 & e.$$.dirty[0] && z && void 0 !== L && (zo(L) ? j(L) : j(L.scrollOffset, L)), 1073741828 & e.$$.dirty[0] | 4 & e.$$.dirty[1] && o(32, l = y && f ? f[n] > y[n] : void 0), 536870912 & e.$$.dirty[0] | 2 & e.$$.dirty[1] && o(7, c = Zc([x, l ? "overflows" : void 0])), 35 & e.$$.dirty[1] && o(6, d = l ? `translate${r}(${u}px)` : "none")
    }, [w, T, f, z, D, B, d, c, v, F, () => {
        l && (N = !1, _ = !0, H = he(0, 0), b = !1, o(29, x = "idle"), $ = hr(v))
    }, ({detail: e}) => {
        l && (b = !0, o(29, x = "idle"))
    }, ({detail: e}) => {
        l && (N || _ && (_ = !1, Pe(e.translation) < .1) || (!M || "x" !== T || (e => {
            const t = ve(he(e.x - H.x, e.y - H.y), Math.abs);
            H = me(e);
            const o = Pe(t), i = t.x - t.y;
            return !(o > 1 && i < -.5)
        })(e.translation) ? j($ + e.translation[T], {elastic: !0}) : N = !0))
    }, ({detail: e}) => {
        if (!l) return;
        if (N) return;
        const t = $ + e.translation[T], o = V(t);
        O = !1, v.set(o).then((e => {
            b && (O = !0)
        }))
    }, ({detail: e}) => {
        o(30, y = e), g("measure", {x: e.x, y: e.y, width: e.width, height: e.height})
    }, e => {
        if (!l) return;
        e.preventDefault(), e.stopPropagation();
        const t = e.shiftKey, o = Pp(e, {fixScrollDirection: h}) * (t ? -1 : 1), i = hr(v);
        j(i + o * k, {animate: !0})
    }, e => {
        if (!l) return;
        if (!b) return;
        let t = e.target;
        e.target.classList.contains("implicit") && (t = t.parentNode);
        const o = t["x" === T ? "offsetLeft" : "offsetTop"], i = o + t["x" === T ? "offsetWidth" : "offsetHeight"],
            r = hr(v), a = C + I;
        r + o < a ? j(-o + a) : r + i > y[n] - a && j(y[n] - i - a, {animate: !0})
    }, () => {
        o(3, z["x" === T ? "scrollLeft" : "scrollTop"] = 0, z)
    }, ({detail: e}) => {
        if (z.querySelector("[data-focus-visible]")) return;
        const t = -2 * e[T], o = hr(v);
        j(o + t * k, {animate: !0, preventScrollState: !0})
    }, E, A, I, S, k, C, M, P, R, L, x, y, r, l, n, s, a, u, m, p, e => o(2, f = e.detail), function (e) {
        ha[e ? "unshift" : "push"]((() => {
            z = e, o(3, z)
        }))
    }]
}

class Ep extends Ga {
    constructor(e) {
        super(), Ua(this, e, Ip, Rp, lr, {
            class: 0,
            scrollBlockInteractionDist: 22,
            scrollStep: 23,
            scrollFocusMargin: 24,
            scrollDirection: 1,
            scrollAutoCancel: 25,
            elasticity: 26,
            onscroll: 27,
            maskFeatherSize: 21,
            maskFeatherStartOpacity: 19,
            maskFeatherEndOpacity: 20,
            scroll: 28
        }, null, [-1, -1])
    }
}

function Ap(e) {
    let t, o, i, n, r;
    return {
        c() {
            t = Fr("span"), Nr(t, "class", "PinturaStatusMessage")
        }, m(o, a) {
            Ar(o, t, a), t.innerHTML = e[0], i = !0, n || (r = [Wr(t, "measure", (function () {
                sr(e[1]) && e[1].apply(this, arguments)
            })), wr(zc.call(null, t))], n = !0)
        }, p(o, [n]) {
            e = o, (!i || 1 & n) && (t.innerHTML = e[0])
        }, i(n) {
            i || (ba((() => {
                o || (o = Fa(t, e[4], {duration: e[2]}, !0)), o.run(1)
            })), i = !0)
        }, o(n) {
            o || (o = Fa(t, e[4], {duration: e[2]}, !1)), o.run(0), i = !1
        }, d(e) {
            e && Lr(t), e && o && o.end(), n = !1, ar(r)
        }
    }
}

function Lp(e, t, o) {
    let n, r, {text: a} = t, {onmeasure: s = i} = t;
    const l = ca("isAnimated");
    return pr(e, l, (e => o(5, r = e))), e.$$set = e => {
        "text" in e && o(0, a = e.text), "onmeasure" in e && o(1, s = e.onmeasure)
    }, e.$$.update = () => {
        32 & e.$$.dirty && o(2, n = r ? 500 : 0)
    }, [a, s, n, l, function (e, {duration: t}) {
        return {
            duration: t, tick: t => {
                e.style.opacity = t
            }
        }
    }, r]
}

class Fp extends Ga {
    constructor(e) {
        super(), Ua(this, e, Lp, Ap, lr, {text: 0, onmeasure: 1})
    }
}

function zp(e) {
    let t, o, i;
    const n = e[5].default, r = mr(n, e, e[4], null);
    return {
        c() {
            t = Fr("span"), r && r.c(), Nr(t, "class", o = "PinturaStatusAside " + e[1]), Zr(t, "transform", e[2]), Zr(t, "opacity", e[0])
        }, m(e, o) {
            Ar(e, t, o), r && r.m(t, null), i = !0
        }, p(e, [a]) {
            r && r.p && (!i || 16 & a) && fr(r, n, e, e[4], i ? $r(n, e[4], a, null) : yr(e[4]), null), (!i || 2 & a && o !== (o = "PinturaStatusAside " + e[1])) && Nr(t, "class", o), 4 & a && Zr(t, "transform", e[2]), 1 & a && Zr(t, "opacity", e[0])
        }, i(e) {
            i || (Ea(r, e), i = !0)
        }, o(e) {
            Aa(r, e), i = !1
        }, d(e) {
            e && Lr(t), r && r.d(e)
        }
    }
}

function Dp(e, t, o) {
    let i, {$$slots: n = {}, $$scope: r} = t, {offset: a = 0} = t, {opacity: s = 0} = t, {class: l} = t;
    return e.$$set = e => {
        "offset" in e && o(3, a = e.offset), "opacity" in e && o(0, s = e.opacity), "class" in e && o(1, l = e.class), "$$scope" in e && o(4, r = e.$$scope)
    }, e.$$.update = () => {
        8 & e.$$.dirty && o(2, i = `translateX(${a}px)`)
    }, [s, l, i, a, r, n]
}

class Bp extends Ga {
    constructor(e) {
        super(), Ua(this, e, Dp, zp, lr, {offset: 3, opacity: 0, class: 1})
    }
}

let Op = null;
var Wp = e => {
    if (null === Op && (Op = l() && "visualViewport" in window), !Op) return !1;
    const t = visualViewport.height, o = () => {
        e(visualViewport.height < t ? "visible" : "hidden")
    };
    return visualViewport.addEventListener("resize", o), () => visualViewport.removeEventListener("resize", o)
};

function Vp(e) {
    let t, o;
    const i = [{onclick: e[1]}, e[3]];
    let n = {};
    for (let e = 0; e < i.length; e += 1) n = ir(n, i[e]);
    return t = new xp({props: n}), {
        c() {
            Na(t.$$.fragment)
        }, m(e, i) {
            Ha(t, e, i), o = !0
        }, p(e, o) {
            const n = 10 & o[0] ? Wa(i, [2 & o[0] && {onclick: e[1]}, 8 & o[0] && Va(e[3])]) : {};
            t.$set(n)
        }, i(e) {
            o || (Ea(t.$$.fragment, e), o = !0)
        }, o(e) {
            Aa(t.$$.fragment, e), o = !1
        }, d(e) {
            ja(t, e)
        }
    }
}

function _p(e) {
    let t, o;
    const i = [{onclick: e[0]}, {class: "PinturaInputFormButtonConfirm"}, e[2]];
    let n = {};
    for (let e = 0; e < i.length; e += 1) n = ir(n, i[e]);
    return t = new xp({props: n}), {
        c() {
            Na(t.$$.fragment)
        }, m(e, i) {
            Ha(t, e, i), o = !0
        }, p(e, o) {
            const n = 5 & o[0] ? Wa(i, [1 & o[0] && {onclick: e[0]}, i[1], 4 & o[0] && Va(e[2])]) : {};
            t.$set(n)
        }, i(e) {
            o || (Ea(t.$$.fragment, e), o = !0)
        }, o(e) {
            Aa(t.$$.fragment, e), o = !1
        }, d(e) {
            ja(t, e)
        }
    }
}

function Np(e) {
    let t, o, i, n, r, a, s, l, c = e[3] && Vp(e);
    const d = e[29].default, u = mr(d, e, e[28], null);
    let h = e[2] && _p(e);
    return {
        c() {
            t = Fr("div"), o = Fr("div"), c && c.c(), i = Br(), n = Fr("div"), u && u.c(), r = Br(), h && h.c(), Nr(n, "class", "PinturaInputFormFields"), Nr(o, "class", "PinturaInputFormInner"), Nr(t, "class", "PinturaInputForm"), Nr(t, "data-layout", e[4]), Zr(t, "opacity", e[6]), Zr(t, "left", e[7]), Zr(t, "top", e[8]), Zr(t, "right", e[9]), Zr(t, "bottom", e[10])
        }, m(d, p) {
            Ar(d, t, p), Rr(t, o), c && c.m(o, null), Rr(o, i), Rr(o, n), u && u.m(n, null), Rr(o, r), h && h.m(o, null), e[30](t), a = !0, s || (l = [Wr(n, "keydown", e[14]), Wr(t, "focusin", e[11]), Wr(t, "focusout", e[12]), Wr(t, "measure", e[13]), wr(zc.call(null, t))], s = !0)
        }, p(e, n) {
            e[3] ? c ? (c.p(e, n), 8 & n[0] && Ea(c, 1)) : (c = Vp(e), c.c(), Ea(c, 1), c.m(o, i)) : c && (Ra(), Aa(c, 1, 1, (() => {
                c = null
            })), Ia()), u && u.p && (!a || 268435456 & n[0]) && fr(u, d, e, e[28], a ? $r(d, e[28], n, null) : yr(e[28]), null), e[2] ? h ? (h.p(e, n), 4 & n[0] && Ea(h, 1)) : (h = _p(e), h.c(), Ea(h, 1), h.m(o, null)) : h && (Ra(), Aa(h, 1, 1, (() => {
                h = null
            })), Ia()), (!a || 16 & n[0]) && Nr(t, "data-layout", e[4]), 64 & n[0] && Zr(t, "opacity", e[6]), 128 & n[0] && Zr(t, "left", e[7]), 256 & n[0] && Zr(t, "top", e[8]), 512 & n[0] && Zr(t, "right", e[9]), 1024 & n[0] && Zr(t, "bottom", e[10])
        }, i(e) {
            a || (Ea(c), Ea(u, e), Ea(h), a = !0)
        }, o(e) {
            Aa(c), Aa(u, e), Aa(h), a = !1
        }, d(o) {
            o && Lr(t), c && c.d(), u && u.d(o), h && h.d(), e[30](null), s = !1, ar(l)
        }
    }
}

function Hp(e, t, o) {
    let i, n, r, a, s, {
            $$slots: l = {},
            $$scope: c
        } = t, {onconfirm: d} = t, {oncancel: u} = t, {autoFocus: h = !0} = t, {autoPositionCursor: p = !0} = t, {buttonConfirm: m} = t, {buttonCancel: g} = t, {layout: $ = "stack"} = t, {parentRect: f} = t, {align: y} = t, {justify: b} = t, {parentMargin: v = 16} = t, {panelOffset: w = ue()} = t, {willHandleKeydown: S = (() => !0)} = t,
        k = !1, C = void 0, T = void 0, M = {top: void 0, bottom: void 0}, P = 0, R = void 0, I = void 0, E = void 0,
        A = void 0;
    const L = () => {
        const e = s.querySelector("input, textarea");
        e.focus(), P >= 1 || e.select()
    }, F = () => {
        k = !0, D || !bo() && !x() || o(24, M = {top: "1em", bottom: "auto"}), bo() && (e => {
            let t;
            const o = e => t = e.touches[0].screenY, i = e => {
                const o = e.touches[0].screenY, i = e.target;
                /textarea/i.test(i.nodeName) ? (o > t ? 0 == i.scrollTop && e.preventDefault() : o < t ? i.scrollTop + i.offsetHeight == i.scrollHeight && e.preventDefault() : e.preventDefault(), t = o) : e.preventDefault()
            };
            e.addEventListener("touchstart", o), e.addEventListener("touchmove", i)
        })(s), o(6, P = 1)
    };
    let z;
    const D = Wp((e => {
        a ? "hidden" !== e || k ? (clearTimeout(T), T = void 0, o(24, M = {top: visualViewport.height - C.height - w.y + "px"}), "visible" === e ? (o(5, s.dataset.stick = !0, s), L(), F()) : (k = !1, o(6, P = 0))) : L() : o(24, M = {
            top: "4.5em",
            bottom: "auto"
        })
    }));
    return na((() => {
        h && L()
    })), aa((() => {
        D && D()
    })), e.$$set = e => {
        "onconfirm" in e && o(0, d = e.onconfirm), "oncancel" in e && o(1, u = e.oncancel), "autoFocus" in e && o(15, h = e.autoFocus), "autoPositionCursor" in e && o(16, p = e.autoPositionCursor), "buttonConfirm" in e && o(2, m = e.buttonConfirm), "buttonCancel" in e && o(3, g = e.buttonCancel), "layout" in e && o(4, $ = e.layout), "parentRect" in e && o(17, f = e.parentRect), "align" in e && o(18, y = e.align), "justify" in e && o(19, b = e.justify), "parentMargin" in e && o(20, v = e.parentMargin), "panelOffset" in e && o(21, w = e.panelOffset), "willHandleKeydown" in e && o(22, S = e.willHandleKeydown), "$$scope" in e && o(28, c = e.$$scope)
    }, e.$$.update = () => {
        8519680 & e.$$.dirty[0] && o(27, i = f && C), 144572416 & e.$$.dirty[0] && o(26, n = i ? ((e, t, o, i, n) => {
            let r, a;
            return r = "center" === i ? e.x + .5 * e.width - .5 * t.width : "right" === i ? e.x + e.width - t.width - n : e.x + n, a = "center" === o ? e.y + .5 * e.height - .5 * t.height : "bottom" === o ? e.y + e.height - t.height - n : e.y + n, {
                top: a + "px",
                right: "auto",
                bottom: "auto",
                left: r + "px"
            }
        })(f, C, y, b, v) : void 0), 201326592 & e.$$.dirty[0] && o(7, R = i ? n.left : void 0), 218103808 & e.$$.dirty[0] && o(8, I = i ? n.top : M.top), 201326592 & e.$$.dirty[0] && o(9, E = i ? n.right : void 0), 218103808 & e.$$.dirty[0] && o(10, A = i ? n.bottom : M.bottom), 32 & e.$$.dirty[0] && o(25, r = s && getComputedStyle(s)), 33554432 & e.$$.dirty[0] && (a = r && "1" === r.getPropertyValue("--editor-modal"))
    }, [d, u, m, g, $, s, P, R, I, E, A, e => {
        var t;
        ((e => /textarea/i.test(e))(e.target) || Od(e.target)) && (z = Date.now(), p && ((t = e.target).selectionStart = t.selectionEnd = t.value.length), clearTimeout(T), T = setTimeout(F, 200))
    }, e => {
        Date.now() - z > 50 || (e.stopPropagation(), L())
    }, ({detail: e}) => {
        o(23, C = {width: e.width, height: e.height})
    }, e => {
        if (S(e)) return "Enter" === e.key ? d() : "Escape" === e.key ? u() : void 0
    }, h, p, f, y, b, v, w, S, C, M, r, n, i, c, l, function (e) {
        ha[e ? "unshift" : "push"]((() => {
            s = e, o(5, s)
        }))
    }]
}

class jp extends Ga {
    constructor(e) {
        super(), Ua(this, e, Hp, Np, lr, {
            onconfirm: 0,
            oncancel: 1,
            autoFocus: 15,
            autoPositionCursor: 16,
            buttonConfirm: 2,
            buttonCancel: 3,
            layout: 4,
            parentRect: 17,
            align: 18,
            justify: 19,
            parentMargin: 20,
            panelOffset: 21,
            willHandleKeydown: 22
        }, null, [-1, -1])
    }
}

var Up = (e, t) => {
    e.fastSeek && e.fastSeek(t), e.currentTime = t
}, Gp = e => e.touches && e.touches.length && "stylus" === e.touches[0].touchType;
const Zp = ["aspectRatio", "isRotatedSideways", "flip", "cropSize"],
    Xp = Cs.map((([e]) => e)).filter((e => !Zp.includes(e)));
var Yp = (e, t) => new CustomEvent("ping", {detail: {type: e, data: t}, cancelable: !0, bubbles: !0}),
    qp = (e, t) => (t ? Pl(e, t) : e).replace(/([a-z])([A-Z])/g, "$1-$2").replace(/\s+/g, "-").toLowerCase(),
    Kp = (e, t = Z) => {
        const {subscribe: o, set: i} = Ya(void 0);
        return {
            subscribe: o, destroy: ((e, t) => {
                const o = matchMedia(e);
                return o.addListener(t), t(o), {
                    get matches() {
                        return o.matches
                    }, destroy: () => o.removeListener(t)
                }
            })(e, (({matches: e}) => i(t(e)))).destroy
        }
    }, Jp = (e, t, o) => new Promise(((i, n) => {
        (async () => {
            Us(e) && i(await js(e));
            const r = await t.read(e), a = e => B(e, o).then((e => t.apply(e, r))).then(i).catch(n);
            if (I(e) || !R() || Kt() || bo()) return a(e);
            let s;
            try {
                s = await L(((e, t) => createImageBitmap(e).then((e => t(null, e))).catch(t)), [e])
            } catch (e) {
            }
            s && s.width ? await d() ? ec() && r > 1 ? i(await (async e => u(await w(e)))(s)) : i(s) : i(t.apply(s, r)) : a(e)
        })()
    })), Qp = (e, t) => new Promise((async o => {
        if (e.width < t.width && e.height < t.height) return o(e);
        const i = Math.min(t.width / e.width, t.height / e.height), n = i * e.width, r = i * e.height,
            a = m("canvas", {width: n, height: r}), s = a.getContext("2d", {willReadFrequently: !0}),
            l = f(e) ? await w(e) : e;
        s.drawImage(l, 0, 0, n, r), o(u(a))
    }));
let em = null;
var tm = () => {
    if (null === em) {
        let e = m("canvas");
        em = !!jl(e), $(e), e = void 0
    }
    return em
};
const om = [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0], im = {precision: 1e-4},
    nm = {precision: .01 * im.precision};
var rm = () => {
        const e = [], t = [], o = [], i = () => {
            t.forEach((e => e(o)))
        }, n = t => {
            t.unsub = t.subscribe((n => ((t, n) => {
                const r = e.indexOf(t);
                r < 0 || (o[r] = n, i())
            })(t, n))), i()
        };
        return {
            get length() {
                return e.length
            }, clear: () => {
                e.forEach((e => e.unsub())), e.length = 0, o.length = 0
            }, unshift: t => {
                e.unshift(t), n(t)
            }, get: t => e[t], push: t => {
                e.push(t), n(t)
            }, remove: t => {
                t.unsub();
                const i = e.indexOf(t);
                e.splice(i, 1), o.splice(i, 1)
            }, forEach: t => e.forEach(t), filter: t => e.filter(t), subscribe: e => (t.push(e), e(o), () => {
                t.splice(t.indexOf(e), 1)
            })
        }
    }, am = e => e[0] < .25 && e[1] < .25 && e[2] < .25, sm = (e = {}) => new Promise((t => {
        const {accept: o = "image/*"} = e,
            i = m("input", {style: "position:absolute;visibility:hidden;width:0;height:0;", type: "file", accept: o}),
            n = () => {
                const [e] = i.files;
                i.parentNode && i.remove(), i.removeEventListener("change", n), t(e)
            };
        i.addEventListener("change", n), bo() && document.body.append(i), i.click()
    })), lm = e => {
        try {
            return e()
        } catch (e) {
            console.error(e)
        }
    }, cm = ([e, t]) => e + .5 * (t - e), dm = e => Math.round(100 * e), um = e => he(e.clientX, e.clientY),
    hm = (e, t, o) => {
        const i = um(e);
        return Se(Se(i, t), o)
    };

function pm(e, t, o) {
    let i, n, r, a, s, l, c, d, u, h, p, m, g, $, f, y, b, x, v, w,
        S, {root: k} = t, {locale: C} = t, {stores: T} = t, {allowPan: M = !0} = t, {allowZoom: P = !0} = t, {enablePan: R = !0} = t, {enableZoom: I = !0} = t, {enableZoomControls: E = I} = t, {enableZoomInput: A = !0} = t, {enablePanInput: L = !0} = t, {enablePanLimit: F = !0} = t, {panLimitGutterScalar: z = 0} = t, {zoomOptions: D = [.25, .5, 1, 1.25, 1.5, 2, 3, 4, 6, 8, 16]} = t, {zoomAdjustStep: B = .25} = t, {zoomAdjustFactor: O = .1} = t, {zoomAdjustWheelFactor: W = 1} = t, {elasticity: V = 5} = t, {imageSelectionRectCentered: _} = t, {imageSelectionRectScalar: N} = t, {zoomLevel: H = null} = t, {zoomControls: j} = t, {zoomMultiTouching: U = !1} = t;
    const {
        isAnimated: G,
        isInteracting: Z,
        rootRect: X,
        stageRect: Y,
        stageScalar: q,
        imageSelectionPan: K,
        imageSelectionZoom: J,
        imageSelectionStageFitScalar: Q,
        imageSelectionRect: ee,
        imageSelectionStoredState: te,
        imagePreviewUpscale: oe
    } = T;
    pr(e, G, (e => o(70, w = e))), pr(e, Z, (e => o(69, x = e))), pr(e, X, (e => o(66, f = e))), pr(e, Y, (e => o(65, $ = e))), pr(e, q, (e => o(46, v = e))), pr(e, K, (e => o(64, p = e))), pr(e, J, (e => o(43, h = e))), pr(e, Q, (e => o(44, m = e))), pr(e, ee, (e => o(67, y = e))), pr(e, te, (e => o(71, S = e))), pr(e, oe, (e => o(45, g = e)));
    const ie = ca("fixScrollDirection");
    pr(e, ie, (e => o(68, b = e)));
    let ne = !1, re = void 0, ae = void 0, se = void 0, le = void 0;
    const ce = e => {
        const t = k.querySelector(".PinturaMain > .PinturaUtilMain") || k.querySelector('div[data-inert="false"] .PinturaUtilMain');
        return !!t && (!!t.contains(e.target) && !Wd(e.target))
    }, de = (e = {}) => {
        const {pan: t = p, zoom: o = h} = e;
        vr(te, S = {translation: t, zoom: o}, S)
    }, pe = () => p && 0 === p.x && 0 === p.y, ge = () => {
        vr(J, h = void 0, h), pe() || vr(K, p = ue(), p), ye.set(void 0, {hard: !0})
    }, $e = () => {
        ge(), de()
    }, ye = bc(void 0, {precision: .01});
    ye.subscribe((e => {
        if (void 0 === e) return vr(J, h = void 0, h), void (pe() || vr(K, p = ue(), p));
        const t = h;
        e <= 1 ? pe() || vr(K, p = ue(), p) : e <= t && vr(K, p = Ce(p, .8), p), vr(J, h = e, h)
    }));
    const be = e => {
        ye.update((t => {
            const o = e(t || m);
            return de({zoom: o}), o
        }))
    }, xe = e => {
        e ? ye.set(e, {hard: !1 === w}) : (e = void 0, ye.set(void 0, {hard: !0})), vr(J, h = e, h), de({zoom: e})
    }, ve = (e, t) => {
        const o = N * t, i = {..._}, n = 1 - gs(z, 0, 1);
        ct(i, o < n ? o : n);
        const r = {..._};
        ct(r, o), lt(r, e);
        const a = {...r};
        return r.x > i.x && (a.x = i.x), r.y > i.y && (a.y = i.y), r.x + r.width < i.x + i.width && (a.x = i.x + i.width - r.width), r.y + r.height < i.y + i.height && (a.y = i.y + i.height - r.height), Se(st(a), st(i))
    }, we = ({translation: e, zoom: t = 1, elastify: o = !0}) => {
        if (!re) return;
        let i = e;
        const n = he(re.x + i.x, re.y + i.y);
        if (!F) return n;
        const r = ve(n, t);
        return o ? Tp(r, n, V) : r
    };
    let Te, Me;
    const Pe = () => {
        Me = void 0, vr(Z, x = !0, x), o(34, ne = L), Te = !1, se = !1, re = {...p}, ae = g ? h || m : r ? h || 1 : h || m
    }, Re = e => {
        const {scalar: t, translation: n, isMultiTouching: r} = e.detail;
        if (!re || !r && !L) return;
        r && Ce(n, .5), (L || r) && (Te = !0), U || o(13, U = r);
        const a = i ? gs(ae * t, s, l) : 1, c = we({translation: n, zoom: a, elastify: !0}), d = fe(c);
        le = fe(p), se = d < le, i && J.set(a), K.set(c), Me = U && {translation: e.detail.translation, scalar: t}
    }, Ie = e => {
        vr(Z, x = !1, x), o(34, ne = !1), o(13, U = !1), se && le < 50 && (re = void 0, ae = void 0, K.set(ue()))
    }, Ee = e => {
        vr(Z, x = !1, x), o(34, ne = !1), o(13, U = !1), Promise.resolve().then((() => {
            if (Te && re) {
                const t = Me || e.detail, o = i ? gs(ae * t.scalar, s, l) : 1,
                    n = we({elastify: !1, translation: t.translation, zoom: o});
                K.set(n)
            }
            re = void 0, ae = void 0, L && e.detail.isDoubleTap && $e(), de()
        }))
    };
    let Ae, Le = Date.now(), Fe = 0, ze = !1, De = !1;
    const Be = e => {
        if (!ce(e)) return;
        if (e.preventDefault(), e.stopPropagation(), De) return;
        clearTimeout(Ae);
        const t = Pp(e, {fixScrollDirection: b}), o = Date.now(), i = o - Le;
        Le = o;
        const n = Math.abs(t / i) > .2;
        Fe = n ? Fe + 1 : 0;
        const r = 1 + -1 * t * W / (n ? 50 : 100), a = hm(e, f, $);
        Oe(a, r, {isZoomingFast: n})
    }, Oe = (e, t, {isZoomingFast: o}) => {
        const i = g ? h || m : r ? h || 1 : h || m, n = i * t, a = ue(), c = p, d = g ? m : r ? 1 : m,
            u = Math.abs(n - d), $ = n < i, f = i > d && $ || i < d && n > i, b = Fe >= 5;
        if (o || (ze = !1), Fe > 0 && !ze && (ze = f), b && ze) return $e(), De = !0, void setTimeout((() => {
            De = !1
        }), 100);
        if (b) return;
        !o && f && u <= .05 && (Ae = setTimeout((() => {
            $e()
        }), 250)), vr(J, h = gs(n, s, l), h);
        const x = Je(y);
        ct(x, i), lt(x, c);
        const v = st(x), w = Je(x);
        ct(w, h - i + 1, e);
        const S = st(w), k = ke(Se(S, v), i);
        ((e, t, o) => {
            e.x = t, e.y = o
        })(a, c.x + k.x, c.y + k.y), vr(K, p = $ && o ? Ce(me(p), .85) : ve(a, i), p), de()
    }, We = e => (e ? "add" : "remove") + "EventListener";
    let Ve, _e, Ne, He;
    const je = e => {
        e.preventDefault(), _e = {...p}, He = Je(y), Ne = hm(e, f, $), Ve = g ? h || m : r ? h || 1 : h || m
    }, Ue = e => {
        e.preventDefault(), vr(J, h = gs(e.scale * Ve, s, l), h);
        const t = Je(He);
        ct(t, Ve), lt(t, _e);
        const o = st(t), i = Je(t);
        ct(i, h - Ve + 1, Ne);
        const n = st(i), r = ke(Se(n, o), Ve), a = {x: _e.x + r.x, y: _e.y + r.y};
        vr(K, p = ve(a, h), p)
    }, Ge = e => {
        e.preventDefault()
    }, Ze = e => {
        k[We(e)]("wheel", Be), bo() || (k[We(e)]("gesturestart", je), k[We(e)]("gesturechange", Ue), k[We(e)]("gestureend", Ge))
    }, Xe = e => {
        const t = We(e);
        k[t]("interactionstart", Pe), k[t]("interactionupdate", Re), k[t]("interactionrelease", Ie), k[t]("interactionend", Ee)
    };
    let Ye;
    return na((() => {
        Ye = Sp(k, {drag: !0, pinch: !0, inertia: !0, inertiaDurationMultiplier: 10, shouldStartInteraction: ce})
    })), aa((() => {
        Ze(!1), Xe(!1), Ye.destroy(), Ye = void 0
    })), e.$$set = e => {
        "root" in e && o(14, k = e.root), "locale" in e && o(15, C = e.locale), "stores" in e && o(16, T = e.stores), "allowPan" in e && o(17, M = e.allowPan), "allowZoom" in e && o(18, P = e.allowZoom), "enablePan" in e && o(19, R = e.enablePan), "enableZoom" in e && o(20, I = e.enableZoom), "enableZoomControls" in e && o(21, E = e.enableZoomControls), "enableZoomInput" in e && o(22, A = e.enableZoomInput), "enablePanInput" in e && o(23, L = e.enablePanInput), "enablePanLimit" in e && o(24, F = e.enablePanLimit), "panLimitGutterScalar" in e && o(25, z = e.panLimitGutterScalar), "zoomOptions" in e && o(26, D = e.zoomOptions), "zoomAdjustStep" in e && o(27, B = e.zoomAdjustStep), "zoomAdjustFactor" in e && o(28, O = e.zoomAdjustFactor), "zoomAdjustWheelFactor" in e && o(29, W = e.zoomAdjustWheelFactor), "elasticity" in e && o(30, V = e.elasticity), "imageSelectionRectCentered" in e && o(31, _ = e.imageSelectionRectCentered), "imageSelectionRectScalar" in e && o(32, N = e.imageSelectionRectScalar), "zoomLevel" in e && o(33, H = e.zoomLevel), "zoomControls" in e && o(12, j = e.zoomControls), "zoomMultiTouching" in e && o(13, U = e.zoomMultiTouching)
    }, e.$$.update = () => {
        var t, $;
        5505024 & e.$$.dirty[0] && o(36, i = P && I && A), 655360 & e.$$.dirty[0] && o(35, n = M && R), 393216 & e.$$.dirty[0] && (M || P ? (vr(J, h = I ? S.zoom : void 0, h), vr(K, p = R ? me(S.translation) : pe() ? p : ue(), p), ye.set(h)) : ge()), 32768 & e.$$.dirty[1] && (r = v >= 1), 67141632 & e.$$.dirty[0] | 57344 & e.$$.dirty[1] && o(40, a = [(g || v < 1) && [m, dm(m) + "%", {sublabel: C.labelZoomFit}], ...D.map((e => [e, dm(e) + "%"]))].filter(Boolean).map((e => (1 === e[0] && (e[2] = {sublabel: C.labelZoomActual}), e))).sort(((e, t) => {
            const o = e[0] || m, i = t[0] || m;
            return o < i ? -1 : i < o ? 1 : 0
        }))), 8704 & e.$$.dirty[1] && o(38, s = Math.min(a.reduce(((e, [t]) => t < e ? t : e), Number.MAX_SAFE_INTEGER), m)), 512 & e.$$.dirty[1] && o(37, l = a.reduce(((e, [t]) => t > e ? t : e), Number.MIN_SAFE_INTEGER)), 4 & e.$$.dirty[1] && null !== H && xe(H), 61440 & e.$$.dirty[1] && o(42, d = h || (g || v < 1 ? m : 1)), 2560 & e.$$.dirty[1] && o(39, (t = a.map((([e]) => e)), $ = d, c = t.findIndex((e => e === $)))), 2048 & e.$$.dirty[1] && o(41, u = dm(d) + "%"), 405045248 & e.$$.dirty[0] | 6080 & e.$$.dirty[1] && o(12, j = (P || P) && E ? [["Button", "zoom-out", {
            hideLabel: !0,
            label: C.labelZoomOut,
            icon: C.iconZoomOut,
            disabled: h === s,
            onclick: () => be((e => Math.max(s, e - B))),
            onhold: () => be((e => Math.max(s, e * (1 - O))))
        }], ["Dropdown", "zoom-level", {
            label: u,
            title: C.labelZoom,
            labelClass: "PinturaFixedWidthCharacters",
            options: a,
            selectedIndex: c,
            onchange: e => xe(e.value)
        }], ["Button", "zoom-in", {
            hideLabel: !0,
            label: C.labelZoomIn,
            icon: C.iconZoomIn,
            disabled: h === l,
            onclick: () => be((e => Math.min(l, e + B))),
            onhold: () => be((e => Math.min(l, e * (1 + O))))
        }]] : []), 16384 & e.$$.dirty[0] | 32 & e.$$.dirty[1] && k && Ze(i), 16384 & e.$$.dirty[0] | 16 & e.$$.dirty[1] && k && Xe(n), 8404992 & e.$$.dirty[0] | 24 & e.$$.dirty[1] && k && k.style.setProperty("--cursor", n && L ? ne ? "grabbing" : "grab" : "")
    }, [G, Z, X, Y, q, K, J, Q, ee, te, oe, ie, j, U, k, C, T, M, P, R, I, E, A, L, F, z, D, B, O, W, V, _, N, H, ne, n, i, l, s, c, a, u, d, h, m, g, v]
}

class mm extends Ga {
    constructor(e) {
        super(), Ua(this, e, pm, null, lr, {
            root: 14,
            locale: 15,
            stores: 16,
            allowPan: 17,
            allowZoom: 18,
            enablePan: 19,
            enableZoom: 20,
            enableZoomControls: 21,
            enableZoomInput: 22,
            enablePanInput: 23,
            enablePanLimit: 24,
            panLimitGutterScalar: 25,
            zoomOptions: 26,
            zoomAdjustStep: 27,
            zoomAdjustFactor: 28,
            zoomAdjustWheelFactor: 29,
            elasticity: 30,
            imageSelectionRectCentered: 31,
            imageSelectionRectScalar: 32,
            zoomLevel: 33,
            zoomControls: 12,
            zoomMultiTouching: 13
        }, null, [-1, -1, -1, -1])
    }
}

const {window: gm} = za;

function $m(e) {
    let t, o, i, n = e[41] && fm(e), r = e[38] && Tm(e);
    return {
        c() {
            n && n.c(), t = Br(), r && r.c(), o = Or()
        }, m(e, a) {
            n && n.m(e, a), Ar(e, t, a), r && r.m(e, a), Ar(e, o, a), i = !0
        }, p(e, i) {
            e[41] ? n ? (n.p(e, i), 1024 & i[1] && Ea(n, 1)) : (n = fm(e), n.c(), Ea(n, 1), n.m(t.parentNode, t)) : n && (Ra(), Aa(n, 1, 1, (() => {
                n = null
            })), Ia()), e[38] ? r ? (r.p(e, i), 128 & i[1] && Ea(r, 1)) : (r = Tm(e), r.c(), Ea(r, 1), r.m(o.parentNode, o)) : r && (Ra(), Aa(r, 1, 1, (() => {
                r = null
            })), Ia())
        }, i(e) {
            i || (Ea(n), Ea(r), i = !0)
        }, o(e) {
            Aa(n), Aa(r), i = !1
        }, d(e) {
            n && n.d(e), e && Lr(t), r && r.d(e), e && Lr(o)
        }
    }
}

function fm(e) {
    let t, o, i, n, r;
    const a = [bm, ym], s = [];

    function l(e, t) {
        return e[39] ? 0 : e[35] ? 1 : -1
    }

    return ~(i = l(e)) && (n = s[i] = a[i](e)), {
        c() {
            t = Fr("div"), o = Fr("p"), n && n.c(), Zr(o, "transform", e[72]), Nr(t, "class", "PinturaStatus"), Zr(t, "opacity", e[54])
        }, m(e, n) {
            Ar(e, t, n), Rr(t, o), ~i && s[i].m(o, null), r = !0
        }, p(e, r) {
            let c = i;
            i = l(e), i === c ? ~i && s[i].p(e, r) : (n && (Ra(), Aa(s[c], 1, 1, (() => {
                s[c] = null
            })), Ia()), ~i ? (n = s[i], n ? n.p(e, r) : (n = s[i] = a[i](e), n.c()), Ea(n, 1), n.m(o, null)) : n = null), 1024 & r[2] && Zr(o, "transform", e[72]), 8388608 & r[1] && Zr(t, "opacity", e[54])
        }, i(e) {
            r || (Ea(n), r = !0)
        }, o(e) {
            Aa(n), r = !1
        }, d(e) {
            e && Lr(t), ~i && s[i].d()
        }
    }
}

function ym(e) {
    let t, o, i, n;
    t = new Fp({props: {text: e[35].text || "", onmeasure: e[221]}});
    let r = e[35].aside && xm(e);
    return {
        c() {
            Na(t.$$.fragment), o = Br(), r && r.c(), i = Or()
        }, m(e, a) {
            Ha(t, e, a), Ar(e, o, a), r && r.m(e, a), Ar(e, i, a), n = !0
        }, p(e, o) {
            const n = {};
            16 & o[1] && (n.text = e[35].text || ""), t.$set(n), e[35].aside ? r ? (r.p(e, o), 16 & o[1] && Ea(r, 1)) : (r = xm(e), r.c(), Ea(r, 1), r.m(i.parentNode, i)) : r && (Ra(), Aa(r, 1, 1, (() => {
                r = null
            })), Ia())
        }, i(e) {
            n || (Ea(t.$$.fragment, e), Ea(r), n = !0)
        }, o(e) {
            Aa(t.$$.fragment, e), Aa(r), n = !1
        }, d(e) {
            ja(t, e), e && Lr(o), r && r.d(e), e && Lr(i)
        }
    }
}

function bm(e) {
    let t, o, i, n;
    return t = new Fp({props: {text: e[39], onmeasure: e[221]}}), i = new Bp({
        props: {
            class: "PinturaStatusIcon",
            offset: e[82],
            opacity: e[83],
            $$slots: {default: [Cm]},
            $$scope: {ctx: e}
        }
    }), {
        c() {
            Na(t.$$.fragment), o = Br(), Na(i.$$.fragment)
        }, m(e, r) {
            Ha(t, e, r), Ar(e, o, r), Ha(i, e, r), n = !0
        }, p(e, o) {
            const n = {};
            256 & o[1] && (n.text = e[39]), t.$set(n);
            const r = {};
            1048576 & o[2] && (r.offset = e[82]), 2097152 & o[2] && (r.opacity = e[83]), 8 & o[0] | 134217728 & o[19] && (r.$$scope = {
                dirty: o,
                ctx: e
            }), i.$set(r)
        }, i(e) {
            n || (Ea(t.$$.fragment, e), Ea(i.$$.fragment, e), n = !0)
        }, o(e) {
            Aa(t.$$.fragment, e), Aa(i.$$.fragment, e), n = !1
        }, d(e) {
            ja(t, e), e && Lr(o), ja(i, e)
        }
    }
}

function xm(e) {
    let t, o;
    return t = new Bp({
        props: {
            class: "PinturaStatusButton",
            offset: e[82],
            opacity: e[83],
            $$slots: {default: [Sm]},
            $$scope: {ctx: e}
        }
    }), {
        c() {
            Na(t.$$.fragment)
        }, m(e, i) {
            Ha(t, e, i), o = !0
        }, p(e, o) {
            const i = {};
            1048576 & o[2] && (i.offset = e[82]), 2097152 & o[2] && (i.opacity = e[83]), 16 & o[1] | 134217728 & o[19] && (i.$$scope = {
                dirty: o,
                ctx: e
            }), t.$set(i)
        }, i(e) {
            o || (Ea(t.$$.fragment, e), o = !0)
        }, o(e) {
            Aa(t.$$.fragment, e), o = !1
        }, d(e) {
            ja(t, e)
        }
    }
}

function vm(e) {
    let t, o;
    return t = new Th({props: {progress: e[35].progressIndicator.progress}}), {
        c() {
            Na(t.$$.fragment)
        }, m(e, i) {
            Ha(t, e, i), o = !0
        }, p(e, o) {
            const i = {};
            16 & o[1] && (i.progress = e[35].progressIndicator.progress), t.$set(i)
        }, i(e) {
            o || (Ea(t.$$.fragment, e), o = !0)
        }, o(e) {
            Aa(t.$$.fragment, e), o = !1
        }, d(e) {
            ja(t, e)
        }
    }
}

function wm(e) {
    let t, o;
    const i = [e[35].closeButton, {hideLabel: !0}];
    let n = {};
    for (let e = 0; e < i.length; e += 1) n = ir(n, i[e]);
    return t = new xp({props: n}), {
        c() {
            Na(t.$$.fragment)
        }, m(e, i) {
            Ha(t, e, i), o = !0
        }, p(e, o) {
            const n = 16 & o[1] ? Wa(i, [Va(e[35].closeButton), i[1]]) : {};
            t.$set(n)
        }, i(e) {
            o || (Ea(t.$$.fragment, e), o = !0)
        }, o(e) {
            Aa(t.$$.fragment, e), o = !1
        }, d(e) {
            ja(t, e)
        }
    }
}

function Sm(e) {
    let t, o, i, n = e[35].progressIndicator.visible && vm(e), r = e[35].closeButton && e[35].text && wm(e);
    return {
        c() {
            n && n.c(), t = Br(), r && r.c(), o = Or()
        }, m(e, a) {
            n && n.m(e, a), Ar(e, t, a), r && r.m(e, a), Ar(e, o, a), i = !0
        }, p(e, i) {
            e[35].progressIndicator.visible ? n ? (n.p(e, i), 16 & i[1] && Ea(n, 1)) : (n = vm(e), n.c(), Ea(n, 1), n.m(t.parentNode, t)) : n && (Ra(), Aa(n, 1, 1, (() => {
                n = null
            })), Ia()), e[35].closeButton && e[35].text ? r ? (r.p(e, i), 16 & i[1] && Ea(r, 1)) : (r = wm(e), r.c(), Ea(r, 1), r.m(o.parentNode, o)) : r && (Ra(), Aa(r, 1, 1, (() => {
                r = null
            })), Ia())
        }, i(e) {
            i || (Ea(n), Ea(r), i = !0)
        }, o(e) {
            Aa(n), Aa(r), i = !1
        }, d(e) {
            n && n.d(e), e && Lr(t), r && r.d(e), e && Lr(o)
        }
    }
}

function km(e) {
    let t, o = e[3].iconSupportError + "";
    return {
        c() {
            t = zr("g")
        }, m(e, i) {
            Ar(e, t, i), t.innerHTML = o
        }, p(e, i) {
            8 & i[0] && o !== (o = e[3].iconSupportError + "") && (t.innerHTML = o)
        }, d(e) {
            e && Lr(t)
        }
    }
}

function Cm(e) {
    let t, o;
    return t = new wd({props: {$$slots: {default: [km]}, $$scope: {ctx: e}}}), {
        c() {
            Na(t.$$.fragment)
        }, m(e, i) {
            Ha(t, e, i), o = !0
        }, p(e, o) {
            const i = {};
            8 & o[0] | 134217728 & o[19] && (i.$$scope = {dirty: o, ctx: e}), t.$set(i)
        }, i(e) {
            o || (Ea(t.$$.fragment, e), o = !0)
        }, o(e) {
            Aa(t.$$.fragment, e), o = !1
        }, d(e) {
            ja(t, e)
        }
    }
}

function Tm(e) {
    let t, o, i, n, r, a, s, l, c, d, u, h, p, m, g = e[10] && Mm(e), $ = e[46] && e[45] && Pm(e);
    const f = [zm, Fm], y = [];

    function b(e, t) {
        return e[46] ? 0 : 1
    }

    function x(t) {
        e[444](t)
    }

    function v(t) {
        e[445](t)
    }

    function w(t) {
        e[446](t)
    }

    i = b(e), n = y[i] = f[i](e), a = new Gc({
        props: {
            isAnimated: e[53],
            isTransparent: e[20],
            pixelRatio: e[57],
            textPixelRatio: e[6],
            backgroundColor: e[56],
            maskRect: e[58],
            maskOpacity: e[73] ? e[73].maskOpacity : 1,
            maskMarkupOpacity: e[7],
            maskFrameOpacity: e[5],
            clipAnnotationsToImage: e[85],
            images: e[55],
            interfaceImages: e[86],
            loadImageData: e[28],
            enableGrid: e[11],
            gridSize: e[87],
            gridColors: [e[88], e[89]],
            gridOpacity: e[90],
            selectionColor: e[91],
            csp: e[92] || {},
            willRequest: e[81] || e[93],
            willRender: e[441],
            didRender: e[442]
        }
    });
    let S = {
        root: e[2],
        locale: e[3],
        stores: e[202],
        allowPan: e[95],
        enablePan: e[17],
        enablePanLimit: e[21],
        panLimitGutterScalar: e[22],
        enablePanInput: e[96],
        allowZoom: e[97],
        enableZoom: e[18],
        enableZoomInput: void 0 !== e[19] ? e[19] : e[98],
        enableZoomControls: e[99],
        zoomOptions: e[13] || e[23],
        zoomAdjustStep: e[14] || e[24],
        zoomAdjustFactor: e[15] || e[25],
        zoomAdjustWheelFactor: e[16] || e[26],
        imageSelectionRectCentered: e[100],
        imageSelectionRectScalar: e[101],
        elasticity: _m * e[8]
    };
    return void 0 !== e[0] && (S.zoomLevel = e[0]), void 0 !== e[33] && (S.zoomControls = e[33]), void 0 !== e[34] && (S.zoomMultiTouching = e[34]), d = new mm({props: S}), ha.push((() => _a(d, "zoomLevel", x))), ha.push((() => _a(d, "zoomControls", v))), ha.push((() => _a(d, "zoomMultiTouching", w))), {
        c() {
            g && g.c(), t = Br(), $ && $.c(), o = Br(), n.c(), r = Br(), Na(a.$$.fragment), s = Br(), l = Fr("div"), c = Br(), Na(d.$$.fragment), Nr(l, "class", "PinturaRootPortal")
        }, m(n, u) {
            g && g.m(n, u), Ar(n, t, u), $ && $.m(n, u), Ar(n, o, u), y[i].m(n, u), Ar(n, r, u), Ha(a, n, u), Ar(n, s, u), Ar(n, l, u), e[443](l), Ar(n, c, u), Ha(d, n, u), m = !0
        }, p(e, s) {
            e[10] ? g ? (g.p(e, s), 1024 & s[0] && Ea(g, 1)) : (g = Mm(e), g.c(), Ea(g, 1), g.m(t.parentNode, t)) : g && (Ra(), Aa(g, 1, 1, (() => {
                g = null
            })), Ia()), e[46] && e[45] ? $ ? ($.p(e, s), 49152 & s[1] && Ea($, 1)) : ($ = Pm(e), $.c(), Ea($, 1), $.m(o.parentNode, o)) : $ && (Ra(), Aa($, 1, 1, (() => {
                $ = null
            })), Ia());
            let l = i;
            i = b(e), i === l ? y[i].p(e, s) : (Ra(), Aa(y[l], 1, 1, (() => {
                y[l] = null
            })), Ia(), n = y[i], n ? n.p(e, s) : (n = y[i] = f[i](e), n.c()), Ea(n, 1), n.m(r.parentNode, r));
            const c = {};
            4194304 & s[1] && (c.isAnimated = e[53]), 1048576 & s[0] && (c.isTransparent = e[20]), 67108864 & s[1] && (c.pixelRatio = e[57]), 64 & s[0] && (c.textPixelRatio = e[6]), 33554432 & s[1] && (c.backgroundColor = e[56]), 134217728 & s[1] && (c.maskRect = e[58]), 2048 & s[2] && (c.maskOpacity = e[73] ? e[73].maskOpacity : 1), 128 & s[0] && (c.maskMarkupOpacity = e[7]), 32 & s[0] && (c.maskFrameOpacity = e[5]), 8388608 & s[2] && (c.clipAnnotationsToImage = e[85]), 16777216 & s[1] && (c.images = e[55]), 16777216 & s[2] && (c.interfaceImages = e[86]), 268435456 & s[0] && (c.loadImageData = e[28]), 2048 & s[0] && (c.enableGrid = e[11]), 33554432 & s[2] && (c.gridSize = e[87]), 201326592 & s[2] && (c.gridColors = [e[88], e[89]]), 268435456 & s[2] && (c.gridOpacity = e[90]), 536870912 & s[2] && (c.selectionColor = e[91]), 1073741824 & s[2] && (c.csp = e[92] || {}), 524288 & s[2] | 1 & s[3] && (c.willRequest = e[81] || e[93]), 512 & s[0] | 270991424 & s[1] | 2 & s[3] && (c.willRender = e[441]), 62 & s[2] && (c.didRender = e[442]), a.$set(c);
            const m = {};
            4 & s[0] && (m.root = e[2]), 8 & s[0] && (m.locale = e[3]), 4 & s[3] && (m.allowPan = e[95]), 131072 & s[0] && (m.enablePan = e[17]), 2097152 & s[0] && (m.enablePanLimit = e[21]), 4194304 & s[0] && (m.panLimitGutterScalar = e[22]), 8 & s[3] && (m.enablePanInput = e[96]), 16 & s[3] && (m.allowZoom = e[97]), 262144 & s[0] && (m.enableZoom = e[18]), 524288 & s[0] | 32 & s[3] && (m.enableZoomInput = void 0 !== e[19] ? e[19] : e[98]), 64 & s[3] && (m.enableZoomControls = e[99]), 8396800 & s[0] && (m.zoomOptions = e[13] || e[23]), 16793600 & s[0] && (m.zoomAdjustStep = e[14] || e[24]), 33587200 & s[0] && (m.zoomAdjustFactor = e[15] || e[25]), 67174400 & s[0] && (m.zoomAdjustWheelFactor = e[16] || e[26]), 128 & s[3] && (m.imageSelectionRectCentered = e[100]), 256 & s[3] && (m.imageSelectionRectScalar = e[101]), 256 & s[0] && (m.elasticity = _m * e[8]), !u && 1 & s[0] && (u = !0, m.zoomLevel = e[0], xa((() => u = !1))), !h && 4 & s[1] && (h = !0, m.zoomControls = e[33], xa((() => h = !1))), !p && 8 & s[1] && (p = !0, m.zoomMultiTouching = e[34], xa((() => p = !1))), d.$set(m)
        }, i(e) {
            m || (Ea(g), Ea($), Ea(n), Ea(a.$$.fragment, e), Ea(d.$$.fragment, e), m = !0)
        }, o(e) {
            Aa(g), Aa($), Aa(n), Aa(a.$$.fragment, e), Aa(d.$$.fragment, e), m = !1
        }, d(n) {
            g && g.d(n), n && Lr(t), $ && $.d(n), n && Lr(o), y[i].d(n), n && Lr(r), ja(a, n), n && Lr(s), n && Lr(l), e[443](null), n && Lr(c), ja(d, n)
        }
    }
}

function Mm(e) {
    let t, o, i, n, r;
    return o = new pp({props: {items: e[69]}}), {
        c() {
            t = Fr("div"), Na(o.$$.fragment), Nr(t, "class", "PinturaNav PinturaNavTools")
        }, m(a, s) {
            Ar(a, t, s), Ha(o, t, null), i = !0, n || (r = [Wr(t, "measure", e[430]), wr(zc.call(null, t))], n = !0)
        }, p(e, t) {
            const i = {};
            128 & t[2] && (i.items = e[69]), o.$set(i)
        }, i(e) {
            i || (Ea(o.$$.fragment, e), i = !0)
        }, o(e) {
            Aa(o.$$.fragment, e), i = !1
        }, d(e) {
            e && Lr(t), ja(o), n = !1, ar(r)
        }
    }
}

function Pm(e) {
    let t, o, i;
    return o = new Ep({
        props: {
            elasticity: e[8] * Nm,
            scrollDirection: e[76] ? "y" : "x",
            $$slots: {default: [Lm]},
            $$scope: {ctx: e}
        }
    }), {
        c() {
            t = Fr("div"), Na(o.$$.fragment), Nr(t, "class", "PinturaNav PinturaNavMain")
        }, m(e, n) {
            Ar(e, t, n), Ha(o, t, null), i = !0
        }, p(e, t) {
            const i = {};
            256 & t[0] && (i.elasticity = e[8] * Nm), 16384 & t[2] && (i.scrollDirection = e[76] ? "y" : "x"), 12288 & t[1] | 135168 & t[2] | 134217728 & t[19] && (i.$$scope = {
                dirty: t,
                ctx: e
            }), o.$set(i)
        }, i(e) {
            i || (Ea(o.$$.fragment, e), i = !0)
        }, o(e) {
            Aa(o.$$.fragment, e), i = !1
        }, d(e) {
            e && Lr(t), ja(o)
        }
    }
}

function Rm(e) {
    let t, o;
    const i = [e[79], {tabs: e[44]}];
    let n = {
        $$slots: {default: [Am, ({tab: e}) => ({615: e}), ({tab: e}) => [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, e ? 67108864 : 0]]},
        $$scope: {ctx: e}
    };
    for (let e = 0; e < i.length; e += 1) n = ir(n, i[e]);
    return t = new td({props: n}), t.$on("select", e[431]), {
        c() {
            Na(t.$$.fragment)
        }, m(e, i) {
            Ha(t, e, i), o = !0
        }, p(e, o) {
            const n = 8192 & o[1] | 131072 & o[2] ? Wa(i, [131072 & o[2] && Va(e[79]), 8192 & o[1] && {tabs: e[44]}]) : {};
            201326592 & o[19] && (n.$$scope = {dirty: o, ctx: e}), t.$set(n)
        }, i(e) {
            o || (Ea(t.$$.fragment, e), o = !0)
        }, o(e) {
            Aa(t.$$.fragment, e), o = !1
        }, d(e) {
            ja(t, e)
        }
    }
}

function Im(e) {
    let t, o;
    return t = new pp({props: {items: e[44]}}), {
        c() {
            Na(t.$$.fragment)
        }, m(e, i) {
            Ha(t, e, i), o = !0
        }, p(e, o) {
            const i = {};
            8192 & o[1] && (i.items = e[44]), t.$set(i)
        }, i(e) {
            o || (Ea(t.$$.fragment, e), o = !0)
        }, o(e) {
            Aa(t.$$.fragment, e), o = !1
        }, d(e) {
            ja(t, e)
        }
    }
}

function Em(e) {
    let t, o = e[615].icon + "";
    return {
        c() {
            t = zr("g")
        }, m(e, i) {
            Ar(e, t, i), t.innerHTML = o
        }, p(e, i) {
            67108864 & i[19] && o !== (o = e[615].icon + "") && (t.innerHTML = o)
        }, d(e) {
            e && Lr(t)
        }
    }
}

function Am(e) {
    let t, o, i, n, r, a = e[615].label + "";
    return t = new wd({props: {$$slots: {default: [Em]}, $$scope: {ctx: e}}}), {
        c() {
            Na(t.$$.fragment), o = Br(), i = Fr("span"), n = Dr(a)
        }, m(e, a) {
            Ha(t, e, a), Ar(e, o, a), Ar(e, i, a), Rr(i, n), r = !0
        }, p(e, o) {
            const i = {};
            201326592 & o[19] && (i.$$scope = {
                dirty: o,
                ctx: e
            }), t.$set(i), (!r || 67108864 & o[19]) && a !== (a = e[615].label + "") && Ur(n, a)
        }, i(e) {
            r || (Ea(t.$$.fragment, e), r = !0)
        }, o(e) {
            Aa(t.$$.fragment, e), r = !1
        }, d(e) {
            ja(t, e), e && Lr(o), e && Lr(i)
        }
    }
}

function Lm(e) {
    let t, o, i, n;
    const r = [Im, Rm], a = [];

    function s(e, t) {
        return e[74] ? 0 : 1
    }

    return t = s(e), o = a[t] = r[t](e), {
        c() {
            o.c(), i = Or()
        }, m(e, o) {
            a[t].m(e, o), Ar(e, i, o), n = !0
        }, p(e, n) {
            let l = t;
            t = s(e), t === l ? a[t].p(e, n) : (Ra(), Aa(a[l], 1, 1, (() => {
                a[l] = null
            })), Ia(), o = a[t], o ? o.p(e, n) : (o = a[t] = r[t](e), o.c()), Ea(o, 1), o.m(i.parentNode, i))
        }, i(e) {
            n || (Ea(o), n = !0)
        }, o(e) {
            Aa(o), n = !1
        }, d(e) {
            a[t].d(e), e && Lr(i)
        }
    }
}

function Fm(e) {
    let t, o, i;

    function n(t) {
        e[437](t)
    }

    let r = {locale: e[3], class: "PinturaMain", view: e[207](e[43]), props: e[206](e[43], e[27]), stores: e[202]};
    return void 0 !== e[1][e[43]] && (r.component = e[1][e[43]]), t = new bd({props: r}), ha.push((() => _a(t, "component", n))), t.$on("measure", e[233]), t.$on("show", e[438]), t.$on("hide", e[439]), t.$on("fade", e[440]), {
        c() {
            Na(t.$$.fragment)
        }, m(e, o) {
            Ha(t, e, o), i = !0
        }, p(e, i) {
            const n = {};
            8 & i[0] && (n.locale = e[3]), 4096 & i[1] && (n.view = e[207](e[43])), 134217728 & i[0] | 4096 & i[1] && (n.props = e[206](e[43], e[27])), !o && 2 & i[0] | 4096 & i[1] && (o = !0, n.component = e[1][e[43]], xa((() => o = !1))), t.$set(n)
        }, i(e) {
            i || (Ea(t.$$.fragment, e), i = !0)
        }, o(e) {
            Aa(t.$$.fragment, e), i = !1
        }, d(e) {
            ja(t, e)
        }
    }
}

function zm(e) {
    let t, o;
    const i = [{class: "PinturaMain"}, {visible: e[62]}, e[79], {panels: e[78]}];
    let n = {
        $$slots: {
            default: [Dm, ({panel: e, panelIsActive: t}) => ({613: e, 614: t}), ({
                                                                                     panel: e,
                                                                                     panelIsActive: t
                                                                                 }) => [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (e ? 16777216 : 0) | (t ? 33554432 : 0)]]
        }, $$scope: {ctx: e}
    };
    for (let e = 0; e < i.length; e += 1) n = ir(n, i[e]);
    return t = new md({props: n}), t.$on("measure", e[436]), {
        c() {
            Na(t.$$.fragment)
        }, m(e, i) {
            Ha(t, e, i), o = !0
        }, p(e, o) {
            const n = 196609 & o[2] ? Wa(i, [i[0], 1 & o[2] && {visible: e[62]}, 131072 & o[2] && Va(e[79]), 65536 & o[2] && {panels: e[78]}]) : {};
            134217738 & o[0] | 184549376 & o[19] && (n.$$scope = {dirty: o, ctx: e}), t.$set(n)
        }, i(e) {
            o || (Ea(t.$$.fragment, e), o = !0)
        }, o(e) {
            Aa(t.$$.fragment, e), o = !1
        }, d(e) {
            ja(t, e)
        }
    }
}

function Dm(e) {
    let t, o, i;

    function n(t) {
        e[432](t, e[613])
    }

    let r = {locale: e[3], view: e[207](e[613]), props: e[206](e[613], e[27]), isActive: e[614], stores: e[202]};
    return void 0 !== e[1][e[613]] && (r.component = e[1][e[613]]), t = new bd({props: r}), ha.push((() => _a(t, "component", n))), t.$on("measure", e[233]), t.$on("show", (function () {
        return e[433](e[613])
    })), t.$on("hide", (function () {
        return e[434](e[613])
    })), t.$on("fade", (function (...t) {
        return e[435](e[613], ...t)
    })), {
        c() {
            Na(t.$$.fragment)
        }, m(e, o) {
            Ha(t, e, o), i = !0
        }, p(i, n) {
            e = i;
            const r = {};
            8 & n[0] && (r.locale = e[3]), 16777216 & n[19] && (r.view = e[207](e[613])), 134217728 & n[0] | 16777216 & n[19] && (r.props = e[206](e[613], e[27])), 33554432 & n[19] && (r.isActive = e[614]), !o && 2 & n[0] | 16777216 & n[19] && (o = !0, r.component = e[1][e[613]], xa((() => o = !1))), t.$set(r)
        }, i(e) {
            i || (Ea(t.$$.fragment, e), i = !0)
        }, o(e) {
            Aa(t.$$.fragment, e), i = !1
        }, d(e) {
            ja(t, e)
        }
    }
}

function Bm(e) {
    let t;
    return {
        c() {
            t = Fr("span"), Nr(t, "class", "PinturaEditorOverlay"), Zr(t, "opacity", e[102])
        }, m(e, o) {
            Ar(e, t, o)
        }, p(e, o) {
            512 & o[3] && Zr(t, "opacity", e[102])
        }, d(e) {
            e && Lr(t)
        }
    }
}

function Om(e) {
    let t, o;
    const i = [{layout: "row"}, {parentRect: e[50]}, e[60]];
    let n = {$$slots: {default: [Wm]}, $$scope: {ctx: e}};
    for (let e = 0; e < i.length; e += 1) n = ir(n, i[e]);
    return t = new jp({props: n}), {
        c() {
            Na(t.$$.fragment)
        }, m(e, i) {
            Ha(t, e, i), o = !0
        }, p(e, o) {
            const n = 537395200 & o[1] ? Wa(i, [i[0], 524288 & o[1] && {parentRect: e[50]}, 536870912 & o[1] && Va(e[60])]) : {};
            1610612736 & o[1] | 134217728 & o[19] && (n.$$scope = {dirty: o, ctx: e}), t.$set(n)
        }, i(e) {
            o || (Ea(t.$$.fragment, e), o = !0)
        }, o(e) {
            Aa(t.$$.fragment, e), o = !1
        }, d(e) {
            ja(t, e)
        }
    }
}

function Wm(e) {
    let t, o, i;
    return {
        c() {
            t = Fr("input"), t.value = o = e[60].text, Nr(t, "placeholder", i = e[60].placeholder), Nr(t, "type", "text"), Nr(t, "spellcheck", "false"), Nr(t, "autocorrect", "off"), Nr(t, "autocapitalize", "off")
        }, m(o, i) {
            Ar(o, t, i), e[447](t)
        }, p(e, n) {
            536870912 & n[1] && o !== (o = e[60].text) && t.value !== o && (t.value = o), 536870912 & n[1] && i !== (i = e[60].placeholder) && Nr(t, "placeholder", i)
        }, d(o) {
            o && Lr(t), e[447](null)
        }
    }
}

function Vm(e) {
    let t, o, n, r, a, s;
    ba(e[429]);
    let l = e[40] && $m(e), c = e[102] > 0 && Bm(e), d = e[60] && Om(e);
    return {
        c() {
            t = Fr("div"), l && l.c(), o = Br(), c && c.c(), n = Br(), d && d.c(), Nr(t, "id", e[4]), Nr(t, "class", e[77]), Nr(t, "data-env", e[75]), Nr(t, "dir", e[12])
        }, m(u, h) {
            Ar(u, t, h), l && l.m(t, null), Rr(t, o), c && c.m(t, null), Rr(t, n), d && d.m(t, null), e[448](t), r = !0, a || (s = [Wr(gm, "keydown", e[224]), Wr(gm, "keyup", e[225]), Wr(gm, "blur", e[226]), Wr(gm, "paste", e[230]), Wr(gm, "resize", e[429]), Wr(t, "ping", (function () {
                sr(e[68]) && e[68].apply(this, arguments)
            })), Wr(t, "contextmenu", e[227]), Wr(t, "touchstart", e[222], {passive: !1}), Wr(t, "touchmove", (function () {
                sr(e[71]) && e[71].apply(this, arguments)
            })), Wr(t, "pointermove", (function () {
                sr(e[70]) && e[70].apply(this, arguments)
            })), Wr(t, "transitionend", e[212]), Wr(t, "dropfiles", e[228]), Wr(t, "measure", e[449]), Wr(t, "click", (function () {
                sr(e[42] ? e[229] : i) && (e[42] ? e[229] : i).apply(this, arguments)
            })), wr(zc.call(null, t, {
                observeViewRect: !0,
                isMeasureRoot: !0
            })), wr(Dc.call(null, t)), wr(Wc.call(null, t))], a = !0)
        }, p(i, a) {
            (e = i)[40] ? l ? (l.p(e, a), 512 & a[1] && Ea(l, 1)) : (l = $m(e), l.c(), Ea(l, 1), l.m(t, o)) : l && (Ra(), Aa(l, 1, 1, (() => {
                l = null
            })), Ia()), e[102] > 0 ? c ? c.p(e, a) : (c = Bm(e), c.c(), c.m(t, n)) : c && (c.d(1), c = null), e[60] ? d ? (d.p(e, a), 536870912 & a[1] && Ea(d, 1)) : (d = Om(e), d.c(), Ea(d, 1), d.m(t, null)) : d && (Ra(), Aa(d, 1, 1, (() => {
                d = null
            })), Ia()), (!r || 16 & a[0]) && Nr(t, "id", e[4]), (!r || 32768 & a[2]) && Nr(t, "class", e[77]), (!r || 8192 & a[2]) && Nr(t, "data-env", e[75]), (!r || 4096 & a[0]) && Nr(t, "dir", e[12])
        }, i(e) {
            r || (Ea(l), Ea(d), r = !0)
        }, o(e) {
            Aa(l), Aa(d), r = !1
        }, d(o) {
            o && Lr(t), l && l.d(), c && c.d(), d && d.d(), e[448](null), a = !1, ar(s)
        }
    }
}

const _m = 1, Nm = 10;

function Hm(e, t, o) {
    let n, r, a, s, c, d, p, m, g, f, y, b, w, S, k, C, T, P, R, I, A, L, F, D, B, O, W, V, _, N, H, j, U, G, X, Y, q,
        K, J, Q, ee, te, oe, ie, ne, re, ae, se, ce, de, pe, me, ge, $e, fe, ye, be, xe, we, Se, ke, Ce, Te, Me, Pe, Re,
        Ie, Ee, Ae, Le, Fe, ze, De, Be, Oe, We, _e, Ne, He, je, Ue, Ge, Ze, Xe, Ye, qe, Ke, tt, ot, nt, rt, st, dt, ut,
        gt, $t, bt, xt, St, Ct, Mt, Pt, Rt, It, Et, At, Lt, Ft, zt, Dt, Bt, Ot, Wt, Vt, _t, jt, Ut, Gt, Zt, Xt, Yt, qt,
        Jt, Qt, eo, to, oo, io, no, ro, ao, so, lo, co, uo, ho, mo, go, $o, fo, yo, xo, vo, wo, So, ko, Co, To, Mo, Po,
        Ro, Io, Eo, Ao, Lo, Fo, Do, Bo, Oo, Wo, Vo, _o, No, Ho, Uo, Go, Zo, Xo, Yo, qo, Jo, Qo, ei, ti, oi, ii, ni, ri,
        ai, si, li, ci, di, ui, hi, pi, mi, gi, $i, fi, bi, xi, vi, wi, Si, ki, Mi, Pi, Ri, Ei, Ai, Fi, zi, Bi, Oi, Wi,
        Vi, _i, Ni, Hi, ji, Ui, Gi, Zi, Xi, Yi = tr, qi = tr;
    pr(e, xc, (e => o(417, ii = e))), e.$$.on_destroy.push((() => Yi())), e.$$.on_destroy.push((() => qi()));
    const Ki = Ko(), Ji = sa();
    let {class: Qi} = t, {layout: en} = t, {stores: tn} = t, {locale: on} = t, {id: nn} = t, {util: rn} = t, {utils: an} = t, {animations: sn = "auto"} = t, {disabled: ln = !1} = t, {previewUpscale: cn = !1} = t, {previewPad: dn = !1} = t, {previewMaskOpacity: un = .95} = t, {previewImageDataMaxSize: hn} = t, {previewImageTextPixelRatio: pn} = t, {markupMaskOpacity: mn = 1} = t, {zoomMaskOpacity: gn = .85} = t, {elasticityMultiplier: $n = 10} = t, {willRevert: fn = (() => Promise.resolve(!0))} = t, {willProcessImage: yn = (() => Promise.resolve(!0))} = t, {willRenderCanvas: bn = Z} = t, {willRenderToolbar: vn = Z} = t, {willRenderUtilTabs: wn = Z} = t, {willSetHistoryInitialState: Sn = Z} = t, {enableButtonExport: kn = !0} = t, {enableButtonRevert: Mn = !0} = t, {enableNavigateHistory: Pn = !0} = t, {enableToolbar: Rn = !0} = t, {enableUtils: In = !0} = t, {enableButtonClose: En = !1} = t, {enableDropImage: Ln = !1} = t, {enablePasteImage: Fn = !1} = t, {enableBrowseImage: zn = !1} = t, {enableTransparencyGrid: Dn = !1} = t, {layoutDirectionPreference: Bn = "auto"} = t, {layoutHorizontalUtilsPreference: On = "left"} = t, {layoutVerticalUtilsPreference: Wn = "bottom"} = t, {layoutVerticalToolbarPreference: Vn = "top"} = t, {layoutVerticalControlGroupsPreference: _n = "bottom"} = t, {layoutVerticalControlTabsPreference: Nn = "bottom"} = t, {status: Hn} = t, {
        formatStatusImageLoading: jn = function (e, t) {
            const {state: o} = e;
            if (!o || !o.task) return t.statusImageLoadNone;
            if (o.error) {
                if ("IMAGE_TOO_SMALL" === o.error.code) return t.statusImageLoadMinSize;
                if ("VIDEO_TOO_SHORT" === o.error.code) {
                    const e = Array.isArray(t.unitSeconds) ? 1 === o.error.metadata.minDuration ? t.unitSeconds[0] : t.unitSeconds[1] : t.unitSeconds;
                    return Pl(t.statusImageLoadMinDuration, {seconds: e}, "{", "}")
                }
                return t.statusImageLoadError
            }
            return "blob-to-bitmap" === o.task ? t.statusImageLoadPrepare : t.statusImageLoadBusy
        }
    } = t, {
        formatStatusImageProcessing: Un = function (e, t) {
            const {state: o} = e;
            if (o && o.task) return "store" === o.task ? o.error ? t.statusImageUploadError : t.statusImageUploadBusy : o.error ? t.statusImageProcessError : t.statusImageProcessBusy
        }
    } = t, {
        formatStatusSupportError: Gn = function (e, t) {
            const {features: o} = e;
            return {features: o.join(", ")}
        }
    } = t, {textDirection: Zn} = t, {markupEditorZoomLevel: Xn = null} = t, {markupEditorZoomLevels: Yn} = t, {markupEditorZoomAdjustStep: qn} = t, {markupEditorZoomAdjustFactor: Kn} = t, {markupEditorZoomAdjustWheelFactor: Jn} = t, {markupEditorInteractionMode: or = !1} = t, {muteAudio: ir = !0} = t, {willSetMediaInitialTimeOffset: nr = ((e, t) => e * cm(t[0]))} = t, {enablePan: rr = !0} = t, {enableZoom: ar = !0} = t, {enableZoomControls: sr = !0} = t, {enableZoomInput: lr} = t, {enablePanInput: cr} = t, {enableCanvasAlpha: dr = !1} = t, {enablePanLimit: mr} = t, {panLimitGutterScalar: gr} = t, {pan: $r = null} = t, {zoomPresetOptions: fr = [.25, .5, 1, 1.25, 1.5, 2, 3, 4, 6, 8, 16]} = t, {zoomAdjustStep: yr = .25} = t, {zoomAdjustFactor: br = .1} = t, {zoomAdjustWheelFactor: xr = 1} = t, {zoomLevel: wr = null} = t, {fixScrollDirection: Sr = !1} = t;
    const kr = Ya(Sr);
    la("fixScrollDirection", kr);
    const Cr = l() && "visualViewport" in window, Tr = Ya("hidden");

    function Mr(e) {
        const {height: t, scale: o} = e.target, i = t * o / window.screen.height < .75 ? "visible" : "hidden";
        Tr.set(i)
    }

    let Pr, Rr;
    la("softKeyboardState", Tr), Cr && window.visualViewport.addEventListener("resize", Mr);
    let {imagePreviewSrc: Ir} = t, {
        imageOrienter: Er = {
            read: () => 1,
            apply: e => e
        }
    } = t, {pluginComponents: Ar} = t, {pluginOptions: Lr = {}} = t;
    const Fr = Ki.sub, zr = {};
    let {root: Dr} = t;
    const Br = () => {
        Rt.setAttribute("data-redraw", "true"), ra.set({})
    }, Or = Ya(!0);
    pr(e, Or, (e => o(483, qt = e)));
    const Wr = Ya(void 0);
    pr(e, Wr, (e => o(427, vi = e)));
    const Vr = Ya(0);
    pr(e, Vr, (e => o(424, fi = e)));
    const _r = Ya(!1), Nr = e => {
        _r.set("play" === e.type), Ki.pub(e.type)
    };
    let Hr, jr;
    let Ur, Gr, Zr = !1;
    const Xr = () => {
        if (!a || !qr()) return;
        Gr = g, vr(Wr, vi = void 0, vi);
        const e = Rt;
        Zr = !1;
        const t = 1 / 24, o = oa();
        (Math.abs(p * o - fi * o) <= t || o - o * fi <= t) && vr(Vr, fi = d, fi), na(fi * oa()), e.play().catch((() => {
        }));
        let i = ia();
        const n = () => {
            if (qr()) return;
            Ur = requestAnimationFrame(n);
            let e = ia();
            e - i <= 0 && (e = i + .01), i = e, vr(Vr, fi = e / oa(), fi), Gr >= 0 && fi >= p && (vr(Vr, fi = p, fi), Yr()), g > -1 && (Zr = !0), Zr && -1 === g && f > 0 && (vr(Vr, fi = c[f][0], fi), na(fi * oa())), vr(wa, pi = fi * oa(), pi), Br()
        };
        n()
    }, Yr = () => {
        a && !qr() && (vr(Wr, vi = void 0, vi), Gr = void 0, Rt.pause(), cancelAnimationFrame(Ur), Br())
    }, qr = () => Rt && Rt.paused, Kr = () => {
        if (a) return qr() ? Xr() : Yr()
    }, Jr = () => {
        if (!a) return;
        Rt.muted = !0
    }, Qr = () => {
        if (!a) return;
        Rt.muted = !1
    }, ea = () => {
        a && vr(ta, xi = !xi, xi)
    }, ta = Ya(ir);
    pr(e, ta, (e => o(426, xi = e)));
    const oa = () => {
        if (a) return Rt.duration
    }, ia = () => {
        if (!a) return;
        return Rt.currentTime
    }, na = e => {
        a && (Up(Rt, e), vr(Vr, fi = e / bi, fi))
    }, ra = Ya({});
    pr(e, ra, (e => o(52, eo = e))), la("redrawTrigger", ra);
    const ca = Ya($n);
    pr(e, ca, (e => o(500, gi = e))), la("elasticityMultiplier", ca);
    let da = [];
    const ua = bc();
    pr(e, ua, (e => o(102, Xi = e)));
    const pa = Ql() || 1024, ma = Ve(pa, pa), ga = Ds(),
        $a = e => Promise.resolve(mi && mi(e, {resourceType: "image"})).then((t => {
            if (!1 === t) return;
            const {headers: o, credentials: i} = t || {};
            return fetch(e, {headers: o, credentials: i}).then((e => {
                if (200 !== e.status) throw `${e.status} (${e.statusText})`;
                return e.blob()
            })).then((e => Jp(e, Er, ga))).then((e => Qp(e, w)))
        }));
    let {imageSourceToImageData: fa = (e => h(e) ? $a(e) : Nt(e) ? new Promise((t => t(u(e)))) : po(e) || Ht(e) ? Jp(e, Er, ga).then((e => Qp(e, w))) : void 0)} = t;
    const ya = (() => {
        let e, t;
        const o = Xp.reduce(((e, o) => (e[o] = function (e, t, o) {
            let i = [];
            return {
                set: t, update: o, publish: e => {
                    i.forEach((t => t(e)))
                }, subscribe: t => (i.push(t), e(t), () => {
                    i = i.filter((e => e !== t))
                })
            }
        }((e => {
            if (!t) return e();
            t.stores[o].subscribe(e)()
        }), (e => {
            t && t.stores[o].set(e)
        }), (e => {
            t && t.stores[o].update(e)
        })), e)), {});
        return {
            update: i => {
                if (t = i, e && (e.forEach((e => e())), e = void 0), !i) return o.file.publish(void 0), void o.loadState.publish(void 0);
                e = Xp.map((e => i.stores[e].subscribe((t => {
                    o[e].publish(t)
                }))))
            }, stores: o, destroy: () => {
                e && e.forEach((e => e()))
            }
        }
    })(), {
        file: ba,
        size: xa,
        duration: va,
        currentTime: wa,
        trim: Sa,
        volume: ka,
        minDuration: Ca,
        maxDuration: Ta,
        loadState: Ma,
        processState: Pa,
        cropAspectRatio: Ra,
        cropLimitToImage: Ia,
        crop: Ea,
        cropMinSize: Aa,
        cropMaxSize: La,
        cropRange: Fa,
        cropOrigin: za,
        cropRectAspectRatio: Da,
        rotation: Ba,
        rotationRange: Oa,
        targetSize: Wa,
        flipX: Va,
        flipY: _a,
        backgroundColor: Na,
        backgroundImage: Ha,
        colorMatrix: ja,
        convolutionMatrix: Ua,
        gamma: Ga,
        vignette: Za,
        noise: Ka,
        decoration: Ja,
        annotation: Qa,
        manipulation: es,
        redaction: ts,
        frame: os,
        selection: is,
        state: ns
    } = ya.stores;
    pr(e, ba, (e => o(401, So = e))), pr(e, xa, (e => o(375, At = e))), pr(e, va, (e => o(425, bi = e))), pr(e, wa, (e => o(499, pi = e))), pr(e, Sa, (e => o(422, hi = e))), pr(e, ka, (e => o(423, $i = e))), pr(e, Ta, (e => o(428, wi = e))), pr(e, Ma, (e => o(393, uo = e))), pr(e, Pa, (e => o(392, co = e))), pr(e, Ra, (e => o(496, ri = e))), pr(e, Ia, (e => o(85, Pi = e))), pr(e, Ea, (e => o(412, No = e))), pr(e, Ba, (e => o(378, zt = e))), pr(e, Va, (e => o(377, Ft = e))), pr(e, _a, (e => o(376, Lt = e))), pr(e, Na, (e => o(383, Zt = e))), pr(e, Ja, (e => o(48, Et = e))), pr(e, Qa, (e => o(49, Dt = e))), pr(e, es, (e => o(380, jt = e))), pr(e, ts, (e => o(381, Ut = e))), pr(e, os, (e => o(47, It = e))), pr(e, is, (e => o(59, ci = e))), pr(e, ns, (e => o(485, To = e))), la("components", {DynamicComponentTree: pp}), la("previewcontrols", {
        play: Xr,
        pause: Yr,
        togglePlayPause: Kr,
        mute: Jr,
        unmute: Qr,
        toggleMute: ea,
        setCurrentTime: na,
        getCurrentTime: ia,
        getDuration: oa,
        frameOffset: Vr,
        framePeekOffset: Wr,
        isPlaying: _r,
        isMuted: ta
    });
    const rs = (e, t, o = 0) => new Promise(((i, n) => {
        if (Us(e)) return void Ns(e).then((e => {
            const t = zo(pi) ? pi : nr(e.duration, hi || [[0, 1]]);
            Hs(e, t).then(i)
        }));
        let r, a = !1;
        t.cancel = () => a = !0;
        const s = Date.now();
        fa(e).then((e => {
            const t = Date.now() - s;
            clearTimeout(r), r = setTimeout((() => {
                a || i(e)
            }), Math.max(0, o - t))
        })).catch(n)
    })), {
        images: as,
        shapePreprocessor: ss,
        imageScrambler: ls,
        imageRedactionRendering: cs,
        willRequest: ds,
        willRequestResource: us,
        csp: hs
    } = tn;
    let ps;
    pr(e, as, (e => o(421, ui = e))), pr(e, ss, (e => o(420, di = e))), pr(e, ls, (e => o(384, Xt = e))), pr(e, cs, (e => o(382, Gt = e))), pr(e, ds, (e => o(81, mi = e))), pr(e, us, (e => o(93, Wi = e))), pr(e, hs, (e => o(92, Oi = e)));
    const ms = qa(Ha, ((e, t) => {
        if (!e) return t(void 0);
        ps && (ps.cancel(), ps = void 0), ps = {cancel: i}, rs(e, ps).then(t).catch((e => {
        }))
    })), $s = ns.subscribe((e => Ki.pub("update", e))), fs = Ya();
    la("ui", Ya({})), la("selection", is);
    const ys = Ya(!0);
    pr(e, ys, (e => o(95, _i = e)));
    const bs = Ya(!0);
    pr(e, bs, (e => o(97, Hi = e)));
    const vs = Ya(!0);
    pr(e, vs, (e => o(419, li = e)));
    const ws = Ya(!0);
    pr(e, ws, (e => o(497, ai = e)));
    const Ss = Ya(!0);
    pr(e, Ss, (e => o(98, ji = e)));
    const ks = Ya();
    pr(e, ks, (e => o(99, Ui = e)));
    const Cs = Ya();
    pr(e, Cs, (e => o(498, si = e)));
    const Ts = qa([Cs, ws], (() => void 0 !== si ? si : ai));
    pr(e, Ts, (e => o(96, Ni = e)));
    const Ps = Ya([0, 0, 0]);
    pr(e, Ps, (e => o(56, Eo = e)));
    const Rs = Ya([1, 1, 1]);
    pr(e, Rs, (e => o(481, _t = e)));
    const Is = bc([1, 1, 1]);
    pr(e, Is, (e => o(480, Vt = e)));
    const Es = Ya();
    pr(e, Es, (e => o(91, Bi = e)));
    const As = Ya(), Ls = Ya();
    pr(e, Ls, (e => o(51, Jt = e)));
    const Fs = Ya();
    pr(e, Fs, (e => o(373, Mt = e)));
    const zs = Ya(Qe());
    pr(e, zs, (e => o(80, Mo = e)));
    const Bs = Ya(0);
    pr(e, Bs, (e => o(418, ni = e)));
    const Os = Ya(Qe());
    pr(e, Os, (e => o(84, Mi = e)));
    const Ws = Ya();
    pr(e, Ws, (e => o(478, Pt = e)));
    const Vs = Kp("(pointer: fine)", (e => e ? "pointer-fine" : "pointer-coarse"));
    pr(e, Vs, (e => o(399, vo = e)));
    const _s = Kp("(hover: hover)", (e => e ? "pointer-hover" : "pointer-no-hover"));
    pr(e, _s, (e => o(398, xo = e)));
    const js = Ya(!1), Gs = Ya(!1);
    pr(e, Gs, (e => o(379, Wt = e)));
    const Zs = Xa(void 0, (e => {
        const t = bc(0), o = [Gs.subscribe((e => {
            t.set(e ? 1 : 0, {hard: !oo})
        })), t.subscribe(e)];
        return () => o.forEach((e => e()))
    }));
    pr(e, Zs, (e => o(479, Ot = e)));
    const Xs = Ya();
    pr(e, Xs, (e => o(484, $o = e)));
    const Ys = Ya();
    let qs;
    pr(e, Ys, (e => o(53, oo = e))), la("isAnimated", Ys);
    const Ks = Ya(cn);
    pr(e, Ks, (e => o(402, ko = e)));
    const Js = Ya(!1);
    pr(e, Js, (e => o(490, Go = e))), la("imageIsStatic", Js);
    const Qs = Ya();
    pr(e, Qs, (e => o(491, Zo = e)));
    const el = Ya();
    pr(e, el, (e => o(488, Ho = e)));
    const tl = Xa(void 0, (e => {
        const t = Ya(void 0), o = [Ea.subscribe((() => {
            if (!No) return;
            if (Go) return t.set(Je(No));
            const e = Cp(No, Ho, 5 * $n);
            t.set(e)
        })), t.subscribe(e)];
        return () => o.forEach((e => e()))
    })), ol = Ya();
    pr(e, ol, (e => o(487, _o = e)));
    const il = Ya();
    pr(e, il, (e => o(489, Uo = e)));
    const nl = Ya(void 0);
    pr(e, nl, (e => o(494, ei = e)));
    const rl = Ya(ue());
    pr(e, rl, (e => o(495, ti = e)));
    const al = (e, t) => {
        if (!t || !e) return {top: 0, right: 0, bottom: 0, left: 0};
        const o = Tn(t, e, S), i = Cn(o, e);
        return {top: Math.abs(i.top), right: Math.abs(i.right), bottom: Math.abs(i.bottom), left: Math.abs(i.left)}
    }, sl = Ya({}), ll = qa([Ws, zs, Os, sl], (([e, t, o, i], n) => {
        if (!e) return n(void 0);
        let r = 0;
        1 !== N.length || y || "bottom" === Vn || (r = o.y + o.height), n(at(e.x + t.x, e.y + t.y + r, e.width, e.height))
    }));
    let cl = {left: 0, right: 0, top: 0, bottom: 0};
    const dl = Ya(!1), ul = qa([dl, os, ll, Gs], (([e, t, o, i], n) => {
        if (!o) return n({left: 0, right: 0, top: 0, bottom: 0});
        if (!e) return;
        const r = Math.min(o.width, o.height), a = al({width: r, height: r}, t);
        le(cl.top, 4) === le(a.top, 4) && le(cl.bottom, 4) === le(a.bottom, 4) && le(cl.right, 4) === le(a.right, 4) && le(cl.left, 4) === le(a.left, 4) || (cl = a, n(a))
    }));
    pr(e, ul, (e => o(410, Oo = e)));
    const hl = qa([dl, ul], (([e, t], o) => {
        if (!e) return o(!1);
        o(Object.values(t).some((e => e > 0)))
    }));
    pr(e, hl, (e => o(411, Wo = e)));
    const pl = qa([dl, Ws, hl, ul], (([e, t, o, i], n) => {
            if (t) return e && o ? void n(at(t.x + i.left, t.y + i.top, t.width - i.left - i.right, t.height - i.top - i.bottom)) : n({...t})
        })),
        ml = qa([ll, hl, ul], (([e, t, o], i) => e ? t ? void i(at(e.x + o.left, e.y + o.top, e.width - o.left - o.right, e.height - o.top - o.bottom)) : i(e) : i(void 0)));
    pr(e, ml, (e => o(50, Bt = e)));
    const gl = qa([Js, xa, Ba], (([e, t, o], i) => {
        if (!e || !t) return i(void 0);
        const n = et(t);
        i(ft(n, o))
    })), $l = qa([gl], (([e], t) => {
        if (!e) return t(void 0);
        const o = it(e);
        t(Tt(o))
    }));
    pr(e, $l, (e => o(414, qo = e)));
    const fl = qa([ml, Ea, $l, Ks], (([e, t, o, i], n) => {
        if (!e || !t || !(!Zo && !Ho)) return;
        const {width: r, height: a} = o || t, s = Math.min(e.width / r, e.height / a);
        n(i ? s : Math.min(1, s))
    }));
    pr(e, fl, (e => o(413, Yo = e)));
    la("imageStaticVisualCorners", qa([Js, xa, Ba, ml, Ws, fl], (([e, t, o, i, n, r], a) => {
        if (!(e && i && n && t)) return a(void 0);
        const s = et(t), l = Tt(ct(s, r)), c = yt(i, l);
        l.x = c.x, l.y = c.y;
        a(ft(l, o))
    })));
    const yl = Ya(void 0);
    pr(e, yl, (e => o(416, oi = e)));
    const bl = qa([Ea, ml], (([e, t]) => {
        if (t && e) return Math.min(t.width / e.width, t.height / e.height)
    })), xl = qa([Ea, ol], (([e, t]) => e && t ? Math.min(e.width / t.width, e.height / t.height) : 1));
    pr(e, xl, (e => o(101, Zi = e)));
    const vl = qa([yl, xl], (([e, t]) => e && t ? t * e : 1));
    pr(e, vl, (e => o(493, Jo = e)));
    const wl = Ya(ue());
    pr(e, wl, (e => o(415, Qo = e)));
    const Sl = Ya({scalar: Jo, translation: Qo}), Cl = () => {
        Sl.set({scalar: void 0, translation: ue()})
    }, Tl = Xa(void 0, (e => {
        const t = bc(void 0, {precision: 1e-4}), o = 1 === Fd() ? e => kt(e, Math.round) : Z, i = () => {
            if (!_o) return;
            const e = Wt || !$o;
            if (Go) {
                const o = Je(_o);
                return lt(o, ti), lt(o, Bt), t.set(o, {hard: e})
            }
            const i = Cp(_o, ei, _m * $n);
            i.width < 0 && (i.width = 0, i.x = _o.x), i.height < 0 && (i.height = 0, i.y = _o.y), lt(i, Bt), lt(i, Qo), ct(i, Jo), !e && o(i), t.set(i, {hard: e})
        }, n = [ml.subscribe(i), ol.subscribe(i), vl.subscribe(i), wl.subscribe(i), os.subscribe(i), t.subscribe(e)];
        return () => n.forEach((e => e()))
    }));
    pr(e, Tl, (e => o(58, Bo = e)));
    const Ml = Ya(1);
    pr(e, Ml, (e => o(486, Vo = e)));
    const Rl = () => {
        if (!No || !Bt) return;
        let e = ht(Je(No), Yo || 1);
        const t = yt(Bt, ht(Je(qo), Yo));
        lt(e, t);
        const o = Pt.width / e.width, i = Pt.height / e.height, n = Math.min(1, o, i);
        Ml.set(n), ct(e, n), ((e, t) => {
            const [o, i, n, r] = wt(e);
            o < t.y && (e.y = Math.max(t.y, e.y)), i > t.width && (e.x = t.width - e.width), n > t.height && (e.y = t.height - e.height), r < t.x && (e.x = Math.max(t.x, e.x))
        })(e, {...Pt, x: 0, y: 0}), ol.set(e)
    }, Il = qa([ml, fl, Ea, xa], (([e, t, o, i], n) => {
        e && (o || i) && n(El(e, t || 1, o || i))
    }));
    pr(e, Il, (e => o(100, Gi = e)));
    const El = (e, t, o) => o.width <= e.width && o.height <= e.height ? yt(e, ht(Je(o), t)) : vt(e, mt(o));
    let Al, Ll;
    const Fl = e => {
        if (y && Al && pt(Al, e) && Ll === Yo) return;
        if (Go) return Rl();
        Al = e, Ll = Yo;
        const t = El(e, Yo, No || At);
        ol.set(t)
    };
    let zl = !1;
    const Dl = fl.subscribe((e => {
        !zl && void 0 !== e && No && (Fl(Bt), zl = !0)
    })), Bl = ml.subscribe((e => {
        e && void 0 !== Yo && No && Fl(e)
    })), Ol = Js.subscribe((e => {
        !e && Bt && Fl(Bt)
    }));
    let Wl;
    const Vl = il.subscribe((e => {
        if (!e) return Wl = void 0, void vr(Qs, Zo = void 0, Zo);
        Wl = Xo;
        const t = Je(No);
        Qs.set(t)
    })), _l = ol.subscribe((e => {
        if (!e || !Uo) return;
        const t = (o = Je(e), i = Uo, o.x -= i.x, o.y -= i.y, o.width -= i.width, o.height -= i.height, o);
        var o, i;
        ((e, t) => {
            e.x /= t, e.y /= t, e.width /= t, e.height /= t
        })(t, Wl);
        const n = ((e, t) => (e.x += t.x, e.y += t.y, e.width += t.width, e.height += t.height, e))(Je(Zo), t);
        Ea.set(n)
    })), Nl = Ea.subscribe((e => {
        if (!e || !_o) return;
        if (Go) return void (Uo || Rl());
        if (Wt || Uo || Ho) return;
        const t = mt(_o), o = mt(e);
        if (le(t, 6) === le(o, 6)) return;
        const {width: i, height: n} = No, r = Math.min(Bt.width / i, Bt.height / n), a = Ve(e.width * r, e.height * r),
            s = .5 * (_o.width - a.width), l = .5 * (_o.height - a.height),
            c = at(Math.max(0, Math.min(Bt.width - a.width, _o.x + s)), Math.max(0, Math.min(Bt.height - a.height, _o.y + l)), a.width, a.height);
        ol.set(c)
    })), Hl = qa([fl, Ea, ol, Js], (([e, t, o, i], n) => {
        if (!e || !t || !o) return;
        if (i) return n(Vo);
        const r = o.width / t.width, a = o.height / t.height;
        n(Math.max(r, a) / e)
    })), jl = qa([fl, Hl], (([e, t], o) => {
        if (!t) return;
        o(e * t)
    }));
    pr(e, jl, (e => o(492, Xo = e)));
    let Ul = {left: 0, right: 0, top: 0, bottom: 0};
    const Gl = qa([os, ol], (([e, t], o) => {
            if (!t) return o(Ul);
            const i = al(t, e);
            le(Ul.top, 4) === le(i.top, 4) && le(Ul.bottom, 4) === le(i.bottom, 4) && le(Ul.right, 4) === le(i.right, 4) && le(Ul.left, 4) === le(i.left, 4) || (Ul = i, o(i))
        })), Zl = qa([Gl], (([e], t) => {
            t(Object.values(e).some((e => e > 0)))
        })), Xl = bc(.075, {stiffness: .03, damping: .4, precision: .001}),
        Yl = qa([Is, Ps, Xl, Tl, vl, os, Zl, Gl, hl], (([e, t, o, i, n, r, a, s, l], c) => {
            if (!i || y) return c([]);
            let {x: d, y: u, width: h, height: p} = i;
            d += .5, u += .5, h -= .5, p -= .5;
            const m = [];
            if (r) {
                if (a) {
                    let {left: e, right: o, top: i, bottom: r} = s;
                    e *= n, o *= n, i *= n, r *= n;
                    const a = am(t) ? [1, 1, 1, .125] : [0, 0, 0, .075];
                    m.push({
                        x: d - e - .5,
                        y: u - i - .5,
                        width: h + e + o + 1,
                        height: p + i + r + 1,
                        strokeWidth: 1,
                        strokeColor: a,
                        opacity: l ? 1 : .5
                    })
                }
                const i = am(e);
                r && r.frameColor && am(r.frameColor) || i || (m.push({
                    x: d - 1,
                    y: u - 1,
                    width: h + 2,
                    height: p + 2,
                    strokeWidth: 2,
                    strokeColor: [0, 0, 0, .1],
                    opacity: o
                }), m.push({
                    x: d + 1,
                    y: u + 1,
                    width: h - 2,
                    height: p - 2,
                    strokeWidth: 2,
                    strokeColor: [0, 0, 0, .1],
                    opacity: o
                }))
            }
            c([...m, {x: d, y: u, width: h, height: p, strokeWidth: 1, strokeColor: e, opacity: o}])
        })), ql = Ya([]);
    pr(e, ql, (e => o(404, Po = e)));
    const Kl = qa([Yl, ql], (([e, t], o) => {
        o([...e, ...t])
    }));
    pr(e, Kl, (e => o(94, Vi = e)));
    const Jl = bc(0, {precision: .001});
    pr(e, Jl, (e => o(406, Io = e)));
    const tc = bc();
    pr(e, tc, (e => o(409, Fo = e)));
    const oc = bc();
    pr(e, oc, (e => o(408, Lo = e)));
    const ic = bc();
    pr(e, ic, (e => o(407, Ao = e)));
    const nc = bc();
    pr(e, nc, (e => o(405, Ro = e)));
    const rc = Ya(!1);
    pr(e, rc, (e => o(391, lo = e)));
    const ac = Ya();
    let sc;
    pr(e, ac, (e => o(394, ho = e)));
    const lc = qa([rc, ac], (([e, t], n) => {
        if (!e || !t) return void n(void 0);
        if (sc && (sc.cancel(), o(295, sc = void 0)), An(t)) return n(v(t));
        const r = Lc.length ? 0 : oo ? 250 : 0;
        o(295, sc = {cancel: i}), rs(t, sc, r).then(n).catch((e => {
            vr(Ma, uo.error = e, uo)
        })).finally((() => {
            o(295, sc = void 0)
        }))
    }));
    Yi(), Yi = ur(lc, (e => o(374, Rt = e)));
    let {imagePreviewCurrent: cc} = t;
    const dc = Ya({});
    pr(e, dc, (e => o(396, fo = e)));
    const uc = Ya([]);
    pr(e, uc, (e => o(86, Ri = e)));
    const hc = qa([ml, Fs, xa, tl, ol, jl, Ba, Va, _a, vl, wl, js], (([e, t, o, i, n, r, a, s, l, c, d, u], h) => {
        if (!e || !n) return;
        const p = kl(e, t, o, i, n, c, d, r, a, s, l);
        !u && O(p), h(p)
    }));
    pr(e, hc, (e => o(397, yo = e)));
    const pc = qa([ja, Ua, Ga, Za, Ka], (([e, t, o, i, n], r) => {
        const a = e && Object.keys(e).map((t => e[t])).filter(Boolean);
        r({
            gamma: o || void 0,
            vignette: i || void 0,
            noise: n || void 0,
            convolutionMatrix: t || void 0,
            colorMatrix: a && a.length && Qn(a)
        })
    }));
    let mc, gc;
    const $c = (() => {
        if (!bo()) return !1;
        const e = navigator.userAgent.match(/OS (\d+)_(\d+)_?(\d+)?/i) || [], [, t, o] = e.map((e => parseInt(e, 10) || 0));
        return t > 13 || 13 === t && o >= 4
    })(), yc = Ya({});
    pr(e, yc, (e => o(385, Qt = e))), la("env", yc);
    const vc = Fd(), wc = Xa(vc, (e => {
        const t = () => e(Fd()), o = matchMedia(`(resolution: ${vc}dppx)`);
        return o.addListener(t), () => o.removeListener(t)
    }));
    pr(e, wc, (e => o(57, Do = e)));
    const Sc = ((e, t, o) => {
        const {sub: i, pub: n} = Ko(), {willUndo: r = (() => !0)} = o || {}, a = [], s = Ya(0), l = [],
            c = () => l.forEach((e => e({index: hr(s), length: a.length}))), d = {
                get index() {
                    return hr(s)
                },
                set index(e) {
                    e = Number.isInteger(e) ? e : 0, e = gs(e, 0, a.length - 1), s.set(e), t(a[d.index]), c()
                },
                get state() {
                    return a[a.length - 1]
                },
                length: () => a.length,
                undo() {
                    if (!1 === r()) return;
                    const e = d.index--;
                    return n("undo", e), e
                },
                redo() {
                    const e = d.index++;
                    return n("redo", d.index), e
                },
                revert() {
                    a.length = 1, d.index = 0, n("revert")
                },
                write(o) {
                    o && t({...e(), ...o});
                    const i = e(), r = a[a.length - 1];
                    JSON.stringify(i) !== JSON.stringify(r) && (a.length = d.index + 1, a.push(i), s.set(a.length - 1), c(), n("writehistory"))
                },
                set(e = {}) {
                    a.length = 0, d.index = 0;
                    const t = Array.isArray(e) ? e : [e];
                    a.push(...t), d.index = a.length - 1
                },
                get: () => [...a],
                subscribe: e => (l.push(e), e({index: d.index, length: a.length}), () => l.splice(l.indexOf(e), 1)),
                on: i
            };
        return d
    })((() => To), (e => {
        vr(ns, To = e, To), zs.set(Mo)
    }), {willUndo: () => !Rc() || (Pc(), !1)});
    qi(), qi = ur(Sc, (e => o(403, Co = e)));
    const kc = () => {
        const e = {x: 0, y: 0, ...At}, t = kt(vt(e, To.cropAspectRatio), Math.round),
            o = Sn({...To, rotation: 0, crop: t}, To), i = [o];
        JSON.stringify(o) !== JSON.stringify(To) && i.push({...To}), Sc.set(i)
    }, Cc = Ma.subscribe((e => {
        e && e.complete && kc()
    })), Tc = () => fn().then((e => e && Sc.revert())), Mc = [Qa, Ja, ts, es], Pc = () => {
        Mc.forEach((e => {
            e.update((e => e.length && Di(e[e.length - 1]) ? e.slice(0, -1) : e))
        }))
    }, Rc = () => _.filter((e => e.length)).some((e => Di(e[e.length - 1]))), Ic = Ya(!1);
    pr(e, Ic, (e => o(386, to = e)));
    const Ec = () => {
        vr(Ic, to = !0, to), yn().then((e => {
            if (!e) return void vr(Ic, to = !1, to);
            let t;
            t = cd.subscribe((e => {
                1 === e && (t && t(), Ji("processImage"))
            }))
        }))
    }, Ac = Pa.subscribe((e => {
        if (!e) return void vr(Ic, to = !1, to);
        vr(Ic, to = !0, to);
        const {complete: t, abort: o} = e;
        (t || o) && vr(Ic, to = !1, to)
    })), Lc = rm();
    pr(e, Lc, (e => o(55, mo = e)));
    const Fc = qa([Lc], (([e], t) => {
        if (!e.length) return t();
        const {origin: o, translation: i, rotation: n, scale: r} = e[0];
        t({origin: o, translation: i, rotation: n, scale: r})
    })), zc = Ya();
    pr(e, zc, (e => o(400, wo = e)));
    let Dc, Bc = [];
    const Oc = Ya(), Wc = Ya(), Vc = qa([yl, Wc, fl, bl], (([e, t, o, i]) => e || (t || o < 1 ? i : 1))), Nc = {
        ...tn,
        imageFile: ba,
        imageSize: xa,
        mediaDuration: va,
        mediaMinDuration: Ca,
        mediaMaxDuration: Ta,
        mediaTrim: Sa,
        imageBackgroundColor: Na,
        imageBackgroundImage: Ha,
        imageCropAspectRatio: Ra,
        imageCropMinSize: Aa,
        imageCropMaxSize: La,
        imageCropLimitToImage: Ia,
        imageCropRect: Ea,
        imageCropRectOrigin: za,
        imageCropRectSnapshot: Qs,
        imageCropRectAspectRatio: Da,
        imageCropRange: Fa,
        imageRotation: Ba,
        imageRotationRange: Oa,
        imageFlipX: Va,
        imageFlipY: _a,
        imageOutputSize: Wa,
        imageColorMatrix: ja,
        imageConvolutionMatrix: Ua,
        imageGamma: Ga,
        imageVignette: Za,
        imageNoise: Ka,
        imageManipulation: es,
        imageDecoration: Ja,
        imageAnnotation: Qa,
        imageRedaction: ts,
        imageFrame: os,
        imagePreview: lc,
        imagePreviewSource: ac,
        imageTransforms: hc,
        imagePreviewModifiers: dc,
        history: Sc,
        animation: Xs,
        pixelRatio: wc,
        elasticityMultiplier: $n,
        scrollElasticity: Nm,
        rangeInputElasticity: 5,
        redrawTrigger: ra,
        pointerAccuracy: Vs,
        pointerHoverable: _s,
        env: yc,
        rootRect: Fs,
        stageRect: ml,
        stageRectBase: ll,
        stageRecenter: sl,
        stageScalar: fl,
        stagePadding: ul,
        stagePadded: hl,
        presentationScalar: jl,
        imagePreviewUpscale: Wc,
        utilRect: Ws,
        utilRectPadded: pl,
        allowPlayPause: Or,
        allowPan: ys,
        allowZoom: bs,
        allowZoomControls: vs,
        enableZoomInput: Ss,
        enablePanInput: ws,
        enablePanInputStatus: Ts,
        imageSelectionMultiTouching: Oc,
        rootBackgroundColor: Ps,
        rootForegroundColor: Rs,
        rootLineColor: Is,
        rootColorSecondary: As,
        imageOutlineOpacity: Xl,
        utilTools: zc,
        imageSelectionPan: wl,
        imageSelectionZoom: yl,
        imageSelectionZoomCurrent: Vc,
        imageSelectionStageFitScalar: bl,
        imageSelectionStoredState: Sl,
        imageOverlayMarkup: ql,
        interfaceImages: uc,
        isInteracting: Gs,
        isTransformingImage: js,
        isInteractingFraction: Zs,
        imageCropRectIntent: el,
        imageCropRectPresentation: tl,
        imageSelectionRect: ol,
        imageSelectionRectIntent: nl,
        imageSelectionRectPresentation: Tl,
        imageSelectionRectSnapshot: il,
        imageScalar: Hl,
        imageTransformsInterpolated: Fc,
        imageEffects: pc
    };
    delete Nc.image;
    const Hc = "util-" + E();
    let jc = [];
    const Uc = e => H.find((([t]) => e === t));
    let Gc = [];
    const Xc = e => {
        o(62, Gc = Gc.concat(e))
    }, Yc = e => {
        o(62, Gc = Gc.filter((t => t !== e)))
    }, qc = (e, t) => {
        o(304, X[e] = t, X)
    };
    let Kc = bo();
    const Jc = (e, t, o) => {
        let i = ke.getPropertyValue(e);
        i = o ? o(i) : /^[0-9]+$/.test(i) ? parseFloat(i) : void 0, t.set(i, {hard: !oo})
    }, Qc = (e, t, o = !1) => {
        const i = (e => {
            const t = ke.getPropertyValue(e);
            return zh(t)
        })(e);
        i && 0 !== i[3] && (o || (i.length = 3), t.set(i, {hard: !oo}))
    }, ed = Ya();
    pr(e, ed, (e => o(87, Ei = e)));
    const td = Ya();
    pr(e, td, (e => o(88, Ai = e)));
    const od = Ya();
    pr(e, od, (e => o(89, Fi = e)));
    const id = bc(0, {damping: .9});
    pr(e, id, (e => o(90, zi = e)));
    const nd = () => {
        Qc("color", Rs), Qc(dr ? "--color-background" : "background-color", Ps), Qc("outline-color", Is), Qc("--color-primary", Es), Qc("--color-secondary", As), Qc("--grid-color-even", td, !0), Qc("--grid-color-odd", od, !0), Jc("--grid-size", ed), Jc("--editor-inset-top", Bs, (e => parseInt(e, 10)))
    }, rd = qa([hc, pc, Na, ms], (([e, t, o, i]) => e && {...e, ...t, backgroundColor: o, backgroundImage: i}));
    pr(e, rd, (e => o(395, go = e)));
    const ad = () => {
        const e = Lc.length ? void 0 : {resize: 1.05}, t = ((e, t, o = {}) => {
            const {resize: i = 1, opacity: n = 0} = o, r = {
                    opacity: [bc(n, {...im, stiffness: .1}), Z],
                    resize: [bc(i, {...im, stiffness: .1}), Z],
                    translation: [bc(void 0, im), Z],
                    rotation: [bc(void 0, nm), Z],
                    origin: [bc(void 0, im), Z],
                    scale: [bc(void 0, nm), Z],
                    gamma: [bc(void 0, nm), e => e || 1],
                    vignette: [bc(void 0, nm), e => e || 0],
                    colorMatrix: [bc([...om], im), e => e || [...om]],
                    convolutionMatrix: [Ya(void 0), e => e && e.clarity || void 0],
                    backgroundColor: [bc(void 0, im), (e, t, o) => {
                        if (Array.isArray(e)) {
                            if (Array.isArray(t)) {
                                const i = [...e];
                                0 === t[3] ? (i[3] = 0, o(i)) : 0 === i[3] && ((e = [...t])[3] = 0)
                            }
                            return e
                        }
                    }],
                    backgroundImage: [Ya(void 0), Z]
                }, a = Object.entries(r).map((([e, t]) => [e, t[0]])), s = a.map((([, e]) => e)),
                l = Object.entries(r).reduce(((e, [t, o]) => {
                    const [i, n] = o;
                    return e[t] = (e, o) => i.set(n(e, c[t], (e => {
                        i.set(e, {hard: !0})
                    })), o), e
                }), {});
            let c;
            const d = qa(s, (o => (c = o.reduce(((e, t, o) => (e[a[o][0]] = t, e)), {}), c.data = e, c.size = t, c.scale *= o[1], c)));
            return d.get = () => c, d.set = (e, t) => {
                const o = {hard: !t};
                Object.entries(e).forEach((([e, t]) => {
                    l[e] && l[e](t, o)
                }))
            }, d
        })(Rt, At, e);
        Lc.unshift(t), sd(go)
    }, sd = e => {
        Lc.forEach(((t, o) => {
            const i = 0 === o ? 1 : 0;
            t.set({...e, opacity: i, resize: 1}, $o)
        }))
    };
    let ld;
    const cd = fc(void 0, {duration: 500});
    let dd;
    pr(e, cd, (e => o(54, ao = e)));
    const ud = Ya(!1);
    let hd;
    pr(e, ud, (e => o(390, so = e)));
    const pd = bc(void 0, {stiffness: .1, damping: .7, precision: .25});
    pr(e, pd, (e => o(82, Si = e)));
    const md = bc(0, {stiffness: .1, precision: .05});
    pr(e, md, (e => o(83, ki = e)));
    const gd = bc(0, {stiffness: .02, damping: .5, precision: .25});
    pr(e, gd, (e => o(388, no = e)));
    const $d = bc(void 0, {stiffness: .02, damping: .5, precision: .25});
    pr(e, $d, (e => o(389, ro = e)));
    const fd = bc(void 0, {stiffness: .02, damping: .5, precision: .25});
    let yd;
    pr(e, fd, (e => o(387, io = e)));
    const bd = () => {
        Ji("abortLoadImage")
    }, xd = () => {
        Ji("abortProcessImage"), vr(Ic, to = !1, to)
    }, vd = e => {
        e.target && "true" === e.target.dataset.touchScroll || Gp(e) || e.preventDefault()
    }, wd = $c ? e => {
        const t = e.touches ? e.touches[0] : e;
        t.pageX > 20 && t.pageX < window.innerWidth - 20 || vd(e)
    } : i, Sd = Ya([]);
    pr(e, Sd, (e => o(482, Yt = e))), la("keysPressed", Sd);
    const kd = e => {
        !e || jo(e) && !(e => /^image/.test(e.type) && !/svg/.test(e.type))(e) || !jo(e) && !/^http/.test(e) || Ji("loadImage", e)
    }, Cd = e => {
        e && kd(e)
    };
    let Td = void 0, Md = void 0;
    let Pd, Rd = [];
    const Id = Ya();
    la("rootPortal", Id), la("rootRect", Fs);
    const Ed = () => ({
            foregroundColor: [..._t],
            lineColor: [...Vt],
            utilVisibility: {...X},
            isInteracting: Wt,
            isInteractingFraction: Ot,
            rootRect: Je(Mt),
            stageRect: Je(Bt),
            manipulationShapesDirty: qd,
            annotationShapesDirty: Gd,
            decorationShapesDirty: Xd,
            frameShapesDirty: Yd
        }), Ad = (e, t, o) => xn(e, Ve(Math.round(t.width / o), Math.round(t.height / o))), Ld = (e, t, o) => {
            var i;
            return e._translate = he((i = t).x, i.y), e._scale = o, e
        }, zd = e => {
            const t = [];
            return e.forEach((e => t.push(Dd(e)))), t.filter(Boolean)
        },
        Dd = e => Ii(e) ? (e.points = [he(e.x1, e.y1), he(e.x2, e.y2)], e) : (!(e => Ci(e) && !e.text.length)(e) || e.backgroundColor && 0 !== e.backgroundColor[3] || (Ti(e) && (e.width = 5, e.height = e.lineHeight), e.strokeWidth = 1, e.strokeColor = [1, 1, 1, .5], e.backgroundColor = [0, 0, 0, .1]), e);
    let Bd, Od = [], Vd = [], _d = [], Nd = [], Hd = [], jd = {};
    const Ud = (e, t, o, i, n, r, a) => {
        const {
            manipulationShapesDirty: s,
            annotationShapesDirty: l,
            decorationShapesDirty: c,
            frameShapesDirty: d,
            selectionRect: u,
            scale: h
        } = e, p = Bd !== h, m = p || !pt(jd, u);
        m && (Bd = h, jd = u), s && (_d = t.filter(Li).map(yi).map((e => xn(e, At)))), (l || o !== Dt) && (Od = o.filter(Li).map(yi).sort(((e, t) => e.alwaysOnTop ? 1 : t.alwaysOnTop ? -1 : 0)).map((e => xn(e, At)))), (p || Zd || l || o !== Dt) && (Vd = zd(Od.map((e => S(e, {
            flipX: Ft,
            flipY: Lt,
            rotation: zt,
            scale: h,
            context: et(At)
        }))).flat())), (c || i !== Et || m) && (Nd = zd(i.filter(Li).map(yi).sort(((e, t) => e.alwaysOnTop ? 1 : t.alwaysOnTop ? -1 : 0)).map((e => Ad(e, u, h))).map((e => S(e, {context: u}))).flat().map((e => Ld(e, u, h))))), (d || r !== It || m) && (Hd = r ? zd([r].map(yi).map((e => Ad(e, u, h))).map(S).flat().map((e => Ld(e, u, h)))) : []);
        let g = zd(n.filter(Li));
        return "undefined" != typeof window && (e => {
            if (e && e._bj9ox0o) return;
            const [t] = [[85, 110, 108, 105, 99, 101, 110, 115, 101, 100, 32, 80, 105, 110, 116, 117, 114, 97, 32, 105, 110, 115, 116, 97, 110, 99, 101]].map((e => e.map((e => String.fromCharCode(e))).join("")));
            g = [...g, {
                x: u.x + .5 * u.width - 82,
                y: u.y + u.height - 16 - 12,
                width: 164,
                height: 16,
                text: t,
                fontWeight: 900,
                fontSize: 12,
                color: [1, 1, 1, .25]
            }]
        })(window), {
            manipulationShapesDirty: s,
            manipulationShapes: _d,
            annotationShapesDirty: l,
            annotationShapes: Vd,
            decorationShapesDirty: c,
            decorationShapes: Nd,
            frameShapesDirty: d,
            frameShapes: Hd,
            interfaceShapes: g,
            selectionShapes: a.map(yi).map((e => xn(e, At)))
        }
    };
    let Gd = !0;
    let Zd = !0;
    let Xd = !0;
    let Yd = !0;
    let qd = !0;
    aa((() => {
        Yr(), Rt && h(Rt.src) && /^blob:/.test(Rt.src) && URL.revokeObjectURL(Rt.src), $s(), Bl(), Dl(), Ol(), Vl(), _l(), Nl(), Cc(), Ac(), Vs.destroy(), _s.destroy(), ya.destroy(), Lc.clear(), Od.length = 0, Vd.length = 0, _d.length = 0, Nd.length = 0, Hd.length = 0, Td && $(Td), Cr && window.visualViewport.removeEventListener("resize", Mr);
        try {
            o(235, cc = void 0), o(296, ld = void 0)
        } catch (e) {
        }
    }));
    let Kd;
    return e.$$set = e => {
        "class" in e && o(236, Qi = e.class), "layout" in e && o(237, en = e.layout), "stores" in e && o(238, tn = e.stores), "locale" in e && o(3, on = e.locale), "id" in e && o(4, nn = e.id), "util" in e && o(239, rn = e.util), "utils" in e && o(240, an = e.utils), "animations" in e && o(241, sn = e.animations), "disabled" in e && o(242, ln = e.disabled), "previewUpscale" in e && o(243, cn = e.previewUpscale), "previewPad" in e && o(244, dn = e.previewPad), "previewMaskOpacity" in e && o(5, un = e.previewMaskOpacity), "previewImageDataMaxSize" in e && o(245, hn = e.previewImageDataMaxSize), "previewImageTextPixelRatio" in e && o(6, pn = e.previewImageTextPixelRatio), "markupMaskOpacity" in e && o(7, mn = e.markupMaskOpacity), "zoomMaskOpacity" in e && o(246, gn = e.zoomMaskOpacity), "elasticityMultiplier" in e && o(8, $n = e.elasticityMultiplier), "willRevert" in e && o(247, fn = e.willRevert), "willProcessImage" in e && o(248, yn = e.willProcessImage), "willRenderCanvas" in e && o(9, bn = e.willRenderCanvas), "willRenderToolbar" in e && o(249, vn = e.willRenderToolbar), "willRenderUtilTabs" in e && o(250, wn = e.willRenderUtilTabs), "willSetHistoryInitialState" in e && o(251, Sn = e.willSetHistoryInitialState), "enableButtonExport" in e && o(252, kn = e.enableButtonExport), "enableButtonRevert" in e && o(253, Mn = e.enableButtonRevert), "enableNavigateHistory" in e && o(254, Pn = e.enableNavigateHistory), "enableToolbar" in e && o(10, Rn = e.enableToolbar), "enableUtils" in e && o(255, In = e.enableUtils), "enableButtonClose" in e && o(256, En = e.enableButtonClose), "enableDropImage" in e && o(257, Ln = e.enableDropImage), "enablePasteImage" in e && o(258, Fn = e.enablePasteImage), "enableBrowseImage" in e && o(259, zn = e.enableBrowseImage), "enableTransparencyGrid" in e && o(11, Dn = e.enableTransparencyGrid), "layoutDirectionPreference" in e && o(260, Bn = e.layoutDirectionPreference), "layoutHorizontalUtilsPreference" in e && o(261, On = e.layoutHorizontalUtilsPreference), "layoutVerticalUtilsPreference" in e && o(262, Wn = e.layoutVerticalUtilsPreference), "layoutVerticalToolbarPreference" in e && o(263, Vn = e.layoutVerticalToolbarPreference), "layoutVerticalControlGroupsPreference" in e && o(264, _n = e.layoutVerticalControlGroupsPreference), "layoutVerticalControlTabsPreference" in e && o(265, Nn = e.layoutVerticalControlTabsPreference), "status" in e && o(234, Hn = e.status), "formatStatusImageLoading" in e && o(266, jn = e.formatStatusImageLoading), "formatStatusImageProcessing" in e && o(267, Un = e.formatStatusImageProcessing), "formatStatusSupportError" in e && o(268, Gn = e.formatStatusSupportError), "textDirection" in e && o(12, Zn = e.textDirection), "markupEditorZoomLevel" in e && o(269, Xn = e.markupEditorZoomLevel), "markupEditorZoomLevels" in e && o(13, Yn = e.markupEditorZoomLevels), "markupEditorZoomAdjustStep" in e && o(14, qn = e.markupEditorZoomAdjustStep), "markupEditorZoomAdjustFactor" in e && o(15, Kn = e.markupEditorZoomAdjustFactor), "markupEditorZoomAdjustWheelFactor" in e && o(16, Jn = e.markupEditorZoomAdjustWheelFactor), "markupEditorInteractionMode" in e && o(270, or = e.markupEditorInteractionMode), "muteAudio" in e && o(271, ir = e.muteAudio), "willSetMediaInitialTimeOffset" in e && o(272, nr = e.willSetMediaInitialTimeOffset), "enablePan" in e && o(17, rr = e.enablePan), "enableZoom" in e && o(18, ar = e.enableZoom), "enableZoomControls" in e && o(273, sr = e.enableZoomControls), "enableZoomInput" in e && o(19, lr = e.enableZoomInput), "enablePanInput" in e && o(274, cr = e.enablePanInput), "enableCanvasAlpha" in e && o(20, dr = e.enableCanvasAlpha), "enablePanLimit" in e && o(21, mr = e.enablePanLimit), "panLimitGutterScalar" in e && o(22, gr = e.panLimitGutterScalar), "pan" in e && o(275, $r = e.pan), "zoomPresetOptions" in e && o(23, fr = e.zoomPresetOptions), "zoomAdjustStep" in e && o(24, yr = e.zoomAdjustStep), "zoomAdjustFactor" in e && o(25, br = e.zoomAdjustFactor), "zoomAdjustWheelFactor" in e && o(26, xr = e.zoomAdjustWheelFactor), "zoomLevel" in e && o(0, wr = e.zoomLevel), "fixScrollDirection" in e && o(276, Sr = e.fixScrollDirection), "imagePreviewSrc" in e && o(279, Ir = e.imagePreviewSrc), "imageOrienter" in e && o(280, Er = e.imageOrienter), "pluginComponents" in e && o(281, Ar = e.pluginComponents), "pluginOptions" in e && o(27, Lr = e.pluginOptions), "root" in e && o(2, Dr = e.root), "imageSourceToImageData" in e && o(28, fa = e.imageSourceToImageData), "imagePreviewCurrent" in e && o(235, cc = e.imagePreviewCurrent)
    }, e.$$.update = () => {
        if (268435456 & e.$$.dirty[8] && kr.set(Sr), 8 & e.$$.dirty[0] && o(302, n = !!on), 1 & e.$$.dirty[0] | 2097152 & e.$$.dirty[8] && o(0, wr = null === wr ? Xn : wr), 2 & e.$$.dirty[0] | 4 & e.$$.dirty[9]) {
            let e = !1;
            Ar.forEach((([t]) => {
                zr[t] || (o(1, zr[t] = {}, zr), e = !0)
            })), e && o(293, da = [...Ar])
        }
        var t, l, u, x;
        if (8388608 & e.$$.dirty[7] | 8404992 & e.$$.dirty[9] && o(354, N = n && da.length ? an || da.map((([e]) => e)) : []), 134217728 & e.$$.dirty[0] | 16384 & e.$$.dirty[9] | 8192 & e.$$.dirty[11] | 536870912 & e.$$.dirty[12] && o(355, H = ((e, t, o, i) => {
            const n = t.filter((([t]) => e.includes(t))).filter((([e, {isSupported: t}]) => t({...i, ...o[e]}))).map((([e, t]) => [e, t.Component]));
            return xs(n, jc, ((e, t) => e[0] === t[0] && e[1] === t[1])) ? jc : (jc = n, n)
        })(N, da, Lr, {src: So})), 16384 & e.$$.dirty[11] && o(308, j = H.length), 8 & e.$$.dirty[0] | 536870912 & e.$$.dirty[9] | 8192 & e.$$.dirty[11] && o(353, U = j && N.map((e => {
            const t = Uc(e);
            if (t) return {id: e, view: t[1], tabIcon: on[e + "Icon"], tabLabel: on[e + "Label"]}
        })).filter(Boolean) || []), 4096 & e.$$.dirty[11] && o(372, r = !!U.find((e => "trim" === e.id))), 5 & e.$$.dirty[12] | 4194304 & e.$$.dirty[13] && o(307, a = !!(bi && Rt && r)), 4194304 & e.$$.dirty[7] | 536870912 & e.$$.dirty[9] && o(43, G = j && rn && "string" == typeof rn && Uc(rn) ? rn : j > 0 ? H[0][0] : void 0), 4096 & e.$$.dirty[1] | 268435456 & e.$$.dirty[9] && a && G && Yr(), 268435456 & e.$$.dirty[9] | 4 & e.$$.dirty[12] && (a ? (Rt.addEventListener("play", Nr), Rt.addEventListener("pause", Nr)) : Rt && "video" === Rt.nodeName && (Rt.removeEventListener("play", Nr), Rt.removeEventListener("pause", Nr))), 268435456 & e.$$.dirty[9] && a && Vr.set(ia() / oa()), 18874368 & e.$$.dirty[13] && (e => {
            if (!qr()) return;
            const t = Date.now();
            if (jr && t - jr < 16) return;
            jr = t;
            const o = bi * e;
            if (o.toFixed(1) === Hr) return;
            Hr = o.toFixed(1);
            const i = Rt, n = () => {
                i.removeEventListener("seeked", n), Br()
            };
            i.addEventListener("seeked", n), Up(i, o)
        })(vi || fi), 2097152 & e.$$.dirty[13] && o(370, s = fi && le(fi, 6)), 38273024 & e.$$.dirty[13] && o(368, c = hi || [[0, Math.min(bi, wi) / bi]]), 134217728 & e.$$.dirty[11] && (d = c[0][0]), 134217728 & e.$$.dirty[11] && (p = c[c.length - 1][1]), 134217728 & e.$$.dirty[11] && o(371, m = c.map((([e, t]) => [le(e, 6), le(t, 6)]))), 1610612736 & e.$$.dirty[11] && o(369, g = m.findIndex((([e, t]) => s >= e && s <= t))), 1879048192 & e.$$.dirty[11] && (f = -1 === g && m.findIndex(((e, t, o) => {
            const i = o[t - 1];
            return i ? s <= e[0] && s >= i[1] : s <= e[0]
        }))), 8388608 & e.$$.dirty[8] && ta.set(ir), 4 & e.$$.dirty[12] | 8388608 & e.$$.dirty[13] && (Rt && xi ? Jr() : Qr()), 268435456 & e.$$.dirty[9] | 2097152 & e.$$.dirty[13] && a && wa.set(oa() * fi), 4 & e.$$.dirty[12] | 1048576 & e.$$.dirty[13] && Rt && (e => {
            if (!a) return;
            Rt.volume = Math.min(1, e)
        })($i), 256 & e.$$.dirty[0] && vr(ca, gi = $n, gi), 1048576 & e.$$.dirty[7] && o(364, y = "overlay" === en), 128 & e.$$.dirty[8] | 8388608 & e.$$.dirty[11] && o(45, b = In && !y), 134217730 & e.$$.dirty[0] && Lr && Object.entries(Lr).forEach((([e, t]) => {
            Object.entries(t).forEach((([t, i]) => {
                zr[e] && o(1, zr[e][t] = i, zr)
            }))
        })), 16384 & e.$$.dirty[13] && o(365, T = !ii), 16777216 & e.$$.dirty[7] | 50331648 & e.$$.dirty[11] && vr(Ys, oo = "always" === sn ? k : "never" !== sn && (k && T), oo), 4194304 & e.$$.dirty[1] | 33554432 & e.$$.dirty[7] && ua.set(ln ? 1 : 0, {hard: !oo}), 268435456 & e.$$.dirty[7] && (w = hn ? (t = hn, l = ma, Ve(Math.min(t.width, l.width), Math.min(t.height, l.height))) : ma), 262144 & e.$$.dirty[13] && ya.update(ui[0]), 131072 & e.$$.dirty[13] && (S = di ? (e, t) => di(e, {
            flipX: void 0,
            flipY: void 0,
            rotation: void 0, ...t,
            isPreview: !0
        }) : Z), 268435456 & e.$$.dirty[1] && Array.isArray(ci) && Ji("selectionchange", [...ci]), 33554432 & e.$$.dirty[8] | 65536 & e.$$.dirty[13] && ks.set(li && sr), 71303168 & e.$$.dirty[8] && Cs.set("pan" === or || cr), 1048576 & e.$$.dirty[1] && Jt && Fs.set(at(Jt.x, Jt.y, Jt.width, Jt.height)), 8388608 & e.$$.dirty[11] | 2097154 & e.$$.dirty[12] && Mt && y && uo && uo.complete && (() => {
            const e = ri, t = mt(Mt);
            e && e === t || (Ra.set(mt(Mt)), kc())
        })(), 8192 & e.$$.dirty[11] && o(46, J = N.length > 1), 32768 & e.$$.dirty[1] && (J || zs.set(Qe())), 1024 & e.$$.dirty[0] | 32768 & e.$$.dirty[13] && (Rn || Os.set(at(0, ni, 0, 0))), 33554432 & e.$$.dirty[11] | 128 & e.$$.dirty[12] && o(367, C = !Wt && k), 1048576 & e.$$.dirty[1] && o(309, dt = Jt && Jt.width > 0 && Jt.height > 0), 8 & e.$$.dirty[0] | 1610612736 & e.$$.dirty[9] && o(40, ut = dt && on && !!j), 512 & e.$$.dirty[1] && setTimeout((() => o(294, qs = ut)), 1), 16777216 & e.$$.dirty[7] | 32768 & e.$$.dirty[9] | 83886080 & e.$$.dirty[11] && vr(Xs, $o = "always" === sn ? C : "never" !== sn && (C && qs && T), $o), 67108864 & e.$$.dirty[7] | 8388608 & e.$$.dirty[11] && Ks.set(cn || y), 134217728 & e.$$.dirty[7] && dl.set(dn), 134217728 & e.$$.dirty[8] && $r && wl.set($r), 4 & e.$$.dirty[0] | 9216 & e.$$.dirty[13] && Dr && (Dr.dispatchEvent(Yp("markupzoom", oi)), Dr.dispatchEvent(Yp("zoom", zo(oi) ? oi : Yo))), 4 & e.$$.dirty[0] | 4096 & e.$$.dirty[13] && Dr && (Dr.dispatchEvent(Yp("markuppan", Qo)), Dr.dispatchEvent(Yp("pan", Qo))), 512 & e.$$.dirty[13] && No && Cl(), 2048 & e.$$.dirty[13] && qo && Rl(), 4198400 & e.$$.dirty[1] && G && Xl.set(.075, {hard: !oo}), 536870912 & e.$$.dirty[7] && o(362, P = gn), 384 & e.$$.dirty[13] && o(363, R = Wo ? -Math.max(...Object.values(Oo)) : 0), 138936320 & e.$$.dirty[1] | 6291456 & e.$$.dirty[11] && Bo) {
            let e = Bo.x - Bt.x, t = Bt.x + Bt.width - (Bo.x + Bo.width), o = Bo.y - Bt.y,
                i = Bt.y + Bt.height - (Bo.y + Bo.height), n = Math.min(e, o, t, i);
            Jl.set(n > R ? 0 : Math.min(P, Math.abs(n / 64)), {hard: !oo})
        }
        if (67108864 & e.$$.dirty[1] && o(361, I = .55 / Do), 4718592 & e.$$.dirty[1] | 1048576 & e.$$.dirty[11] && Bt && tc.set({
            x: 0,
            y: Bt.y,
            width: Bt.x < 64 ? 0 : Bt.x,
            height: Bt.height + I
        }, {hard: !oo}), 4718592 & e.$$.dirty[1] | 1048576 & e.$$.dirty[11] | 2 & e.$$.dirty[12] && Bt && oc.set({
            x: 0,
            y: 0,
            width: Mt.width,
            height: Bt.y + I
        }, {hard: !oo}), 4718592 & e.$$.dirty[1] | 1048576 & e.$$.dirty[11] | 2 & e.$$.dirty[12] && Bt) {
            let e = Bt.x + Bt.width, t = Mt.width - (Bt.x + Bt.width);
            t < 64 && (e += t, t = 0), ic.set({x: e, y: Bt.y, width: t, height: Bt.height + I}, {hard: !oo})
        }
        if (4718592 & e.$$.dirty[1] | 2 & e.$$.dirty[12] && Bt && nc.set({
            x: 0,
            y: Bt.y + Bt.height,
            width: Mt.width,
            height: Mt.height - (Bt.y + Bt.height)
        }, {hard: !oo}), 33554432 & e.$$.dirty[1] | 72 & e.$$.dirty[13] && o(357, A = Fo && {
            id: "stage-overlay",
            backgroundColor: Eo,
            opacity: Io, ...Fo
        }), 33554432 & e.$$.dirty[1] | 40 & e.$$.dirty[13] && o(360, L = Lo && {
            id: "stage-overlay",
            backgroundColor: Eo,
            opacity: Io, ...Lo
        }), 33554432 & e.$$.dirty[1] | 24 & e.$$.dirty[13] && o(359, F = Ao && {
            id: "stage-overlay",
            backgroundColor: Eo,
            opacity: Io, ...Ao
        }), 33554432 & e.$$.dirty[1] | 12 & e.$$.dirty[13] && o(358, D = Ro && {
            id: "stage-overlay",
            backgroundColor: Eo,
            opacity: Io, ...Ro
        }), 983040 & e.$$.dirty[11] && o(356, B = [L, F, D, A].filter(Boolean)), 32768 & e.$$.dirty[11] | 2 & e.$$.dirty[13] && B && Po && ql.update((e => [...e.filter((e => "stage-overlay" !== e.id)), ...B])), 1 & e.$$.dirty[9] | 536870912 & e.$$.dirty[12] && ac.set(Ir || (So || void 0)), 4 & e.$$.dirty[0] | 262144 & e.$$.dirty[7] | 4 & e.$$.dirty[12] && (o(235, cc = Rt), Rt && Dr.dispatchEvent(Yp("loadpreview", cc))), 4194304 & e.$$.dirty[12] && ho && (wl.set(ue()), yl.set(void 0), Cl(), uc.set([])), 1 & e.$$.dirty[13] && o(313, W = Co.index > 0), 1 & e.$$.dirty[13] && o(312, V = Co.index < Co.length - 1), 393216 & e.$$.dirty[1] | 768 & e.$$.dirty[12] && (_ = [Dt, Et, Ut, jt]), 8 & e.$$.dirty[1] && Oc.set(Dc), 1073741824 & e.$$.dirty[12] && Wc.set(ko), 4096 & e.$$.dirty[1] && fs.set(G), 33554432 & e.$$.dirty[9] | 4096 & e.$$.dirty[11] && o(304, X = U.reduce(((e, t) => (e[t.id] = X && X[t.id] || 0, e)), {})), 4096 & e.$$.dirty[1] && o(79, Y = {
            name: Hc,
            selected: G
        }), 4096 & e.$$.dirty[11] && o(335, q = U.map((e => ({
            id: e.id,
            icon: e.tabIcon,
            label: e.tabLabel
        })))), 4096 & e.$$.dirty[11] && o(78, K = U.map((e => e.id))), 524288 & e.$$.dirty[7] && o(77, Q = Zc(["PinturaRoot", "PinturaRootComponent", Qi])), 2 & e.$$.dirty[12] && o(349, ee = Mt && (Mt.width > 1e3 ? "wide" : Mt.width < 600 ? "narrow" : void 0)), 2 & e.$$.dirty[12] && o(336, te = Mt && (Mt.width <= 320 || Mt.height <= 460)), 2 & e.$$.dirty[12] && o(348, oe = Mt && (Mt.height > 1e3 ? "tall" : Mt.height < 600 ? "short" : void 0)), 4 & e.$$.dirty[0] && o(315, ie = Dr && Dr.parentNode && Dr.parentNode.classList.contains("PinturaModal")), 1 & e.$$.dirty[1] | 32 & e.$$.dirty[10] | 2 & e.$$.dirty[12] && o(341, ne = ie && Mt && mc > Mt.width), 2 & e.$$.dirty[1] | 32 & e.$$.dirty[10] | 2 & e.$$.dirty[12] && o(340, re = ie && Mt && gc > Mt.height), 1073741824 & e.$$.dirty[10] | 1 & e.$$.dirty[11] && o(342, ae = ne && re), 1048576 & e.$$.dirty[0] && o(339, se = dr), 256 & e.$$.dirty[11] && o(310, ce = "narrow" === ee), 4096 & e.$$.dirty[8] | 2 & e.$$.dirty[12] && o(350, (u = Mt, x = Bn, de = Mt ? "auto" === x ? u.width > u.height ? "landscape" : "portrait" : "horizontal" === x ? u.width < 500 ? "portrait" : "landscape" : "vertical" === x ? u.height < 400 ? "landscape" : "portrait" : void 0 : "landscape")), 512 & e.$$.dirty[11] && o(76, pe = "landscape" === de), 1 & e.$$.dirty[10] | 128 & e.$$.dirty[11] && o(338, me = ce || "short" === oe), 1 & e.$$.dirty[1] | 2 & e.$$.dirty[12] && o(337, ge = Kc && Mt && mc === Mt.width && !$c), 4 & e.$$.dirty[1] | 268435456 & e.$$.dirty[12] && o(311, $e = [...wo || [], ...Bc].filter(Boolean)), 8192 & e.$$.dirty[8] && o(347, fe = "has-navigation-preference-" + On), 16384 & e.$$.dirty[8] && o(346, ye = "has-navigation-preference-" + Wn), 32768 & e.$$.dirty[8] && o(343, be = "has-toolbar-preference-" + Vn), 65536 & e.$$.dirty[8] && o(345, xe = "has-controlgroups-preference-" + _n), 131072 & e.$$.dirty[8] && o(344, we = "has-controltabs-preference-" + Nn), 2 & e.$$.dirty[12] && o(352, Se = void 0 !== Mt && Mt.width > 0 && Mt.height > 0), 4 & e.$$.dirty[0] | 2048 & e.$$.dirty[11] && o(351, ke = Se && Dr && getComputedStyle(Dr)), 1024 & e.$$.dirty[11] && ke && nd(), 1024 & e.$$.dirty[0] | 4243456 & e.$$.dirty[1] | 34603008 & e.$$.dirty[7] | 2080374816 & e.$$.dirty[10] | 1023 & e.$$.dirty[11] | 201334784 & e.$$.dirty[12] && yc.set({
            ...Qt,
            layoutMode: en,
            orientation: de,
            horizontalSpace: ee,
            verticalSpace: oe,
            navigationHorizontalPreference: fe,
            navigationVerticalPreference: ye,
            controlGroupsVerticalPreference: xe,
            controlTabsVerticalpreference: we,
            toolbarVerticalPreference: be,
            isModal: ie,
            isDisabled: ln,
            isCentered: ae,
            isCenteredHorizontally: ne,
            isCenteredVertically: re,
            isAnimated: oo,
            isTransparent: se,
            pointerAccuracy: vo,
            pointerHoverable: xo,
            isCompact: me,
            hasSwipeNavigation: ge,
            hasLimitedSpace: te,
            hasToolbar: Rn,
            hasNavigation: J && b,
            isIOS: Kc,
            browserVersion: ec() ? "chrome-" + (navigator.userAgent.match(/Chrome\/([0-9]+)/) || [])[1] : void 0
        }), 8192 & e.$$.dirty[12] && o(75, Ce = Object.entries(Qt).map((([e, t]) => /^is|has/.test(e) ? t ? qp(e) : void 0 : t)).filter(Boolean).join(" ")), 4096 & e.$$.dirty[1] && G && zc.set([]), 4096 & e.$$.dirty[1] | 4 & e.$$.dirty[8] | 33554432 & e.$$.dirty[10] | 8192 & e.$$.dirty[12] && o(44, Te = wn(q.map((e => ({
            ...e,
            selected: G === e.id
        }))), {...Qt}, (() => ra.set({})))), 8192 & e.$$.dirty[1] && o(74, Me = !!Te.find((e => Array.isArray(e)))), 50331648 & e.$$.dirty[12] && o(73, Pe = yo && Object.entries(fo).filter((([, e]) => null != e)).reduce(((e, [, t]) => e = {...e, ...t}), {})), 2097152 & e.$$.dirty[12] && o(332, Ae = uo && "any-to-file" === uo.task), 4194304 & e.$$.dirty[10] && Ae && Lc && Lc.clear(), 8388608 & e.$$.dirty[12] && o(334, Re = !!go && !!go.translation), 131072 & e.$$.dirty[9] | 16777216 & e.$$.dirty[10] | 4 & e.$$.dirty[12] && Re && Rt && Rt !== ld && (o(296, ld = Rt), ad()), 16777216 & e.$$.dirty[10] | 8388608 & e.$$.dirty[12] && Re && sd(go), 16777216 & e.$$.dirty[1] && mo && mo.length > 1) {
            let e = [];
            Lc.forEach(((t, o) => {
                0 !== o && t.get().opacity <= 0 && e.push(t)
            })), e.forEach((e => Lc.remove(e)))
        }
        if (8 & e.$$.dirty[0] | 8388608 & e.$$.dirty[10] && o(39, Ee = on && Ie.length && function (e, t) {
            if (M(t.labelSupportError)) return t.labelSupportError(e);
            const o = Gn({features: e}, t);
            return Pl(t.labelSupportError, o, "{", "}")
        }(Ie, on)), 2097152 & e.$$.dirty[12] && o(324, Le = uo && !!uo.error), 2097152 & e.$$.dirty[12] && o(42, Fe = !uo || !uo.complete && void 0 === uo.task), 2097152 & e.$$.dirty[12] && o(325, ze = uo && (uo.taskLengthComputable ? uo.taskProgress : 1 / 0)), 4194304 & e.$$.dirty[10] && Ae && vr(rc, lo = !1, lo), 4194304 & e.$$.dirty[1] | 262144 & e.$$.dirty[9] | 2097152 & e.$$.dirty[12] && uo && uo.complete) {
            const e = oo ? 250 : 0;
            clearTimeout(dd), o(297, dd = setTimeout((() => {
                vr(rc, lo = !0, lo)
            }), e))
        }
        if (2048 & e.$$.dirty[1] | 16384 & e.$$.dirty[10] | 2621440 & e.$$.dirty[12] && o(329, De = uo && !Le && !Fe && !lo), 65536 & e.$$.dirty[9] | 4194308 & e.$$.dirty[12] && o(328, Be = !(!ho || Rt && !sc)), 4194304 & e.$$.dirty[1] | 524288 & e.$$.dirty[12]) if (lo) {
            setTimeout((() => id.set(1, {hard: !oo})), oo ? 500 : 0)
        } else id.set(0, {hard: !oo});
        if (1064960 & e.$$.dirty[12] && o(323, Oe = !!(to || co && void 0 !== co.progress && !co.complete)), 8192 & e.$$.dirty[10] && Oe && Yr(), 2048 & e.$$.dirty[1] | 2097152 & e.$$.dirty[12] && o(326, We = uo && !(uo.error || Fe)), 8 & e.$$.dirty[0] | 2097152 & e.$$.dirty[12] && o(327, _e = on && function (e, t) {
            const o = e ? !e.complete || e.error ? e : {task: "blob-to-bitmap", progress: 1 / 0} : void 0;
            let i = M(t.statusLabelLoadImage) ? t.statusLabelLoadImage(o) : jn({state: o}, t);
            return e && e.error && e.error.metadata && (i = Pl(i, e.error.metadata, "{", "}")), i
        }(uo, on)), 8 & e.$$.dirty[0] | 1048576 & e.$$.dirty[12] && o(322, Ne = co && on && function (e, t) {
            return M(t.statusLabelProcessImage) ? t.statusLabelProcessImage(e) : Un({state: e}, t)
        }(co, on)), 1048576 & e.$$.dirty[12] && o(320, He = co && (co.taskLengthComputable ? co.taskProgress : 1 / 0)), 1048576 & e.$$.dirty[12] && o(321, je = co && !co.error), 1048576 & e.$$.dirty[12] && o(319, Ue = !(!co || !co.error)), 8 & e.$$.dirty[0] | 2048 & e.$$.dirty[1] | 131072 & e.$$.dirty[7] | 1048064 & e.$$.dirty[10]) if (Hn) {
            let e, t, i, n, r;
            h(Hn) && (e = Hn), zo(Hn) ? t = Hn : Array.isArray(Hn) && ([e, t, r] = Hn, !1 === t && (n = !0), zo(t) && (i = !0)), o(35, hd = (e || t) && {
                text: e,
                aside: n || i,
                progressIndicator: {visible: i, progress: t},
                closeButton: n && {
                    label: on.statusLabelButtonClose,
                    icon: on.statusIconButtonClose,
                    onclick: r || (() => o(234, Hn = void 0))
                }
            })
        } else o(35, hd = on && Fe || Le || De || Be ? {
            text: _e,
            aside: Le || We,
            progressIndicator: {visible: We, progress: ze},
            closeButton: Le && {label: on.statusLabelButtonClose, icon: on.statusIconButtonClose, onclick: bd}
        } : on && Oe && Ne ? {
            text: Ne,
            aside: Ue || je,
            progressIndicator: {visible: je, progress: He},
            closeButton: Ue && {label: on.statusLabelButtonClose, icon: on.statusIconButtonClose, onclick: xd}
        } : void 0);
        if (131072 & e.$$.dirty[7] && o(331, Ge = void 0 !== Hn), 4194304 & e.$$.dirty[1] | 32 & e.$$.dirty[10] | 1048576 & e.$$.dirty[12] && ie && co && co.complete && (ud.set(!0), setTimeout((() => ud.set(!1)), oo ? 100 : 0)), 4 & e.$$.dirty[0] | 4096 & e.$$.dirty[1] | 524288 & e.$$.dirty[12] && lo && Dr && Dr.dispatchEvent(Yp("selectutil", G)), 2304 & e.$$.dirty[1] | 2908160 & e.$$.dirty[10] | 262144 & e.$$.dirty[12] && o(330, Ze = so || Ee || Fe || Le || De || Be || Oe || Ge), 1048576 & e.$$.dirty[10] && vr(cd, ao = Ze ? 1 : 0, ao), 4194304 & e.$$.dirty[1] | 1048576 & e.$$.dirty[10] && cd.set(Ze ? 1 : 0, {duration: oo ? 500 : 1}), 8388608 & e.$$.dirty[1] && o(41, Xe = ao > 0), 16 & e.$$.dirty[1] && o(318, Ye = !(!hd || !hd.aside)), 4195344 & e.$$.dirty[1] | 524288 & e.$$.dirty[9] | 256 & e.$$.dirty[10] | 131072 & e.$$.dirty[12] && Xe && hd) {
            clearTimeout(yd);
            const e = {hard: !1 === oo};
            if (Ye) {
                const t = !!hd.error || !oo;
                md.set(1, e), pd.set(ro, {hard: t}), o(298, yd = setTimeout((() => {
                    gd.set(16, e)
                }), 1))
            } else md.set(0, e), o(298, yd = setTimeout((() => {
                gd.set(0, e)
            }), 1))
        }
        if (1024 & e.$$.dirty[1] && (Xe || (fd.set(void 0, {hard: !0}), pd.set(void 0, {hard: !0}), gd.set(0, {hard: !0}))), 65536 & e.$$.dirty[12] && o(317, qe = .5 * no), 128 & e.$$.dirty[10] | 32768 & e.$$.dirty[12] && o(72, Ke = `translateX(${io - qe}px)`), 256 & e.$$.dirty[1] | 12 & e.$$.dirty[12] && o(38, St = Rt && At && !Ee), 128 & e.$$.dirty[1] | 96 & e.$$.dirty[10] && o(314, ot = tt && (St || ie) ? vd : i), 16 & e.$$.dirty[10] && o(71, nt = ot), 16 & e.$$.dirty[10] && o(70, rt = ot), 8 & e.$$.dirty[0] | 2097152 & e.$$.dirty[1] | 370 & e.$$.dirty[8] | 15 & e.$$.dirty[10] | 8192 & e.$$.dirty[12] && o(69, st = on && eo && lm((() => vn([["div", "alpha", {class: "PinturaNavGroup"}, [["div", "alpha-set", {class: "PinturaNavSet"}, [En && ["Button", "close", {
            label: on.labelClose,
            icon: on.iconButtonClose,
            onclick: () => Ji("close"),
            hideLabel: !0
        }], Mn && ["Button", "revert", {
            label: on.labelButtonRevert,
            icon: on.iconButtonRevert,
            disabled: !W,
            onclick: Tc,
            hideLabel: !0
        }]]]]], ["div", "beta", {class: "PinturaNavGroup PinturaNavGroupFloat"}, [Pn && ["div", "history", {class: "PinturaNavSet"}, [["Button", "undo", {
            label: on.labelButtonUndo,
            icon: on.iconButtonUndo,
            disabled: !W,
            onclick: Sc.undo,
            hideLabel: !0
        }], ["Button", "redo", {
            label: on.labelButtonRedo,
            icon: on.iconButtonRedo,
            disabled: !V,
            onclick: Sc.redo,
            hideLabel: !0
        }]]], $e.length && ["div", "plugin-tools", {class: "PinturaNavSet"}, $e.filter(Boolean).map((([e, t, o]) => [e, t, {...o}]))]]], ["div", "gamma", {class: "PinturaNavGroup"}, [kn && ["Button", "export", {
            label: on.labelButtonExport,
            icon: ce && on.iconButtonExport,
            class: "PinturaButtonExport",
            onclick: Ec,
            hideLabel: ce
        }]]]], {...Qt}, (() => ra.set({})))))), 512 & e.$$.dirty[12] && o(306, gt = Ut && !!Ut.length), 134217728 & e.$$.dirty[9] | 520 & e.$$.dirty[12] && o(305, $t = gt && er(At, Ut)), 201326592 & e.$$.dirty[9] | 6148 & e.$$.dirty[12] && gt && ((e, t, i, n) => {
            if (!t || !e || Md === t) return;
            Md = t;
            const r = {dataSizeScalar: i};
            n && n[3] > 0 && (r.backgroundColor = [...n]), t(e, r).then((e => {
                Td && $(Td), e.setAttribute("data-retain", !0), o(299, Td = e)
            }))
        })(Rt, Xt, $t, Zt), 1048576 & e.$$.dirty[9] | 1544 & e.$$.dirty[12] && Ut && Td && At) {
            const {width: e, height: t} = At, i = Kt() ? "pixelated" : "auto" === Gt ? "auto" : "pixelated";
            o(300, Rd = Ut.map((o => {
                const n = at(o.x, o.y, o.width, o.height), r = ft(Je(n), o.rotation).map((o => he(o.x / e, o.y / t)));
                return {
                    ...o,
                    id: "redaction",
                    flipX: !1,
                    flipY: !1,
                    cornerRadius: 0,
                    strokeWidth: 0,
                    strokeColor: void 0,
                    backgroundColor: [0, 0, 0, 0],
                    backgroundImage: Td,
                    backgroundImageRendering: i,
                    backgroundCorners: r
                }
            })))
        }
        2097152 & e.$$.dirty[9] | 256 & e.$$.dirty[12] && o(37, bt = [...Rd, ...jt || []]), 32 & e.$$.dirty[1] && Pd && Id.set(Pd), 4 & e.$$.dirty[0] | 128 & e.$$.dirty[1] && St && Dr && Dr.dispatchEvent(Yp("ready")), 262144 & e.$$.dirty[1] && o(63, Gd = !0), 120 & e.$$.dirty[12] && o(64, Zd = !0), 131072 & e.$$.dirty[1] && o(65, Xd = !0), 65536 & e.$$.dirty[1] && o(66, Yd = !0), 64 & e.$$.dirty[1] && o(67, qd = !0), 2 & e.$$.dirty[12] && o(303, Ct = !!Mt && Mt.height > 0), 29360128 & e.$$.dirty[9] && !n && Ct && (clearTimeout(Kd), o(301, Kd = setTimeout((() => {
            n || Ms("locale")
        }), 32)))
    }, o(366, k = !_c()), O = 1 === Fd() ? e => {
        e && (ve(e.origin, Math.round), ve(e.translation, Math.round))
    } : Z, o(333, Ie = [!tm() && "WebGL"].filter(Boolean)), o(316, tt = bo() || x() && z()), o(68, xt = ((e, t = !0) => o => {
        "ping" === o.type && (t && o.stopPropagation(), e(o.detail.type, o.detail.data))
    })(Ki.pub)), [wr, zr, Dr, on, nn, un, pn, mn, $n, bn, Rn, Dn, Zn, Yn, qn, Kn, Jn, rr, ar, lr, dr, mr, gr, fr, yr, br, xr, Lr, fa, lc, Sc, mc, gc, Bc, Dc, hd, Pd, bt, St, Ee, ut, Xe, Fe, G, Te, b, J, It, Et, Dt, Bt, Jt, eo, oo, ao, mo, Eo, Do, Bo, ci, Pr, Rr, Gc, Gd, Zd, Xd, Yd, qd, xt, st, rt, nt, Ke, Pe, Me, Ce, pe, Q, K, Y, Mo, mi, Si, ki, Mi, Pi, Ri, Ei, Ai, Fi, zi, Bi, Oi, Wi, Vi, _i, Ni, Hi, ji, Ui, Gi, Zi, Xi, Or, Wr, Vr, ta, ra, ca, ua, ba, xa, va, wa, Sa, ka, Ta, Ma, Pa, Ra, Ia, Ea, Ba, Va, _a, Na, Ja, Qa, es, ts, os, is, ns, as, ss, ls, cs, ds, us, hs, ys, bs, vs, ws, Ss, ks, Cs, Ts, Ps, Rs, Is, Es, Ls, Fs, zs, Bs, Os, Ws, Vs, _s, Gs, Zs, Xs, Ys, Ks, Js, Qs, el, ol, il, nl, rl, ul, hl, ml, $l, fl, yl, xl, vl, wl, Tl, Ml, Il, jl, ql, Kl, Jl, tc, oc, ic, nc, rc, ac, dc, uc, hc, yc, wc, Ic, Lc, zc, Nc, Xc, Yc, qc, (e, t) => t[e], e => U.find((t => t.id === e)).view, ed, td, od, id, ({
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              target: e,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              propertyName: t
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          }) => {
        e === Dr && /background|outline/.test(t) && ke && nd()
    }, rd, cd, ud, pd, md, gd, $d, fd, e => {
        const t = !(!hd || !hd.closeButton) || !oo;
        $d.set(e.detail.width, {hard: t}), fd.set(Math.round(.5 * -e.detail.width), {hard: t})
    }, wd, Sd, e => {
        const {keyCode: t, metaKey: o, ctrlKey: i, shiftKey: n} = e;
        if (9 === t && ln) return void e.preventDefault();
        if (e.target && 32 === t && Dr.contains(e.target) && !Wd(e.target) && (qt && a && Kr(), e.preventDefault()), 90 === t && (o || i)) return void (n && o ? Sc.redo() : Sc.undo());
        if (89 === t && i) return void Sc.redo();
        if (229 === t) return;
        const r = new Set([...Yt, t]);
        Sd.set(Array.from(r))
    }, ({key: e, keyCode: t}) => {
        if ("Meta" === e) return Sd.set([]);
        Sd.set(Yt.filter((e => e !== t)))
    }, () => {
        Sd.set([])
    }, e => {
        Wd(e.target) || e.preventDefault()
    }, e => {
        Ln && kd(e.detail.resources[0])
    }, () => {
        zn && sm().then(Cd)
    }, e => {
        if (!Fn) return;
        const t = gs((window.innerWidth - Math.abs(Mt.x)) / Mt.width, 0, 1),
            o = gs((window.innerHeight - Math.abs(Mt.y)) / Mt.height, 0, 1);
        t < .75 && o < .75 || kd((e.clipboardData || window.clipboardData).files[0])
    }, Ed, Ud, e => {
        Pt && pt(e.detail, Pt) || vr(Ws, Pt = e.detail, Pt)
    }, Hn, cc, Qi, en, tn, rn, an, sn, ln, cn, dn, hn, gn, fn, yn, vn, wn, Sn, kn, Mn, Pn, In, En, Ln, Fn, zn, Bn, On, Wn, Vn, _n, Nn, jn, Un, Gn, Xn, or, ir, nr, sr, cr, $r, Sr, () => o(60, Pr = void 0), (e, t, i) => {
        const {
            text: n = "",
            placeholder: r = "",
            autoClose: a = !0,
            align: s = "top",
            justify: l = "center",
            buttonConfirm: c,
            buttonCancel: d
        } = i;
        o(60, Pr = {
            align: s, justify: l, text: n, placeholder: r, buttonConfirm: c, buttonCancel: d, onconfirm: () => {
                e(Rr.value), a && o(60, Pr = void 0)
            }, oncancel: () => {
                t(void 0), o(60, Pr = void 0)
            }
        })
    }, Ir, Er, Ar, Fr, Xr, Yr, qr, Kr, Jr, Qr, ea, oa, ia, na, da, qs, sc, ld, dd, yd, Td, Rd, Kd, n, Ct, X, $t, gt, a, j, dt, ce, $e, V, W, ot, ie, tt, qe, Ye, Ue, He, je, Ne, Oe, Le, ze, We, _e, Be, De, Ze, Ge, Ae, Ie, Re, q, te, ge, me, se, re, ne, ae, be, we, xe, ye, fe, oe, ee, de, ke, Se, U, N, H, B, A, D, F, L, I, P, R, y, T, k, C, c, g, s, m, r, Mt, Rt, At, Lt, Ft, zt, Wt, jt, Ut, Gt, Zt, Xt, Qt, to, io, no, ro, so, lo, co, uo, ho, go, fo, yo, xo, vo, wo, So, ko, Co, Po, Ro, Io, Ao, Lo, Fo, Oo, Wo, No, Yo, qo, Qo, oi, ii, ni, li, di, ui, hi, $i, fi, bi, xi, vi, wi, function () {
        o(31, mc = gm.innerWidth), o(32, gc = gm.innerHeight)
    }, e => vr(Os, Mi = e.detail, Mi), ({detail: e}) => o(43, G = e), function (t, i) {
        e.$$.not_equal(zr[i], t) && (zr[i] = t, o(1, zr), o(281, Ar), o(27, Lr))
    }, e => Xc(e), e => Yc(e), (e, {detail: t}) => qc(e, t), e => vr(zs, Mo = e.detail, Mo), function (t) {
        e.$$.not_equal(zr[G], t) && (zr[G] = t, o(1, zr), o(281, Ar), o(27, Lr))
    }, () => Xc(G), () => Yc(G), ({detail: e}) => qc(G, e), e => {
        const t = {...e, ...Ed()}, {
            annotationShapes: o,
            decorationShapes: i,
            interfaceShapes: n,
            frameShapes: r,
            selectionShapes: a
        } = bn({
            annotationShapes: Dt,
            decorationShapes: Et,
            interfaceShapes: Vi,
            frameShapes: It,
            selectionShapes: ci
        }, t);
        return Ud(t, bt, o, i, n, r, a)
    }, () => {
        o(63, Gd = !1), o(64, Zd = !1), o(65, Xd = !1), o(66, Yd = !1), o(67, qd = !1)
    }, function (e) {
        ha[e ? "unshift" : "push"]((() => {
            Pd = e, o(36, Pd)
        }))
    }, function (e) {
        wr = e, o(0, wr), o(269, Xn)
    }, function (e) {
        Bc = e, o(33, Bc)
    }, function (e) {
        Dc = e, o(34, Dc)
    }, function (e) {
        ha[e ? "unshift" : "push"]((() => {
            Rr = e, o(61, Rr)
        }))
    }, function (e) {
        ha[e ? "unshift" : "push"]((() => {
            Dr = e, o(2, Dr)
        }))
    }, e => vr(Ls, Jt = e.detail, Jt)]
}

class jm extends Ga {
    constructor(e) {
        super(), Ua(this, e, Hm, Vm, lr, {
            class: 236,
            layout: 237,
            stores: 238,
            locale: 3,
            id: 4,
            util: 239,
            utils: 240,
            animations: 241,
            disabled: 242,
            previewUpscale: 243,
            previewPad: 244,
            previewMaskOpacity: 5,
            previewImageDataMaxSize: 245,
            previewImageTextPixelRatio: 6,
            markupMaskOpacity: 7,
            zoomMaskOpacity: 246,
            elasticityMultiplier: 8,
            willRevert: 247,
            willProcessImage: 248,
            willRenderCanvas: 9,
            willRenderToolbar: 249,
            willRenderUtilTabs: 250,
            willSetHistoryInitialState: 251,
            enableButtonExport: 252,
            enableButtonRevert: 253,
            enableNavigateHistory: 254,
            enableToolbar: 10,
            enableUtils: 255,
            enableButtonClose: 256,
            enableDropImage: 257,
            enablePasteImage: 258,
            enableBrowseImage: 259,
            enableTransparencyGrid: 11,
            layoutDirectionPreference: 260,
            layoutHorizontalUtilsPreference: 261,
            layoutVerticalUtilsPreference: 262,
            layoutVerticalToolbarPreference: 263,
            layoutVerticalControlGroupsPreference: 264,
            layoutVerticalControlTabsPreference: 265,
            status: 234,
            formatStatusImageLoading: 266,
            formatStatusImageProcessing: 267,
            formatStatusSupportError: 268,
            textDirection: 12,
            markupEditorZoomLevel: 269,
            markupEditorZoomLevels: 13,
            markupEditorZoomAdjustStep: 14,
            markupEditorZoomAdjustFactor: 15,
            markupEditorZoomAdjustWheelFactor: 16,
            markupEditorInteractionMode: 270,
            muteAudio: 271,
            willSetMediaInitialTimeOffset: 272,
            enablePan: 17,
            enableZoom: 18,
            enableZoomControls: 273,
            enableZoomInput: 19,
            enablePanInput: 274,
            enableCanvasAlpha: 20,
            enablePanLimit: 21,
            panLimitGutterScalar: 22,
            pan: 275,
            zoomPresetOptions: 23,
            zoomAdjustStep: 24,
            zoomAdjustFactor: 25,
            zoomAdjustWheelFactor: 26,
            zoomLevel: 0,
            fixScrollDirection: 276,
            hideTextInput: 277,
            showTextInput: 278,
            imagePreviewSrc: 279,
            imageOrienter: 280,
            pluginComponents: 281,
            pluginOptions: 27,
            sub: 282,
            pluginInterface: 1,
            root: 2,
            play: 283,
            pause: 284,
            isPaused: 285,
            togglePlayPause: 286,
            mute: 287,
            unmute: 288,
            toggleMute: 289,
            getDuration: 290,
            getCurrentTime: 291,
            setCurrentTime: 292,
            imageSourceToImageData: 28,
            imagePreview: 29,
            imagePreviewCurrent: 235,
            history: 30
        }, null, [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1])
    }

    get class() {
        return this.$$.ctx[236]
    }

    set class(e) {
        this.$$set({class: e}), ka()
    }

    get layout() {
        return this.$$.ctx[237]
    }

    set layout(e) {
        this.$$set({layout: e}), ka()
    }

    get stores() {
        return this.$$.ctx[238]
    }

    set stores(e) {
        this.$$set({stores: e}), ka()
    }

    get locale() {
        return this.$$.ctx[3]
    }

    set locale(e) {
        this.$$set({locale: e}), ka()
    }

    get id() {
        return this.$$.ctx[4]
    }

    set id(e) {
        this.$$set({id: e}), ka()
    }

    get util() {
        return this.$$.ctx[239]
    }

    set util(e) {
        this.$$set({util: e}), ka()
    }

    get utils() {
        return this.$$.ctx[240]
    }

    set utils(e) {
        this.$$set({utils: e}), ka()
    }

    get animations() {
        return this.$$.ctx[241]
    }

    set animations(e) {
        this.$$set({animations: e}), ka()
    }

    get disabled() {
        return this.$$.ctx[242]
    }

    set disabled(e) {
        this.$$set({disabled: e}), ka()
    }

    get previewUpscale() {
        return this.$$.ctx[243]
    }

    set previewUpscale(e) {
        this.$$set({previewUpscale: e}), ka()
    }

    get previewPad() {
        return this.$$.ctx[244]
    }

    set previewPad(e) {
        this.$$set({previewPad: e}), ka()
    }

    get previewMaskOpacity() {
        return this.$$.ctx[5]
    }

    set previewMaskOpacity(e) {
        this.$$set({previewMaskOpacity: e}), ka()
    }

    get previewImageDataMaxSize() {
        return this.$$.ctx[245]
    }

    set previewImageDataMaxSize(e) {
        this.$$set({previewImageDataMaxSize: e}), ka()
    }

    get previewImageTextPixelRatio() {
        return this.$$.ctx[6]
    }

    set previewImageTextPixelRatio(e) {
        this.$$set({previewImageTextPixelRatio: e}), ka()
    }

    get markupMaskOpacity() {
        return this.$$.ctx[7]
    }

    set markupMaskOpacity(e) {
        this.$$set({markupMaskOpacity: e}), ka()
    }

    get zoomMaskOpacity() {
        return this.$$.ctx[246]
    }

    set zoomMaskOpacity(e) {
        this.$$set({zoomMaskOpacity: e}), ka()
    }

    get elasticityMultiplier() {
        return this.$$.ctx[8]
    }

    set elasticityMultiplier(e) {
        this.$$set({elasticityMultiplier: e}), ka()
    }

    get willRevert() {
        return this.$$.ctx[247]
    }

    set willRevert(e) {
        this.$$set({willRevert: e}), ka()
    }

    get willProcessImage() {
        return this.$$.ctx[248]
    }

    set willProcessImage(e) {
        this.$$set({willProcessImage: e}), ka()
    }

    get willRenderCanvas() {
        return this.$$.ctx[9]
    }

    set willRenderCanvas(e) {
        this.$$set({willRenderCanvas: e}), ka()
    }

    get willRenderToolbar() {
        return this.$$.ctx[249]
    }

    set willRenderToolbar(e) {
        this.$$set({willRenderToolbar: e}), ka()
    }

    get willRenderUtilTabs() {
        return this.$$.ctx[250]
    }

    set willRenderUtilTabs(e) {
        this.$$set({willRenderUtilTabs: e}), ka()
    }

    get willSetHistoryInitialState() {
        return this.$$.ctx[251]
    }

    set willSetHistoryInitialState(e) {
        this.$$set({willSetHistoryInitialState: e}), ka()
    }

    get enableButtonExport() {
        return this.$$.ctx[252]
    }

    set enableButtonExport(e) {
        this.$$set({enableButtonExport: e}), ka()
    }

    get enableButtonRevert() {
        return this.$$.ctx[253]
    }

    set enableButtonRevert(e) {
        this.$$set({enableButtonRevert: e}), ka()
    }

    get enableNavigateHistory() {
        return this.$$.ctx[254]
    }

    set enableNavigateHistory(e) {
        this.$$set({enableNavigateHistory: e}), ka()
    }

    get enableToolbar() {
        return this.$$.ctx[10]
    }

    set enableToolbar(e) {
        this.$$set({enableToolbar: e}), ka()
    }

    get enableUtils() {
        return this.$$.ctx[255]
    }

    set enableUtils(e) {
        this.$$set({enableUtils: e}), ka()
    }

    get enableButtonClose() {
        return this.$$.ctx[256]
    }

    set enableButtonClose(e) {
        this.$$set({enableButtonClose: e}), ka()
    }

    get enableDropImage() {
        return this.$$.ctx[257]
    }

    set enableDropImage(e) {
        this.$$set({enableDropImage: e}), ka()
    }

    get enablePasteImage() {
        return this.$$.ctx[258]
    }

    set enablePasteImage(e) {
        this.$$set({enablePasteImage: e}), ka()
    }

    get enableBrowseImage() {
        return this.$$.ctx[259]
    }

    set enableBrowseImage(e) {
        this.$$set({enableBrowseImage: e}), ka()
    }

    get enableTransparencyGrid() {
        return this.$$.ctx[11]
    }

    set enableTransparencyGrid(e) {
        this.$$set({enableTransparencyGrid: e}), ka()
    }

    get layoutDirectionPreference() {
        return this.$$.ctx[260]
    }

    set layoutDirectionPreference(e) {
        this.$$set({layoutDirectionPreference: e}), ka()
    }

    get layoutHorizontalUtilsPreference() {
        return this.$$.ctx[261]
    }

    set layoutHorizontalUtilsPreference(e) {
        this.$$set({layoutHorizontalUtilsPreference: e}), ka()
    }

    get layoutVerticalUtilsPreference() {
        return this.$$.ctx[262]
    }

    set layoutVerticalUtilsPreference(e) {
        this.$$set({layoutVerticalUtilsPreference: e}), ka()
    }

    get layoutVerticalToolbarPreference() {
        return this.$$.ctx[263]
    }

    set layoutVerticalToolbarPreference(e) {
        this.$$set({layoutVerticalToolbarPreference: e}), ka()
    }

    get layoutVerticalControlGroupsPreference() {
        return this.$$.ctx[264]
    }

    set layoutVerticalControlGroupsPreference(e) {
        this.$$set({layoutVerticalControlGroupsPreference: e}), ka()
    }

    get layoutVerticalControlTabsPreference() {
        return this.$$.ctx[265]
    }

    set layoutVerticalControlTabsPreference(e) {
        this.$$set({layoutVerticalControlTabsPreference: e}), ka()
    }

    get status() {
        return this.$$.ctx[234]
    }

    set status(e) {
        this.$$set({status: e}), ka()
    }

    get formatStatusImageLoading() {
        return this.$$.ctx[266]
    }

    set formatStatusImageLoading(e) {
        this.$$set({formatStatusImageLoading: e}), ka()
    }

    get formatStatusImageProcessing() {
        return this.$$.ctx[267]
    }

    set formatStatusImageProcessing(e) {
        this.$$set({formatStatusImageProcessing: e}), ka()
    }

    get formatStatusSupportError() {
        return this.$$.ctx[268]
    }

    set formatStatusSupportError(e) {
        this.$$set({formatStatusSupportError: e}), ka()
    }

    get textDirection() {
        return this.$$.ctx[12]
    }

    set textDirection(e) {
        this.$$set({textDirection: e}), ka()
    }

    get markupEditorZoomLevel() {
        return this.$$.ctx[269]
    }

    set markupEditorZoomLevel(e) {
        this.$$set({markupEditorZoomLevel: e}), ka()
    }

    get markupEditorZoomLevels() {
        return this.$$.ctx[13]
    }

    set markupEditorZoomLevels(e) {
        this.$$set({markupEditorZoomLevels: e}), ka()
    }

    get markupEditorZoomAdjustStep() {
        return this.$$.ctx[14]
    }

    set markupEditorZoomAdjustStep(e) {
        this.$$set({markupEditorZoomAdjustStep: e}), ka()
    }

    get markupEditorZoomAdjustFactor() {
        return this.$$.ctx[15]
    }

    set markupEditorZoomAdjustFactor(e) {
        this.$$set({markupEditorZoomAdjustFactor: e}), ka()
    }

    get markupEditorZoomAdjustWheelFactor() {
        return this.$$.ctx[16]
    }

    set markupEditorZoomAdjustWheelFactor(e) {
        this.$$set({markupEditorZoomAdjustWheelFactor: e}), ka()
    }

    get markupEditorInteractionMode() {
        return this.$$.ctx[270]
    }

    set markupEditorInteractionMode(e) {
        this.$$set({markupEditorInteractionMode: e}), ka()
    }

    get muteAudio() {
        return this.$$.ctx[271]
    }

    set muteAudio(e) {
        this.$$set({muteAudio: e}), ka()
    }

    get willSetMediaInitialTimeOffset() {
        return this.$$.ctx[272]
    }

    set willSetMediaInitialTimeOffset(e) {
        this.$$set({willSetMediaInitialTimeOffset: e}), ka()
    }

    get enablePan() {
        return this.$$.ctx[17]
    }

    set enablePan(e) {
        this.$$set({enablePan: e}), ka()
    }

    get enableZoom() {
        return this.$$.ctx[18]
    }

    set enableZoom(e) {
        this.$$set({enableZoom: e}), ka()
    }

    get enableZoomControls() {
        return this.$$.ctx[273]
    }

    set enableZoomControls(e) {
        this.$$set({enableZoomControls: e}), ka()
    }

    get enableZoomInput() {
        return this.$$.ctx[19]
    }

    set enableZoomInput(e) {
        this.$$set({enableZoomInput: e}), ka()
    }

    get enablePanInput() {
        return this.$$.ctx[274]
    }

    set enablePanInput(e) {
        this.$$set({enablePanInput: e}), ka()
    }

    get enableCanvasAlpha() {
        return this.$$.ctx[20]
    }

    set enableCanvasAlpha(e) {
        this.$$set({enableCanvasAlpha: e}), ka()
    }

    get enablePanLimit() {
        return this.$$.ctx[21]
    }

    set enablePanLimit(e) {
        this.$$set({enablePanLimit: e}), ka()
    }

    get panLimitGutterScalar() {
        return this.$$.ctx[22]
    }

    set panLimitGutterScalar(e) {
        this.$$set({panLimitGutterScalar: e}), ka()
    }

    get pan() {
        return this.$$.ctx[275]
    }

    set pan(e) {
        this.$$set({pan: e}), ka()
    }

    get zoomPresetOptions() {
        return this.$$.ctx[23]
    }

    set zoomPresetOptions(e) {
        this.$$set({zoomPresetOptions: e}), ka()
    }

    get zoomAdjustStep() {
        return this.$$.ctx[24]
    }

    set zoomAdjustStep(e) {
        this.$$set({zoomAdjustStep: e}), ka()
    }

    get zoomAdjustFactor() {
        return this.$$.ctx[25]
    }

    set zoomAdjustFactor(e) {
        this.$$set({zoomAdjustFactor: e}), ka()
    }

    get zoomAdjustWheelFactor() {
        return this.$$.ctx[26]
    }

    set zoomAdjustWheelFactor(e) {
        this.$$set({zoomAdjustWheelFactor: e}), ka()
    }

    get zoomLevel() {
        return this.$$.ctx[0]
    }

    set zoomLevel(e) {
        this.$$set({zoomLevel: e}), ka()
    }

    get fixScrollDirection() {
        return this.$$.ctx[276]
    }

    set fixScrollDirection(e) {
        this.$$set({fixScrollDirection: e}), ka()
    }

    get hideTextInput() {
        return this.$$.ctx[277]
    }

    get showTextInput() {
        return this.$$.ctx[278]
    }

    get imagePreviewSrc() {
        return this.$$.ctx[279]
    }

    set imagePreviewSrc(e) {
        this.$$set({imagePreviewSrc: e}), ka()
    }

    get imageOrienter() {
        return this.$$.ctx[280]
    }

    set imageOrienter(e) {
        this.$$set({imageOrienter: e}), ka()
    }

    get pluginComponents() {
        return this.$$.ctx[281]
    }

    set pluginComponents(e) {
        this.$$set({pluginComponents: e}), ka()
    }

    get pluginOptions() {
        return this.$$.ctx[27]
    }

    set pluginOptions(e) {
        this.$$set({pluginOptions: e}), ka()
    }

    get sub() {
        return this.$$.ctx[282]
    }

    get pluginInterface() {
        return this.$$.ctx[1]
    }

    get root() {
        return this.$$.ctx[2]
    }

    set root(e) {
        this.$$set({root: e}), ka()
    }

    get play() {
        return this.$$.ctx[283]
    }

    get pause() {
        return this.$$.ctx[284]
    }

    get isPaused() {
        return this.$$.ctx[285]
    }

    get togglePlayPause() {
        return this.$$.ctx[286]
    }

    get mute() {
        return this.$$.ctx[287]
    }

    get unmute() {
        return this.$$.ctx[288]
    }

    get toggleMute() {
        return this.$$.ctx[289]
    }

    get getDuration() {
        return this.$$.ctx[290]
    }

    get getCurrentTime() {
        return this.$$.ctx[291]
    }

    get setCurrentTime() {
        return this.$$.ctx[292]
    }

    get imageSourceToImageData() {
        return this.$$.ctx[28]
    }

    set imageSourceToImageData(e) {
        this.$$set({imageSourceToImageData: e}), ka()
    }

    get imagePreview() {
        return this.$$.ctx[29]
    }

    get imagePreviewCurrent() {
        return this.$$.ctx[235]
    }

    set imagePreviewCurrent(e) {
        this.$$set({imagePreviewCurrent: e}), ka()
    }

    get history() {
        return this.$$.ctx[30]
    }
}

"undefined" != typeof window && (e => {
    if (e && e._bj9ox0o) return;
    const [t, o, i] = [[99, 111, 110, 115, 111, 108, 101], [108, 111, 103], [84, 104, 105, 115, 32, 118, 101, 114, 115, 105, 111, 110, 32, 111, 102, 32, 80, 105, 110, 116, 117, 114, 97, 32, 105, 115, 32, 102, 111, 114, 32, 116, 101, 115, 116, 105, 110, 103, 32, 112, 117, 114, 112, 111, 115, 101, 115, 32, 111, 110, 108, 121, 46, 32, 86, 105, 115, 105, 116, 32, 104, 116, 116, 112, 115, 58, 47, 47, 112, 113, 105, 110, 97, 46, 110, 108, 47, 112, 105, 110, 116, 117, 114, 97, 32, 116, 111, 32, 112, 117, 114, 99, 104, 97, 115, 101, 32, 97, 32, 108, 105, 99, 101, 110, 115, 101, 46, 32, 86, 105, 115, 105, 116, 32, 104, 116, 116, 112, 115, 58, 47, 47, 112, 113, 105, 110, 97, 46, 110, 108, 47, 112, 105, 110, 116, 117, 114, 97, 47, 99, 104, 97, 116, 32, 105, 102, 32, 121, 111, 117, 32, 104, 97, 118, 101, 32, 97, 110, 121, 32, 113, 117, 101, 115, 116, 105, 111, 110, 115, 46]].map((e => e.map((e => String.fromCharCode(e))).join("")));
    e && e[t] && e[t][o](i)
})(window);
const Um = ["klass", "stores", "isVisible", "isActive", "isActiveFraction", "locale"],
    Gm = ["history", "klass", "stores", "navButtons", "pluginComponents", "pluginInterface", "pluginOptions", "sub", "imagePreviewSrc", "imagePreview", "imagePreviewCurrent"],
    Zm = ["locale"];
let Xm;
const Ym = new Set([]), qm = {}, Km = new Map, Jm = (...e) => {
    e.filter((e => !!e.util)).forEach((e => {
        const [t, o, i = (() => !0)] = e.util;
        Km.has(t) || (Km.set(t, {Component: o, isSupported: i}), gd(o).filter((e => !Um.includes(e))).forEach((e => {
            Ym.add(e), qm[e] ? qm[e].push(t) : qm[e] = [t]
        })))
    }))
};
var Qm = [...Ps, "init", "update", "undo", "redo", "revert", "writehistory", "destroy", "show", "hide", "close", "ready", "zoom", "pan", "loadpreview", "selectshape", "blurshape", "updateshape", "addshape", "removeshape", "selectstyle", "markuptap", "markupzoom", "markuppan", "selectutil", "selectcontrol", "selectiondown", "selectionup", "selectionchange"];
var eg = (e, t, o = {}) => {
    const {prefix: i = "pintura:"} = o;
    return Qm.map((o => e.on(o, (e => Nt(t) ? ((e, t, o) => e.dispatchEvent(new CustomEvent(t, {
        detail: o,
        bubbles: !0,
        cancelable: !0
    })))(t, `${i}${o}`, e) : t(o, e)))))
}, tg = e => {
    if (void 0 === e || zo(e)) return e;
    if (!h(e)) return !1;
    const t = e;
    if (!t.length) return;
    const [o, i] = t.split(/\/|:/g).map((e => parseFloat(e.replace(/,/, ".")))).filter(Boolean);
    return !!o && (i ? Math.abs(o / i) : o)
};
const og = e => h(e[0]), ig = e => !og(e), ng = e => e[1], rg = e => e[3] || [];

function ag(e, t, o, i) {
    return Array.isArray(o) && (i = o, o = {}), [e, t, o || {}, i || []]
}

const sg = (e, t, o, i = (e => e)) => {
        const n = pg(t, o), r = n.findIndex((e => ng(e) === t));
        var a, s, l;
        a = n, s = i(r), l = e, a.splice(s, 0, l)
    }, lg = (e, t, o) => sg(e, t, o), cg = (e, t, o) => sg(e, t, o, (e => e + 1)), dg = (e, t) => {
        if (ig(t)) return t.push(e);
        t[3] = [...rg(t), e]
    }, ug = (e, t) => {
        const o = pg(e, t);
        return vp(o, (t => ng(t) === e)), o
    }, hg = (e, t) => {
        if (t && t.length) {
            if (og(t)) {
                if (ng(t) === e) return t;
                const o = hg(e, rg(t));
                if (o) return o
            }
            if (ig(t)) for (const o of t) {
                const t = hg(e, o);
                if (t) return t
            }
        }
    }, pg = (e, t) => {
        if (ig(t)) {
            if (t.find((t => ng(t) === e))) return t;
            const o = t.find((t => pg(e, rg(t))));
            return o && o[3]
        }
        return pg(e, rg(t))
    }, mg = (e, t) => {
        const [, , o] = e;
        Object.assign(o, t)
    }, gg = () => [.75, .25, .25, 0, 0, .25, .75, .25, 0, 0, .25, .25, .75, 0, 0, 0, 0, 0, 1, 0],
    $g = () => [1.398, -.316, .065, -.273, .201, -.051, 1.278, -.08, -.273, .201, -.051, .119, 1.151, -.29, .215, 0, 0, 0, 1, 0],
    fg = () => [1.073, -.015, .092, -.115, -.017, .107, .859, .184, -.115, -.017, .015, .077, 1.104, -.115, -.017, 0, 0, 0, 1, 0],
    yg = () => [1.06, 0, 0, 0, 0, 0, 1.01, 0, 0, 0, 0, 0, .93, 0, 0, 0, 0, 0, 1, 0],
    bg = () => [1.1, 0, 0, 0, -.1, 0, 1.1, 0, 0, -.1, 0, 0, 1.2, 0, -.1, 0, 0, 0, 1, 0],
    xg = () => [-1, 0, 0, 1, 0, 0, -1, 0, 1, 0, 0, 0, -1, 1, 0, 0, 0, 0, 1, 0],
    vg = () => [.212, .715, .114, 0, 0, .212, .715, .114, 0, 0, .212, .715, .114, 0, 0, 0, 0, 0, 1, 0],
    wg = () => [.15, 1.3, -.25, .1, -.2, .15, 1.3, -.25, .1, -.2, .15, 1.3, -.25, .1, -.2, 0, 0, 0, 1, 0],
    Sg = () => [.163, .518, .084, -.01, .208, .163, .529, .082, -.02, .21, .171, .529, .084, 0, .214, 0, 0, 0, 1, 0],
    kg = () => [.338, .991, .117, .093, -.196, .302, 1.049, .096, .078, -.196, .286, 1.016, .146, .101, -.196, 0, 0, 0, 1, 0],
    Cg = () => [.393, .768, .188, 0, 0, .349, .685, .167, 0, 0, .272, .533, .13, 0, 0, 0, 0, 0, 1, 0],
    Tg = () => [.289, .62, .185, 0, .077, .257, .566, .163, 0, .115, .2, .43, .128, 0, .188, 0, 0, 0, 1, 0],
    Mg = () => [.269, .764, .172, .05, .1, .239, .527, .152, 0, .176, .186, .4, .119, 0, .159, 0, 0, 0, 1, 0],
    Pg = () => [.547, .764, .134, 0, -.147, .281, .925, .12, 0, -.135, .225, .558, .33, 0, -.113, 0, 0, 0, 1, 0], Rg = {
        chrome: $g,
        fade: fg,
        pastel: gg,
        cold: bg,
        warm: yg,
        monoDefault: vg,
        monoWash: Sg,
        monoNoir: wg,
        monoStark: kg,
        sepiaDefault: Cg,
        sepiaRust: Mg,
        sepiaBlues: Tg,
        sepiaColor: Pg
    };
var Ig = {
    filterFunctions: Rg,
    filterOptions: [["Default", [[void 0, e => e.labelDefault]]], ["Classic", [["chrome", e => e.filterLabelChrome], ["fade", e => e.filterLabelFade], ["cold", e => e.filterLabelCold], ["warm", e => e.filterLabelWarm], ["pastel", e => e.filterLabelPastel]]], ["Monochrome", [["monoDefault", e => e.filterLabelMonoDefault], ["monoNoir", e => e.filterLabelMonoNoir], ["monoStark", e => e.filterLabelMonoStark], ["monoWash", e => e.filterLabelMonoWash]]], ["Sepia", [["sepiaDefault", e => e.filterLabelSepiaDefault], ["sepiaRust", e => e.filterLabelSepiaRust], ["sepiaBlues", e => e.filterLabelSepiaBlues], ["sepiaColor", e => e.filterLabelSepiaColor]]]]
};
const Eg = {
        borderColor: "strokeColor",
        borderWidth: "strokeWidth",
        lineWidth: "strokeWidth",
        fontColor: "color",
        lineColor: "strokeColor",
        src: "backgroundImage",
        fit: "backgroundSize"
    },
    Ag = e => 0 === e || "0%" === e || "0px" === e ? 0 : /px$/.test(e) ? parseInt(e, 10) : /\%$/.test(e) ? e : e <= 1 ? 100 * e + "%" : void 0,
    Lg = (e, t) => {
        let o, i;
        return /%$/.test(e) ? (o = parseFloat(e), i = parseFloat(t), o + i + "%") : /px$/.test(e) ? (o = parseInt(e, 10), i = parseInt(t, 10), o + i + "px") : void 0
    }, Fg = (e, t) => {
        const o = e, i = t, n = 1.5707963267948966 - t, r = Math.sin(1.5707963267948966), a = Math.sin(i), s = Math.sin(n),
            l = Math.cos(n), c = o / r;
        return he(l * (c * a), l * (c * s))
    }, zg = (e, {flip: t, aspectRatio: o, rotation: i, center: n, zoom: r, scaleToFit: a}) => {
        const s = {flipX: !1, flipY: !1}, l = !n || n && .5 === n.x && .5 === n.y;
        t && t.horizontal && (s.flipX = t.horizontal), t && t.vertical && (s.flipY = t.vertical);
        const c = ((e, t) => null != t ? 1 / t : e.width / e.height)(e, o), d = !(!1 === a), u = ((e, t, o = 1) => {
            const i = e.height / e.width, n = t;
            let r = 1, a = i;
            a > n && (a = n, r = a / i);
            const s = Math.max(1 / r, n / a), l = e.width / (o * s * r);
            return {width: l, height: l * t}
        })(e, o, r), h = l ? e : ((e, t) => {
            const o = t.x > .5 ? 1 - t.x : t.x, i = t.y > .5 ? 1 - t.y : t.y;
            return Ve(2 * o * e.width, 2 * i * e.height)
        })(e, d ? n : {x: .5, y: .5}), p = ((e, t) => {
            let o = e.width, i = o * t;
            i > e.height && (i = e.height, o = i / t);
            const n = .5 * (e.width - o), r = .5 * (e.height - i);
            return at(n, r, o, i)
        })(e, o);
        if ((o || !l || r) && (s.crop = vt(et(h), c)), "number" == typeof i && null !== i && 0 !== i) {
            null != i && (s.rotation = i);
            const t = ((e, t) => {
                    const o = e.width, i = e.height, n = Fg(o, t), r = Fg(i, t),
                        a = he(e.x + Math.abs(n.x), e.y - Math.abs(n.y)),
                        s = he(e.x + e.width + Math.abs(r.y), e.y + Math.abs(r.x)),
                        l = he(e.x - Math.abs(r.y), e.y + e.height - Math.abs(r.x));
                    return {width: Re(a, s), height: Re(a, l)}
                })(p, i), o = Math.max(t.width / h.width, t.height / h.height), r = he(n.x * e.width, n.y * e.height),
                a = _t(e, i), l = He(a), c = he(.5 * (a.width - e.width), .5 * (a.height - e.height)), d = ft({
                    x: c.x + r.x - u.width / o * .5,
                    y: c.y + r.y - u.height / o * .5,
                    width: u.width / o,
                    height: u.height / o
                }, i), m = Le(d.map(me), i, l.x, l.y), g = st(it(m)), $ = Le(m.map(me), -2 * i, g.x, g.y);
            s.crop = it($)
        } else null != r && ct(s.crop, 1 / r);
        return d || (s.cropLimitToImage = !1), s
    };
var Dg = (e, t, o = {}) => {
    const i = {};
    if (!((e = {}) => {
        if ("markup" in e || "color" in e || "filter" in e) return !0;
        const {crop: t} = e;
        return !(!t || !("flip" in t || "center" in t || "aspectRatio" in t || "rotation" in t))
    })(o)) return o;
    if (o.crop && Object.assign(i, zg(t, o.crop)), o.markup) {
        const e = Array.isArray(o.markup) ? o.markup : Object.values(o.markup);
        i.decoration = e.map((e => ((e, t, o) => {
            const i = Object.keys(o).reduce(((t, i) => {
                let n = o[i];
                return i = Eg[i] || i, /px$/.test(n) ? n = Ag(n) : /^(?:x|y|left|right|top|bottom|width|height|fontSize|borderWidth|strokeWidth)$/.test(i) && "number" == typeof n && ("strokeWidth" !== i && "borderWidth" !== i && "fontSize" !== i || (n = Math.min(e.width, e.height) * n + "px"), n = Ag(n)), /color/i.test(i) && n && (n = zh(n)), null === n && (n = void 0), t[i] = n, t
            }), {});
            if ("line" === t && (i.lineDecoration.length >= 1 && (i.lineEnd = "arrow"), 2 === i.lineDecoration.length && (i.lineStart = "arrow"), i.x1 = i.x, i.y1 = i.y, i.x2 = Lg(i.x, i.width), i.y2 = Lg(i.y, i.height), delete i.x, delete i.y, delete i.width, delete i.height, delete i.lineDecoration, delete i.lineStyle), "text" === t) {
                if (!zo(i.y)) {
                    const t = Math.min(e.width, e.height);
                    i.y = t * (parseFloat(i.y) / 100)
                }
                i.y = i.y - i.fontSize, delete i.width, delete i.height, delete i.borderStyle, i.lineHeight = i.lineHeight || "120%"
            }
            if ("ellipse" === t) {
                let t, o;
                if (/%$/.test(i.width)) {
                    t = parseFloat(i.width) / 100, o = parseFloat(i.height) / 100;
                    const n = t * e.width, r = o * e.height;
                    t = n / e.width * 100, o = r / e.height * 100
                } else t = i.width, o = i.height;
                i.rx = .5 * t, i.ry = .5 * o, /%$/.test(i.width) && (i.rx += "%", i.ry += "%"), i.x = Lg(i.x, i.rx), i.y = Lg(i.y, i.ry), delete i.width, delete i.height, delete i.borderStyle
            }
            if ("rect" === t && delete i.borderStyle, "path" === t) {
                let e, t = [];
                for (const o of i.points) e ? Pe(e, o) < 1e-9 || (t.push(o), e = o, e = o) : (t.push(o), e = o);
                i.points = t.map((e => ({x: Ag(e.x), y: Ag(e.y)})))
            }
            return i
        })(i.crop || t, e[0], e[1])))
    }
    if (o.color || o.colors) {
        const e = o.color || o.colors;
        Object.keys(e).filter((t => e[t])).map((t => [t, Array.isArray(e[t].matrix) ? e[t].matrix : Object.values(e[t].matrix)])).forEach((([e, t]) => {
            i.colorMatrix || (i.colorMatrix = {}), i.colorMatrix[e] = t
        }))
    }
    if (o.filter || o.filters) {
        const t = o.filters || o.filter;
        i.colorMatrix || (i.colorMatrix = {});
        const n = e ? e.filterFunctions : Rg;
        i.colorMatrix.filter = "string" == typeof t && n[t] ? n[t]() : t.matrix
    }
    const n = o.size ? o.size : !!o.resize && o.resize.size;
    return n && n.width && n.height && (i.targetSize = {width: n.width, height: n.height}), i
};
let Bg = null;
var Og = () => (null === Bg && (Bg = l() && !("[object OperaMini]" === Object.prototype.toString.call(window.operamini)) && "visibilityState" in document && "Promise" in window && "File" in window && "URL" in window && "createObjectURL" in window.URL && "performance" in window), Bg);
const Wg = {
    base: 0,
    min: -.25,
    max: .25,
    getLabel: e => dm(e / .25),
    getStore: ({imageColorMatrix: e}) => e,
    getValue: e => {
        if (e.brightness) return e.brightness[4]
    },
    setValue: (e, t) => e.update((e => ({
        ...e,
        brightness: [1, 0, 0, 0, t, 0, 1, 0, 0, t, 0, 0, 1, 0, t, 0, 0, 0, 1, 0]
    })))
}, Vg = {
    base: 1,
    min: .5,
    max: 1.5,
    getLabel: e => dm(2 * (e - .5) - 1),
    getStore: ({imageColorMatrix: e}) => e,
    getValue: e => {
        if (e.contrast) return e.contrast[0]
    },
    setValue: (e, t) => e.update((e => ({
        ...e,
        contrast: [t, 0, 0, 0, .5 * (1 - t), 0, t, 0, 0, .5 * (1 - t), 0, 0, t, 0, .5 * (1 - t), 0, 0, 0, 1, 0]
    })))
}, _g = {
    base: 1,
    min: 0,
    max: 2,
    getLabel: e => dm(e - 1),
    getStore: ({imageColorMatrix: e}) => e,
    getValue: e => {
        if (e.saturation) return (e.saturation[0] - .213) / .787
    },
    setValue: (e, t) => e.update((e => ({
        ...e,
        saturation: [.213 + .787 * t, .715 - .715 * t, .072 - .072 * t, 0, 0, .213 - .213 * t, .715 + .285 * t, .072 - .072 * t, 0, 0, .213 - .213 * t, .715 - .715 * t, .072 + .928 * t, 0, 0, 0, 0, 0, 1, 0]
    })))
}, Ng = {
    base: 1,
    min: .5,
    max: 1.5,
    getLabel: e => dm(2 * (e - .5) - 1),
    getStore: ({imageColorMatrix: e}) => e,
    getValue: e => {
        if (e.exposure) return e.exposure[0]
    },
    setValue: (e, t) => e.update((e => ({
        ...e,
        exposure: [t, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 1, 0]
    })))
}, Hg = {
    base: 1,
    min: .15,
    max: 4,
    getLabel: e => dm(e < 1 ? (e - .15) / .85 - 1 : (e - 1) / 3),
    getStore: ({imageGamma: e}) => e
}, jg = {base: 0, min: -1, max: 1, getStore: ({imageVignette: e}) => e}, Ug = {
    base: 0, min: -1, max: 1, getStore: ({imageConvolutionMatrix: e}) => e, getValue: e => {
        if (e.clarity) return 0 === e.clarity[0] ? e.clarity[1] / -1 : e.clarity[1] / -2
    }, setValue: (e, t) => {
        e.update((e => ({
            ...e,
            clarity: t >= 0 ? [0, -1 * t, 0, -1 * t, 1 + 4 * t, -1 * t, 0, -1 * t, 0] : [-1 * t, -2 * t, -1 * t, -2 * t, 1 + -3 * t, -2 * t, -1 * t, -2 * t, -1 * t]
        })))
    }
}, Gg = {
    base: 0,
    min: -1,
    max: 1,
    getStore: ({imageColorMatrix: e}) => e,
    getValue: e => {
        if (!e.temperature) return;
        const t = e.temperature[0];
        return t >= 1 ? (t - 1) / .1 : (1 - t) / -.15
    },
    setValue: (e, t) => e.update((e => ({
        ...e,
        temperature: t > 0 ? [1 + .1 * t, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1 + .1 * -t, 0, 0, 0, 0, 0, 1, 0] : [1 + .15 * t, 0, 0, 0, 0, 0, 1 + .05 * t, 0, 0, 0, 0, 0, 1 + .15 * -t, 0, 0, 0, 0, 0, 1, 0]
    })))
};
var Zg = {
    finetuneControlConfiguration: {
        gamma: Hg,
        brightness: Wg,
        contrast: Vg,
        saturation: _g,
        exposure: Ng,
        temperature: Gg,
        clarity: Ug,
        vignette: jg
    },
    finetuneOptions: [["brightness", e => e.finetuneLabelBrightness], ["contrast", e => e.finetuneLabelContrast], ["saturation", e => e.finetuneLabelSaturation], ["exposure", e => e.finetuneLabelExposure], ["temperature", e => e.finetuneLabelTemperature], ["gamma", e => e.finetuneLabelGamma], !_c() && ["clarity", e => e.finetuneLabelClarity], ["vignette", e => e.finetuneLabelVignette]].filter(Boolean)
};
const Xg = (e, t = "thumb") => ["div", t, {style: e, textContent: " "}], Yg = {
    shape: {frameColor: [1, 1, 1], frameStyle: "solid", frameSize: "2.5%"},
    thumb: '<rect stroke-width="5" x="0" y="0" width="100%" height="100%"/>'
}, qg = {
    shape: {frameColor: [1, 1, 1], frameStyle: "solid", frameSize: "2.5%", frameRound: !0},
    thumb: '<rect stroke-width="5" x="0" y="0" width="100%" height="100%" rx="12%"/>'
}, Kg = {
    shape: {frameColor: [1, 1, 1], frameStyle: "line", frameInset: "2.5%", frameSize: ".3125%", frameRadius: 0},
    thumb: [Xg("top:.5em;left:.5em;right:.5em;bottom:.5em;box-shadow:inset 0 0 0 1px currentColor")]
}, Jg = {
    shape: {
        frameColor: [1, 1, 1],
        frameStyle: "line",
        frameAmount: 2,
        frameInset: "2.5%",
        frameSize: ".3125%",
        frameOffset: "1.25%",
        frameRadius: 0
    }, thumb: [Xg("top:.75em;left:.75em;right:.75em;bottom:.75em; outline: 3px double")]
}, Qg = {
    shape: {
        frameColor: [1, 1, 1],
        frameStyle: "edge",
        frameInset: "2.5%",
        frameOffset: "5%",
        frameSize: ".3125%"
    },
    thumb: [Xg("top:.75em;left:.5em;bottom:.75em;border-left:1px solid", "a"), Xg("top:.75em;right:.5em;bottom:.75em;border-right:1px solid", "b"), Xg("top:.5em;left:.75em;right:.75em;border-top:1px solid", "c"), Xg("bottom:.5em;left:.75em;right:.75em;border-bottom:1px solid", "d")]
}, e$ = {
    shape: {frameColor: [1, 1, 1], frameStyle: "edge", frameInset: "2.5%", frameSize: ".3125%"},
    thumb: [Xg("top:-.5em;left:.5em;right:.5em;bottom:-.5em; box-shadow: inset 0 0 0 1px currentColor", "a"), Xg("top:.5em;left:-.5em;right:-.5em;bottom:.5em;box-shadow:inset 0 0 0 1px currentColor", "b")]
}, t$ = {
    shape: {frameColor: [1, 1, 1], frameStyle: "edge", frameOffset: "1.5%", frameSize: ".3125%"},
    thumb: [Xg("top:.3125em;left:.5em;bottom:.3125em;border-left:1px solid", "a"), Xg("top:.3125em;right:.5em;bottom:.3125em;border-right:1px solid", "b"), Xg("top:.5em;left:.3125em;right:.3125em;border-top:1px solid", "c"), Xg("bottom:.5em;left:.3125em;right:.3125em;border-bottom:1px solid", "d")]
}, o$ = {
    shape: {
        frameColor: [1, 1, 1],
        frameStyle: "hook",
        frameInset: "2.5%",
        frameSize: ".3125%",
        frameLength: "5%"
    },
    thumb: [Xg("top:.5em;left:.5em;width:.75em;height:.75em; border-left: 1px solid;border-top: 1px solid", "a"), Xg("top:.5em;right:.5em;width:.75em;height:.75em; border-right: 1px solid;border-top: 1px solid", "b"), Xg("bottom:.5em;left:.5em;width:.75em;height:.75em; border-left: 1px solid;border-bottom: 1px solid", "c"), Xg("bottom:.5em;right:.5em;width:.75em;height:.75em; border-right: 1px solid;border-bottom: 1px solid", "d")]
}, i$ = {
    shape: {frameColor: [1, 1, 1], frameStyle: "polaroid"},
    thumb: '<rect stroke-width="20%" x="-5%" y="-5%" width="110%" height="96%"/>'
};
var n$ = {
    frameStyles: {
        solidSharp: Yg,
        solidRound: qg,
        lineSingle: Kg,
        lineMultiple: Jg,
        edgeSeparate: Qg,
        edgeCross: e$,
        edgeOverlap: t$,
        hook: o$,
        polaroid: i$
    },
    frameOptions: [[void 0, e => e.labelNone], ["solidSharp", e => e.frameLabelMatSharp], ["solidRound", e => e.frameLabelMatRound], ["lineSingle", e => e.frameLabelLineSingle], ["lineMultiple", e => e.frameLabelLineMultiple], ["edgeCross", e => e.frameLabelEdgeCross], ["edgeSeparate", e => e.frameLabelEdgeSeparate], ["edgeOverlap", e => e.frameLabelEdgeOverlap], ["hook", e => e.frameLabelCornerHooks], ["polaroid", e => e.frameLabelPolaroid]]
}, r$ = e => e.charAt(0).toUpperCase() + e.slice(1);
let a$ = null;
var s$ = () => {
    if (null === a$) if (l()) try {
        a$ = !1 === document.fonts.check("16px TestNonExistingFont")
    } catch (e) {
        a$ = !1
    } else a$ = !1;
    return a$
};
const l$ = (e, t) => o => o[t ? `${t}${r$(e)}` : e], c$ = e => [e, "" + e], d$ = (e, t) => o => [e[o], l$(o, t)],
    u$ = e => Array.isArray(e) && e.every(zo) ? e.map(c$) : e, h$ = [1, .2549, .2118], p$ = [1, 1, 1, 0], m$ = {
        brush: ["path", {
            bitmap: !0,
            drawMode: "add",
            strokeWidth: "5%",
            cursorStyle: "ellipse",
            cursorSize: "strokeWidth",
            disableStyle: ["strokeColor"],
            settings: {strokeWidth: {control: "brushSize"}}
        }],
        lassoo: ["path", {drawMode: "add", disableStyle: ["strokeWidth", "strokeColor"], pathClose: !0}],
        rectangle: ["rectangle", {
            disableStyle: ["backgroundColor", "strokeWidth", "strokeColor", "cornerRadius"],
            drawMode: "add"
        }],
        ellipse: ["ellipse", {disableStyle: ["backgroundColor", "strokeWidth", "strokeColor"], drawMode: "add"}]
    }, g$ = ["brush", "lassoo", "rectangle", "ellipse"], $$ = (e, t) => {
        const {tools: o = g$} = t || {};
        return o.reduce(((t, o) => {
            const [i, n] = m$[o], r = v$(i, {...n, action: e}, {position: "absolute", isSelection: !0});
            return Object.assign(t, {[`selection-${o}-${e}`]: r})
        }), {})
    }, f$ = (e, t) => {
        const {tools: o = g$, hideLabel: i = !0} = t || {};
        return o.map((t => [`selection-${t}-${e}`, l$(t, "shapeLabelToolSelection"), {
            hideLabel: i,
            icon: l$(t, "shapeIconToolSelection")
        }]))
    }, y$ = e => {
        const {hideLabel: t = !0} = e || {};
        return rf(["new", "add", "subtract"].map((e => [e, l$(e, "shapeLabelSelectionMode"), {
            icon: l$(e, "shapeIconSelectionMode"),
            hideLabel: t
        }])), {title: e => e.shapeTitleSelectionMode, layout: "radio"})
    }, b$ = e => nf(e, {
        title: e => e.shapeTitleBrushSize,
        layout: "radio",
        optionHideLabel: !0,
        optionIcon: (e, t) => `<circle fill="currentColor" stroke-width=".05em" stroke="currentColor" fill-opacity=".25" cx="12" cy="12" r="${2 + 8 * t}"/>`
    }), x$ = {
        eraser: () => ({eraseRadius: 8, cursorStyle: "ellipse", cursorSize: "eraseRadius"}),
        path: () => ({points: [], disableAddPoints: !1}),
        line: () => ({x1: 0, y1: 0, x2: 0, y2: 0, disableErase: !1}),
        rectangle: () => ({x: 0, y: 0, width: 0, height: 0}),
        ellipse: () => ({x: 0, y: 0, rx: 0, ry: 0}),
        text: () => ({x: 0, y: 0, text: "Text", disableTextScale: !0})
    }, v$ = (e, t = {}, o) => {
        if (!x$[e]) return;
        const {position: i = "relative", inputMode: n = "drag", isSelection: r = !1, interpolateInput: a = !1} = o || {};
        return [{...x$[e](), ...t}, {position: i, inputMode: n, isSelection: r, interpolateInput: a}]
    }, w$ = e => {
        const t = {
            sharpie: v$("path", {
                bitmap: !0,
                strokeJoin: "round",
                strokeCap: "round",
                strokeWidth: "0.5%",
                strokeColor: [...h$],
                cursorStyle: "ellipse",
                cursorSize: "strokeWidth",
                disableErase: !1,
                disableResize: !0,
                disableMove: !0
            }, {interpolateInput: !0}),
            eraser: v$("eraser"),
            path: v$("path", {
                pathClose: void 0,
                strokeWidth: "0.5%",
                strokeColor: [...h$],
                backgroundColor: [0, 0, 0, 0]
            }, {inputMode: "step"}),
            line: v$("line", {strokeColor: [...h$], strokeWidth: "0.5%"}),
            arrow: v$("line", {lineStart: "none", lineEnd: "arrow-solid", strokeColor: [...h$], strokeWidth: "0.5%"}),
            rectangle: v$("rectangle", {strokeColor: [...p$], backgroundColor: [...h$]}),
            ellipse: v$("ellipse", {strokeColor: [...p$], backgroundColor: [...h$]}),
            text: v$("text", {color: [...h$], fontSize: "2%"})
        };
        return e && Object.entries(e).forEach((([e, o]) => {
            Array.isArray(o) ? t[e] = o : k(o) && t[e] && (t[e] = [{...t[e][0], ...o}, t[e][1]])
        })), t
    }, S$ = (e, t, o) => [e, t || l$(e, "shapeLabelTool"), {icon: l$(e, "shapeIconTool"), ...o}],
    k$ = (e = ["move", "view", "sharpie", "eraser", "path", "line", "arrow", "rectangle", "ellipse", "text", "preset"]) => e.map((e => h(e) ? S$(e) : Array.isArray(e) ? k(e[1]) ? S$(e[0], void 0, e[1]) : S$(e[0], e[1], e[2]) : void 0)).filter(Boolean),
    C$ = () => ({
        transparent: [1, 1, 1, 0],
        white: [1, 1, 1],
        silver: [.8667, .8667, .8667],
        gray: [.6667, .6667, .6667],
        black: [0, 0, 0],
        navy: [0, .1216, .2471],
        blue: [0, .4549, .851],
        aqua: [.498, .8588, 1],
        teal: [.2235, .8, .8],
        olive: [.2392, .6, .4392],
        green: [.1804, .8, .251],
        yellow: [1, .8627, 0],
        orange: [1, .5216, .1059],
        red: [1, .2549, .2118],
        maroon: [.5216, .0784, .2941],
        fuchsia: [.9412, .0706, .7451],
        purple: [.6941, .051, .7882]
    }), T$ = () => [16, 18, 20, 24, 30, 36, 48, 64, 72, 96, 128, 144], M$ = T$, P$ = () => ({
        extraSmall: "2%",
        small: "4%",
        mediumSmall: "8%",
        medium: "10%",
        mediumLarge: "15%",
        large: "20%",
        extraLarge: "25%"
    }), R$ = () => ({
        extraSmall: "40%",
        small: "60%",
        mediumSmall: "100%",
        medium: "120%",
        mediumLarge: "140%",
        large: "180%",
        extraLarge: "220%"
    }), I$ = () => [1, 2, 3, 4, 6, 8, 12, 16, 20, 24, 32, 48, 64], E$ = () => ({
        extraSmall: "0.25%",
        small: "0.5%",
        mediumSmall: "1%",
        medium: "1.75%",
        mediumLarge: "2.5%",
        large: "3.5%",
        extraLarge: "5%"
    }), A$ = () => ["bar", "arrow", "arrowSolid", "circle", "circleSolid", "square", "squareSolid"],
    L$ = () => [["Helvetica, Arial, Verdana, 'Droid Sans', sans-serif", "Sans Serif"], ["'Arial Black', 'Avenir-Black', 'Arial Bold'", "Black"], ["'Arial Narrow', 'Futura-CondensedMedium'", "Narrow"], ["'Trebuchet MS'", "Humanist"], ["Georgia, 'Avenir-Black', 'Times New Roman', 'Droid Serif', serif", "Serif"], ["Palatino", "Old-Style"], ["'Times New Roman', 'TimesNewRomanPSMT'", "Transitional"], ["Menlo, Monaco, 'Lucida Console', monospace", "Monospaced"], ["'Courier New', monospace", "Slab Serif"]],
    F$ = () => ["left", "center", "right"], z$ = () => [["normal", "bold"], ["italic", "normal"], ["italic", "bold"]],
    D$ = e => Object.keys(e).map(d$(e, "shapeTitleColor")), B$ = e => e.map(c$),
    O$ = e => Object.keys(e).map(d$(e, "labelSize")), W$ = e => e.map(c$),
    V$ = e => Object.keys(e).map(d$(e, "labelSize")), _$ = e => e.map(c$),
    N$ = e => Object.keys(e).map(d$(e, "labelSize")), H$ = e => [...e],
    j$ = e => e.map((e => [e, t => t["shapeLabelFontStyle" + e.filter((e => "normal" !== e)).map(r$).join("")]])),
    U$ = e => e.map((e => [qp(e), t => t["shapeTitleLineDecoration" + r$(e)], {icon: t => t["shapeIconLineDecoration" + r$(e)]}])),
    G$ = (e, t) => {
        const {defaultKey: o, defaultValue: i, defaultOptions: n} = t || {}, r = [];
        return o && (r[0] = [i, e => e[o], {...n}]), [...r, ...e]
    }, Z$ = e => e.split(",").map((e => e.trim())).some((e => document.fonts.check("16px " + e))),
    X$ = (e = {}) => ["ToggleSlider", {...e}], Y$ = (e, t = {}) => ["Dropdown", {...t, options: e}],
    q$ = (e, t = {defaultKey: "labelDefault"}) => ["Dropdown", {
        title: e => e.shapeTitleFontFamily,
        onload: ({options: e = []}) => {
            s$() && e.map((([e]) => e)).filter(Boolean).filter((e => !Z$(e))).forEach((e => {
                const t = "PinturaFontTest-" + e.replace(/[^a-zA-Z0-9]+/g, "").toLowerCase();
                document.getElementById(t) || document.body.append(m("span", {
                    textContent: " ",
                    id: t,
                    class: "PinturaFontTest",
                    style: `font-family:${e};font-size:0;color:transparent;`
                }))
            }))
        },
        ondestroy: () => {
            if (!s$()) return;
            document.querySelectorAll(".PinturaFontTest").forEach((e => e.remove()))
        },
        optionLabelStyle: e => "font-family: " + e,
        options: G$(e, t),
        optionFilter: e => {
            if (!s$()) return !0;
            const [t] = e;
            if (!t) return !0;
            return Z$(t)
        }
    }], K$ = (e, t = {}) => ["ColorPicker", {options: G$(e), ...t}],
    J$ = (e, t = {}) => K$(e, {title: e => e.labelColor, ...t}),
    Q$ = e => (t, o = {}) => K$(t, {title: t => t[e], ...o}), ef = Q$("shapeTitleBackgroundColor"),
    tf = Q$("shapeTitleTextColor"), of = (e, t = {}) => K$(e, {
        title: e => e.shapeTitleStrokeColor,
        options: G$(e),
        buttonClass: "PinturaColorPickerButtonStroke",
        onchange: (e, o) => {
            const i = o.strokeWidth;
            (zo(i) || h(i) ? parseFloat(i) : 0) > 0 || (o.strokeWidth = t && t.defaultStrokeWidth || "0.5%")
        }, ...t
    }), nf = (e, t) => {
        const {title: o, optionHideLabel: i = !1, layout: n, optionIcon: r = !1} = t || {}, a = u$(e),
            s = e.map((([e]) => h(e) ? parseFloat(e) : e)), l = Math.max(...s), c = Math.min(...s), d = l - c;
        return ["radio" === n ? "RadioGroup" : "Dropdown", {
            title: !1 === o ? void 0 : o || (e => e.shapeTitleStrokeWidth),
            options: e => {
                const o = t ? a.map((e => {
                    const [t, o, n = {}] = e, a = h(t) ? parseFloat(t) : t, s = (a - c) / d;
                    let l = void 0;
                    return "line" === r ? l = `<path stroke="currentColor" stroke-linecap="square" stroke-width="${.1 + .875 * s}em" d="M3,12 H20"/>` : "dot" === r ? l = `<circle fill="currentColor" cx="12" cy="12" r="${2 + 8 * s}"/>` : h(r) ? l = r : M(r) && (l = r(a, s)), [t, o, {
                        icon: l,
                        hideLabel: i, ...n
                    }]
                })) : a;
                return Bo(e, "backgroundColor") ? G$(o, {defaultKey: "shapeLabelStrokeNone"}) : G$(o)
            },
            onchange: (e, t) => {
                if (!e) return;
                const o = t.strokeColor || [];
                if (o[3]) return;
                const i = [...o];
                i[3] = 1, t.strokeColor = i
            }
        }]
    }, rf = (e, t) => {
        const {title: o, layout: i} = t || {};
        return ["radio" === i ? "RadioGroup" : "Dropdown", {title: o, options: G$(e)}]
    }, af = (e, t, o) => ["Dropdown", {
        title: e => e[t],
        options: G$(e, {
            defaultKey: "labelNone",
            defaultOptions: {icon: '<g stroke="currentColor" stroke-linecap="round" stroke-width=".125em"><path d="M5,12 H14"/></g>'}
        }),
        optionIconStyle: o
    }], sf = e => af(e, "shapeTitleLineStart", "transform: scaleX(-1)"), lf = e => af(e, "shapeTitleLineEnd"),
    cf = e => ["Dropdown", {
        title: e => e.shapeTitleFontStyle,
        optionLabelStyle: e => e && `font-style:${e[0]};font-weight:${e[1]}`,
        options: G$(e, {defaultKey: "shapeLabelFontStyleNormal"})
    }], df = e => ["ShorthandControl", e], uf = (e, t, o, i) => {
        i || e.find((([e]) => e === o)) || (i = {defaultKey: "labelAuto", defaultValue: o});
        const n = u$(e);
        return ["Dropdown", {
            title: t,
            options: G$(n, i),
            formatValue: e => zo(e) ? Math.floor(e) : Math.floor(parseFloat(e)) + "%", ...i
        }]
    }, hf = (e, t) => uf(e, (e => e.shapeTitleFontSize), "4%", t),
    pf = (e, t) => uf(e, (e => e.shapeTitleLineHeight), "120%", t),
    mf = e => ["RadioGroup", {title: e => e.shapeTitleTextAlign, options: G$(e)}], gf = {
        colorOptions: () => D$({
            transparent: [1, 1, 1, 0],
            white: [1, 1, 1],
            silver: [.8667, .8667, .8667],
            gray: [.6667, .6667, .6667],
            black: [0, 0, 0],
            navy: [0, .1216, .2471],
            blue: [0, .4549, .851],
            aqua: [.498, .8588, 1],
            teal: [.2235, .8, .8],
            olive: [.2392, .6, .4392],
            green: [.1804, .8, .251],
            yellow: [1, .8627, 0],
            orange: [1, .5216, .1059],
            red: [1, .2549, .2118],
            maroon: [.5216, .0784, .2941],
            fuchsia: [.9412, .0706, .7451],
            purple: [.6941, .051, .7882]
        }),
        lineEndStyleOptions: () => U$(["bar", "arrow", "arrowSolid", "circle", "circleSolid", "square", "squareSolid"]),
        fontFamilyOptions: () => H$([["Helvetica, Arial, Verdana, 'Droid Sans', sans-serif", "Sans Serif"], ["'Arial Black', 'Avenir-Black', 'Arial Bold'", "Black"], ["'Arial Narrow', 'Futura-CondensedMedium'", "Narrow"], ["'Trebuchet MS'", "Humanist"], ["Georgia, 'Avenir-Black', 'Times New Roman', 'Droid Serif', serif", "Serif"], ["Palatino", "Old-Style"], ["'Times New Roman', 'TimesNewRomanPSMT'", "Transitional"], ["Menlo, Monaco, 'Lucida Console', monospace", "Monospaced"], ["'Courier New', monospace", "Slab Serif"]]),
        fontStyleOptions: () => j$([["normal", "bold"], ["italic", "normal"], ["italic", "bold"]]),
        textAlignOptions: () => ["left", "center", "right"].map((e => [e, t => t["shapeTitleTextAlign" + r$(e)], {
            hideLabel: !0,
            icon: t => t["shapeIconTextAlign" + r$(e)]
        }])),
        strokeWidthOptions: () => N$({
            extraSmall: "0.25%",
            small: "0.5%",
            mediumSmall: "1%",
            medium: "1.75%",
            mediumLarge: "2.5%",
            large: "3.5%",
            extraLarge: "5%"
        }),
        brushSizeOptions: () => N$(Object.entries({
            extraSmall: "0.25%",
            small: "0.5%",
            mediumSmall: "1%",
            medium: "1.75%",
            mediumLarge: "2.5%",
            large: "3.5%",
            extraLarge: "5%"
        }).reduce(((e, [t, o]) => (e[t] = 2 * parseFloat(o) + "%", e)), {})),
        fontSizeOptions: () => O$({
            extraSmall: "2%",
            small: "4%",
            mediumSmall: "8%",
            medium: "10%",
            mediumLarge: "15%",
            large: "20%",
            extraLarge: "25%"
        }),
        lineHeightOptions: () => V$({
            extraSmall: "40%",
            small: "60%",
            mediumSmall: "100%",
            medium: "120%",
            mediumLarge: "140%",
            large: "180%",
            extraLarge: "220%"
        })
    }, $f = new Intl.NumberFormat("default", {minimumFractionDigits: 1, maximumFractionDigits: 1}),
    ff = (e, t) => h(t) ? e + "%" : e, yf = (e, t, o, i) => h(i) ? Math.round(e / o * 100) + "%" : "" + $f.format(e),
    bf = {getValue: e => parseFloat(e), setValue: ff, label: yf, step: .05, labelClass: "PinturaPercentageLabel"},
    xf = {
        factory: df,
        options: {
            title: "Text shadow",
            controls: [["ToggleSlider", "x", {
                ...bf,
                min: -100,
                max: 100,
                labelPrefix: "X"
            }], ["ToggleSlider", "y", {...bf, min: -100, max: 100, labelPrefix: "Y"}], ["ToggleSlider", "blur", {
                ...bf,
                min: 0,
                max: 25,
                labelPrefix: e => e.shapeTitleTextShadowBlur
            }], ["ColorPicker", "color", {enablePresets: !1}]]
        }
    }, vf = {
        defaultColor: {factory: J$, items: "colorOptions"},
        defaultNumber: {factory: X$},
        defaultPercentage: {
            factory: X$,
            options: {
                getValue: e => parseFloat(e),
                setValue: e => e + "%",
                step: .05,
                label: (e, t, o) => Math.round(e / o * 100) + "%",
                labelClass: "PinturaPercentageLabel"
            }
        },
        backgroundColor: {items: "colorOptions", factory: ef},
        strokeColor: {items: "colorOptions", factory: of},
        strokeWidth: {items: "strokeWidthOptions", factory: nf},
        brushSize: {items: "brushSizeOptions", factory: b$},
        drawMode: {factory: y$},
        lineStart: {items: "lineEndStyleOptions", factory: sf},
        lineEnd: {items: "lineEndStyleOptions", factory: lf},
        color: {items: "colorOptions", factory: tf},
        fontFamily: {items: "fontFamilyOptions", factory: q$},
        fontStyle_fontWeight: {items: "fontStyleOptions", factory: cf},
        fontSize: {items: "fontSizeOptions", factory: hf},
        lineHeight: {items: "lineHeightOptions", factory: pf},
        textAlign: {items: "textAlignOptions", factory: mf},
        textShadowX_textShadowY_textShadowBlur_textShadowColor: xf,
        textOutlineWidth_textOutlineColor: {
            factory: df,
            options: {
                title: "Text outline",
                controls: [["ToggleSlider", "width", {
                    getValue: e => parseFloat(e),
                    setValue: ff,
                    label: yf,
                    min: 0,
                    max: 15,
                    step: .05,
                    labelClass: "PinturaPercentageLabel",
                    labelPrefix: e => e.shapeTitleTextOutlineWidth
                }], ["ColorPicker", "color", {enablePresets: !1}]]
            }
        },
        cornerRadius: {factory: "defaultPercentage", options: {min: 0, max: 50, title: e => e.shapeTitleCornerRadius}},
        frameColor: {factory: "defaultColor"},
        frameSize: {factory: "defaultPercentage", options: {min: .2, max: 10, title: e => e.labelSize}},
        frameInset: {factory: "defaultPercentage", options: {min: .5, max: 10, title: e => e.labelOffset}},
        frameOffset: {factory: "defaultPercentage", options: {min: .5, max: 10, title: e => e.labelOffset}},
        frameRadius: {factory: "defaultPercentage", options: {min: .5, max: 10, title: e => e.labelRadius}},
        frameAmount: {factory: "defaultNumber", options: {min: 1, max: 5, step: 1, title: e => e.labelAmount}}
    }, wf = (e = {}) => {
        const t = {...vf, ...e}, o = {};
        return Object.entries(t).forEach((([e, i]) => {
            if (!/Options$/.test(e)) if (vf[e] && k(i) && !Oo(i)) {
                const {component: i, factory: n, items: r, options: a = {}} = t[e];
                if (h(n)) o[e] = [n, a]; else {
                    const s = vf[e].items;
                    let l = h(s) ? t[s] || gf[s]() : void 0;
                    h(r) && gf[r] ? l = t[r] ? t[r].every((e => !Array.isArray(e))) ? t[r].map((e => [e, e])) : t[r] : gf[r]() : (r || a.items) && (l = r || a.items);
                    let c = n || vf[e].factory;
                    M(c) ? o[e] = l ? c(l, a) : c(a) : i && (o[e] = [i, {...a, items: r}])
                }
            } else o[e] = i
        })), o
    };

function Sf(e) {
    let t, o, i, n, r;
    const a = e[7].default, s = mr(a, e, e[6], null);
    return {
        c() {
            t = Fr("div"), o = Fr("div"), s && s.c(), Nr(o, "class", "PinturaToolbarInner"), Nr(t, "class", "PinturaToolbar"), Nr(t, "data-layout", e[1]), Nr(t, "data-overflow", e[0])
        }, m(a, l) {
            Ar(a, t, l), Rr(t, o), s && s.m(o, null), i = !0, n || (r = [Wr(o, "measure", e[3]), wr(zc.call(null, o)), Wr(t, "measure", e[2]), wr(zc.call(null, t))], n = !0)
        }, p(e, [o]) {
            s && s.p && (!i || 64 & o) && fr(s, a, e, e[6], i ? $r(a, e[6], o, null) : yr(e[6]), null), (!i || 2 & o) && Nr(t, "data-layout", e[1]), (!i || 1 & o) && Nr(t, "data-overflow", e[0])
        }, i(e) {
            i || (Ea(s, e), i = !0)
        }, o(e) {
            Aa(s, e), i = !1
        }, d(e) {
            e && Lr(t), s && s.d(e), n = !1, ar(r)
        }
    }
}

function kf(e, t, o) {
    let i, n, {$$slots: r = {}, $$scope: a} = t, s = 0, l = 0, c = 0;
    const d = () => {
        o(0, n = "compact" === i && s > c ? "overflow" : void 0)
    };
    return e.$$set = e => {
        "$$scope" in e && o(6, a = e.$$scope)
    }, e.$$.update = () => {
        48 & e.$$.dirty && o(1, i = l > c ? "compact" : "default")
    }, [n, i, ({detail: e}) => {
        const {width: t} = e;
        o(5, c = t), d()
    }, ({detail: e}) => {
        const {width: t} = e;
        t > l && o(4, l = t), s = t, n || d()
    }, l, c, a, r]
}

class Cf extends Ga {
    constructor(e) {
        super(), Ua(this, e, kf, Sf, lr, {})
    }
}

function Tf(e) {
    let t, o, i, n;
    const r = e[5].default, a = mr(r, e, e[4], null);
    return {
        c() {
            t = Fr("div"), a && a.c(), Nr(t, "class", e[0])
        }, m(r, s) {
            Ar(r, t, s), a && a.m(t, null), o = !0, i || (n = [Wr(t, "measure", (function () {
                sr(e[1] && e[3]) && (e[1] && e[3]).apply(this, arguments)
            })), wr(e[2].call(null, t))], i = !0)
        }, p(i, [n]) {
            e = i, a && a.p && (!o || 16 & n) && fr(a, r, e, e[4], o ? $r(r, e[4], n, null) : yr(e[4]), null), (!o || 1 & n) && Nr(t, "class", e[0])
        }, i(e) {
            o || (Ea(a, e), o = !0)
        }, o(e) {
            Aa(a, e), o = !1
        }, d(e) {
            e && Lr(t), a && a.d(e), i = !1, ar(n)
        }
    }
}

function Mf(e, t, o) {
    let {$$slots: i = {}, $$scope: n} = t;
    const r = sa();
    let {class: a = null} = t;
    const s = ca("measurable");
    let l = !1;
    return na((() => o(1, l = !0))), e.$$set = e => {
        "class" in e && o(0, a = e.class), "$$scope" in e && o(4, n = e.$$scope)
    }, [a, l, s, ({detail: e}) => r("measure", e), n, i]
}

class Pf extends Ga {
    constructor(e) {
        super(), Ua(this, e, Mf, Tf, lr, {class: 0})
    }
}

const Rf = e => ({}), If = e => ({}), Ef = e => ({}), Af = e => ({}), Lf = e => ({}), Ff = e => ({});

function zf(e) {
    let t, o;
    const i = e[4].header, n = mr(i, e, e[3], Ff);
    return {
        c() {
            t = Fr("div"), n && n.c(), Nr(t, "class", "PinturaUtilHeader")
        }, m(e, i) {
            Ar(e, t, i), n && n.m(t, null), o = !0
        }, p(e, t) {
            n && n.p && (!o || 8 & t) && fr(n, i, e, e[3], o ? $r(i, e[3], t, Lf) : yr(e[3]), Ff)
        }, i(e) {
            o || (Ea(n, e), o = !0)
        }, o(e) {
            Aa(n, e), o = !1
        }, d(e) {
            e && Lr(t), n && n.d(e)
        }
    }
}

function Df(e) {
    let t, o;
    const i = e[4].footer, n = mr(i, e, e[3], If);
    return {
        c() {
            t = Fr("div"), n && n.c(), Nr(t, "class", "PinturaUtilFooter")
        }, m(e, i) {
            Ar(e, t, i), n && n.m(t, null), o = !0
        }, p(e, t) {
            n && n.p && (!o || 8 & t) && fr(n, i, e, e[3], o ? $r(i, e[3], t, Rf) : yr(e[3]), If)
        }, i(e) {
            o || (Ea(n, e), o = !0)
        }, o(e) {
            Aa(n, e), o = !1
        }, d(e) {
            e && Lr(t), n && n.d(e)
        }
    }
}

function Bf(e) {
    let t, o, i, n, r, a, s = e[1] && zf(e);
    const l = e[4].main, c = mr(l, e, e[3], Af), d = c || function (e) {
        let t, o;
        return t = new Pf({props: {class: "PinturaStage"}}), t.$on("measure", e[5]), {
            c() {
                Na(t.$$.fragment)
            }, m(e, i) {
                Ha(t, e, i), o = !0
            }, p: tr, i(e) {
                o || (Ea(t.$$.fragment, e), o = !0)
            }, o(e) {
                Aa(t.$$.fragment, e), o = !1
            }, d(e) {
                ja(t, e)
            }
        }
    }(e);
    let u = e[2] && Df(e);
    return {
        c() {
            s && s.c(), t = Br(), o = Fr("div"), d && d.c(), i = Br(), u && u.c(), n = Br(), r = Or(), Nr(o, "class", "PinturaUtilMain")
        }, m(l, c) {
            s && s.m(l, c), Ar(l, t, c), Ar(l, o, c), d && d.m(o, null), e[6](o), Ar(l, i, c), u && u.m(l, c), Ar(l, n, c), Ar(l, r, c), a = !0
        }, p(e, [o]) {
            e[1] ? s ? (s.p(e, o), 2 & o && Ea(s, 1)) : (s = zf(e), s.c(), Ea(s, 1), s.m(t.parentNode, t)) : s && (Ra(), Aa(s, 1, 1, (() => {
                s = null
            })), Ia()), c && c.p && (!a || 8 & o) && fr(c, l, e, e[3], a ? $r(l, e[3], o, Ef) : yr(e[3]), Af), e[2] ? u ? (u.p(e, o), 4 & o && Ea(u, 1)) : (u = Df(e), u.c(), Ea(u, 1), u.m(n.parentNode, n)) : u && (Ra(), Aa(u, 1, 1, (() => {
                u = null
            })), Ia())
        }, i(e) {
            a || (Ea(s), Ea(d, e), Ea(u), Ea(false), a = !0)
        }, o(e) {
            Aa(s), Aa(d, e), Aa(u), Aa(false), a = !1
        }, d(a) {
            s && s.d(a), a && Lr(t), a && Lr(o), d && d.d(a), e[6](null), a && Lr(i), u && u.d(a), a && Lr(n), a && Lr(r)
        }
    }
}

function Of(e, t, o) {
    let {
        $$slots: i = {},
        $$scope: n
    } = t, {hasHeader: r = !!t.$$slots.header} = t, {hasFooter: a = !!t.$$slots.footer} = t, {root: s} = t;
    return e.$$set = e => {
        o(7, t = ir(ir({}, t), br(e))), "hasHeader" in e && o(1, r = e.hasHeader), "hasFooter" in e && o(2, a = e.hasFooter), "root" in e && o(0, s = e.root), "$$scope" in e && o(3, n = e.$$scope)
    }, t = br(t), [s, r, a, n, i, function (t) {
        da.call(this, e, t)
    }, function (e) {
        ha[e ? "unshift" : "push"]((() => {
            s = e, o(0, s)
        }))
    }]
}

class Wf extends Ga {
    constructor(e) {
        super(), Ua(this, e, Of, Bf, lr, {hasHeader: 1, hasFooter: 2, root: 0})
    }
}

function Vf(e) {
    let t;
    return {
        c() {
            t = Fr("div"), Nr(t, "class", "PinturaRangeInputMeter"), Zr(t, "transform", `translateX(${e[10].x - e[13].x}px) translateY(${e[10].y - e[13].y}px)`)
        }, m(o, i) {
            Ar(o, t, i), t.innerHTML = e[7]
        }, p(e, o) {
            128 & o[0] && (t.innerHTML = e[7]), 1024 & o[0] && Zr(t, "transform", `translateX(${e[10].x - e[13].x}px) translateY(${e[10].y - e[13].y}px)`)
        }, d(e) {
            e && Lr(t)
        }
    }
}

function _f(e) {
    let t, o, i, n, r, a, s, l, c, d, u, h = e[10] && Vf(e);
    return {
        c() {
            t = Fr("div"), o = Fr("span"), i = Br(), n = Fr("button"), r = Dr(e[1]), s = Br(), l = Fr("div"), h && h.c(), Nr(o, "class", "PinturaRangeInputValue"), Nr(n, "class", "PinturaRangeInputReset"), Nr(n, "type", "button"), n.disabled = a = e[0] === e[2], Nr(l, "class", "PinturaRangeInputInner"), Nr(l, "data-value-limited", e[5]), Zr(l, "--range-mask-from", e[9]), Zr(l, "--range-mask-to", e[8]), Nr(t, "class", "PinturaRangeInput"), Nr(t, "tabindex", "0")
        }, m(a, p) {
            Ar(a, t, p), Rr(t, o), o.innerHTML = e[3], Rr(t, i), Rr(t, n), Rr(n, r), Rr(t, s), Rr(t, l), h && h.m(l, null), d || (u = [Wr(n, "click", e[18]), Wr(l, "interactionstart", e[14]), Wr(l, "interactionupdate", e[16]), Wr(l, "interactionend", e[17]), Wr(l, "interactionrelease", e[15]), wr(c = Sp.call(null, l, {inertia: e[6]})), Wr(l, "measure", e[39]), wr(zc.call(null, l)), Wr(t, "wheel", e[20], {passive: !1}), Wr(t, "nudge", e[21]), wr(rh.call(null, t, {
                direction: "horizontal",
                preventDefault: !0
            }))], d = !0)
        }, p(e, t) {
            8 & t[0] && (o.innerHTML = e[3]), 2 & t[0] && Ur(r, e[1]), 5 & t[0] && a !== (a = e[0] === e[2]) && (n.disabled = a), e[10] ? h ? h.p(e, t) : (h = Vf(e), h.c(), h.m(l, null)) : h && (h.d(1), h = null), 32 & t[0] && Nr(l, "data-value-limited", e[5]), c && sr(c.update) && 64 & t[0] && c.update.call(null, {inertia: e[6]}), 512 & t[0] && Zr(l, "--range-mask-from", e[9]), 256 & t[0] && Zr(l, "--range-mask-to", e[8])
        }, i: tr, o: tr, d(e) {
            e && Lr(t), h && h.d(), d = !1, ar(u)
        }
    }
}

function Nf(e, t, o) {
    let n, r, a, s, l, c, d, u, h, p, m,
        g, {labelReset: $ = "Reset"} = t, {direction: f = "x"} = t, {min: y = 0} = t, {max: b = 1} = t, {base: x = y} = t, {value: v = 0} = t, {valueLabel: w = 0} = t, {valueMin: S} = t, {valueMax: k} = t, {oninputstart: C = i} = t, {oninputmove: T = i} = t, {oninputend: M = i} = t, {elasticity: P = 0} = t, {nudgeMultiplier: R} = t, {step: I = 8} = t;
    const E = ca("isAnimated");
    pr(e, E, (e => o(6, p = e)));
    const A = ca("fixScrollDirection");
    pr(e, A, (e => o(45, m = e)));
    const L = (e, t, o) => Math.ceil((e - o) / t) * t + o;
    let F, z, D;
    const B = {x: 2, y: 0}, O = (e, t, o) => `M ${e - o} ${t} a ${o} ${o} 0 1 0 0 -1`;
    let W, V = void 0, _ = !1, N = {snap: !1, elastic: !1};
    const H = (e, t, o) => {
        const i = e[f] + t[f], n = gs(i, W[1][f], W[0][f]), r = P ? n + kp(i - n, P) : n, a = o.elastic ? r : n,
            s = he(0, 0);
        return s[f] = a, j.set(s, {hard: o.snap}), gs(G(s, f), y, b)
    }, j = bc();
    pr(e, j, (e => o(10, g = e)));
    const U = (e, t) => {
        const o = .5 * (F[t] - s[t]) - (ah(e, y, b) * s[t] - .5 * s[t]);
        return {x: "x" === t ? o : 0, y: "y" === t ? o : 0}
    }, G = (e, t) => {
        const o = -(e[t] - .5 * F[t]) / s[t];
        return y + o * n
    }, Z = j.subscribe((e => {
        e && V && T(gs(G(e, f), y, b))
    })), X = e => {
        const t = [U(null != S ? S : y, f), U(null != k ? k : b, f)],
            o = {x: "x" === f ? g.x + e : 0, y: "y" === f ? g.y + e : 0}, i = gs(o[f], t[1][f], t[0][f]),
            n = {...g, [f]: i};
        vr(j, g = n, g);
        const r = gs(G(n, f), y, b);
        C(), T(r), M(r)
    };
    aa((() => {
        Z()
    }));
    return e.$$set = e => {
        "labelReset" in e && o(1, $ = e.labelReset), "direction" in e && o(22, f = e.direction), "min" in e && o(23, y = e.min), "max" in e && o(24, b = e.max), "base" in e && o(2, x = e.base), "value" in e && o(0, v = e.value), "valueLabel" in e && o(3, w = e.valueLabel), "valueMin" in e && o(25, S = e.valueMin), "valueMax" in e && o(26, k = e.valueMax), "oninputstart" in e && o(27, C = e.oninputstart), "oninputmove" in e && o(28, T = e.oninputmove), "oninputend" in e && o(29, M = e.oninputend), "elasticity" in e && o(30, P = e.elasticity), "nudgeMultiplier" in e && o(31, R = e.nudgeMultiplier), "step" in e && o(32, I = e.step)
    }, e.$$.update = () => {
        if (25165824 & e.$$.dirty[0] && o(34, n = b - y), 41943040 & e.$$.dirty[0] && o(36, r = null != S ? Math.max(S, y) : y), 83886080 & e.$$.dirty[0] && o(35, a = null != k ? Math.min(k, b) : b), 25165828 & e.$$.dirty[0] && o(38, l = ah(x, y, b)), 16 & e.$$.dirty[0] | 128 & e.$$.dirty[1] && F) {
            const e = .5 * F.y;
            let t, i = 40 * l, n = "", r = F.y, a = "";
            for (let o = 0; o <= 40; o++) {
                const r = B.x + 10 * o, s = e;
                n += O(r, s, o % 5 == 0 ? 2 : .75) + " ", t = r + B.x, o === i && (a = `<path d="M${r} ${s - 4} l2 3 l-2 -1 l-2 1 z"/>`)
            }
            o(7, z = `<svg width="${t}" height="${r}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${t} ${r}" aria-hidden="true" focusable="false">\n        ${a}\n        <rect rx="4" ry="4" y="${e - 4}"" height="8"/>\n        <path fill-rule="evenodd" d="${n.trim()}"/></svg>`), o(33, D = {
                x: t - 2 * B.x,
                y: r
            })
        }
        16 & e.$$.dirty[0] | 4 & e.$$.dirty[1] && (s = F && D), 25165824 & e.$$.dirty[0] | 48 & e.$$.dirty[1] && o(5, c = r !== y || a !== b), 32 & e.$$.dirty[0] | 48 & e.$$.dirty[1] && o(37, d = c ? function (e, t) {
            const o = 1 / 40, i = ah(e, y, b), n = ah(t, y, b);
            return [100 * le(L(i, o, 0) - .0125) + "%", 100 * le(L(n, o, 0) - .0125) + "%"]
        }(r, a) : void 0), 64 & e.$$.dirty[1] && o(9, u = d ? d[0] : ""), 64 & e.$$.dirty[1] && o(8, h = d ? d[1] : ""), 4194385 & e.$$.dirty[0] | 8 & e.$$.dirty[1] && n && F && F.x && F.y && j.set(U(v, f), {hard: !1 === p})
    }, [v, $, x, w, F, c, p, z, h, u, g, E, A, B, () => {
        _ = !1, V = hr(j), W = [U(null != S ? S : y, f), U(null != k ? k : b, f)], C()
    }, () => {
        _ = !0
    }, ({detail: e}) => {
        N.snap = !_, N.elastic = !_, H(V, e.translation, N)
    }, ({detail: e}) => {
        N.snap = !1, N.elastic = !1;
        const t = H(V, e.translation, N);
        if (V = void 0, W = void 0, Math.abs(t - x) < .01) return M(x);
        M(t)
    }, () => {
        o(0, v = gs(x, r, a)), C(), M(v)
    }, j, e => {
        e.preventDefault(), e.stopPropagation();
        const t = Pp(e, {fixScrollDirection: m}) * I;
        X(t)
    }, ({detail: e}) => {
        X(e[f] * Math.abs(R || 8))
    }, f, y, b, S, k, C, T, M, P, R, I, D, n, a, r, d, l, e => o(4, F = (e => he(e.width, e.height))(e.detail))]
}

class Hf extends Ga {
    constructor(e) {
        super(), Ua(this, e, Nf, _f, lr, {
            labelReset: 1,
            direction: 22,
            min: 23,
            max: 24,
            base: 2,
            value: 0,
            valueLabel: 3,
            valueMin: 25,
            valueMax: 26,
            oninputstart: 27,
            oninputmove: 28,
            oninputend: 29,
            elasticity: 30,
            nudgeMultiplier: 31,
            step: 32
        }, null, [-1, -1])
    }
}

var jf = {
    [Q]: e => ({x: e.x, y: e.y}),
    [ne]: e => ({x: e.x + e.width, y: e.y}),
    [ee]: e => ({x: e.x + e.width, y: e.y}),
    [re]: e => ({x: e.x + e.width, y: e.y + e.height}),
    [te]: e => ({x: e.x, y: e.y + e.height}),
    [ae]: e => ({x: e.x, y: e.y + e.height}),
    [oe]: e => ({x: e.x, y: e.y}),
    [ie]: e => ({x: e.x, y: e.y})
};
const Uf = {t: "top", r: "right", b: "bottom", l: "left"},
    Gf = {t: "vertical", b: "vertical", r: "horizontal", l: "horizontal"};

function Zf(e, t, o) {
    const i = e.slice();
    return i[15] = t[o].key, i[16] = t[o].translate, i[17] = t[o].scale, i[18] = t[o].type, i[19] = t[o].opacity, i[20] = t[o].role, i[21] = t[o].tabindex, i[22] = t[o].label, i[23] = t[o].orientation, i[24] = t[o].valuemin, i[25] = t[o].valuemax, i[26] = t[o].valuenow, i
}

function Xf(e, t) {
    let o, i, n, r, a, s, l, c, d, u, h, p;
    return {
        key: e, first: null, c() {
            o = Fr("div"), Nr(o, "role", i = t[20]), Nr(o, "tabindex", n = t[21]), Nr(o, "aria-label", r = t[22]), Nr(o, "aria-orientation", a = t[23]), Nr(o, "aria-valuemin", s = t[24]), Nr(o, "aria-valuemax", l = t[25]), Nr(o, "aria-valuenow", c = t[26]), Nr(o, "class", "PinturaRectManipulator"), Nr(o, "data-direction", d = t[15]), Nr(o, "data-shape", u = "" + ("edge" === t[18] ? "edge" : "" + t[0])), Zr(o, "--tx", t[16].x), Zr(o, "--ty", t[16].y), Zr(o, "--sx", t[17].x), Zr(o, "--sy", t[17].y), Zr(o, "opacity", t[19]), this.first = o
        }, m(e, i) {
            Ar(e, o, i), h || (p = [Wr(o, "nudge", (function () {
                sr(t[6](t[15])) && t[6](t[15]).apply(this, arguments)
            })), wr(rh.call(null, o, {preventDefault: !0})), Wr(o, "interactionstart", (function () {
                sr(t[5]("resizestart", t[15])) && t[5]("resizestart", t[15]).apply(this, arguments)
            })), Wr(o, "interactionupdate", (function () {
                sr(t[5]("resizemove", t[15])) && t[5]("resizemove", t[15]).apply(this, arguments)
            })), Wr(o, "interactionend", (function () {
                sr(t[5]("resizeend", t[15])) && t[5]("resizeend", t[15]).apply(this, arguments)
            })), wr(Sp.call(null, o))], h = !0)
        }, p(e, h) {
            t = e, 2 & h && i !== (i = t[20]) && Nr(o, "role", i), 2 & h && n !== (n = t[21]) && Nr(o, "tabindex", n), 2 & h && r !== (r = t[22]) && Nr(o, "aria-label", r), 2 & h && a !== (a = t[23]) && Nr(o, "aria-orientation", a), 2 & h && s !== (s = t[24]) && Nr(o, "aria-valuemin", s), 2 & h && l !== (l = t[25]) && Nr(o, "aria-valuemax", l), 2 & h && c !== (c = t[26]) && Nr(o, "aria-valuenow", c), 2 & h && d !== (d = t[15]) && Nr(o, "data-direction", d), 3 & h && u !== (u = "" + ("edge" === t[18] ? "edge" : "" + t[0])) && Nr(o, "data-shape", u), 2 & h && Zr(o, "--tx", t[16].x), 2 & h && Zr(o, "--ty", t[16].y), 2 & h && Zr(o, "--sx", t[17].x), 2 & h && Zr(o, "--sy", t[17].y), 2 & h && Zr(o, "opacity", t[19])
        }, d(e) {
            e && Lr(o), h = !1, ar(p)
        }
    }
}

function Yf(e) {
    let t, o = [], i = new Map, n = e[1];
    const r = e => e[15];
    for (let t = 0; t < n.length; t += 1) {
        let a = Zf(e, n, t), s = r(a);
        i.set(s, o[t] = Xf(s, a))
    }
    return {
        c() {
            for (let e = 0; e < o.length; e += 1) o[e].c();
            t = Or()
        }, m(e, i) {
            for (let t = 0; t < o.length; t += 1) o[t].m(e, i);
            Ar(e, t, i)
        }, p(e, [a]) {
            99 & a && (n = e[1], o = Oa(o, a, r, 1, e, n, i, t.parentNode, Da, Xf, t, Zf))
        }, i: tr, o: tr, d(e) {
            for (let t = 0; t < o.length; t += 1) o[t].d(e);
            e && Lr(t)
        }
    }
}

function qf(e, t, o) {
    let i, n, r, a, {rect: s = null} = t, {bounds: l = null} = t, {visible: c = !1} = t, {cornerStyle: d} = t;
    const u = ca("isAnimated");
    pr(e, u, (e => o(12, a = e)));
    const h = bc(void 0, {precision: 1e-4, stiffness: .2, damping: .4});
    pr(e, h, (e => o(11, r = e)));
    const p = bc(0, {precision: .001});
    let m;
    pr(e, p, (e => o(10, n = e)));
    const g = sa();
    return e.$$set = e => {
        "rect" in e && o(7, s = e.rect), "bounds" in e && o(8, l = e.bounds), "visible" in e && o(9, c = e.visible), "cornerStyle" in e && o(0, d = e.cornerStyle)
    }, e.$$.update = () => {
        4608 & e.$$.dirty && h.set(c ? 1 : .5, {hard: !1 === a}), 4608 & e.$$.dirty && p.set(c ? 1 : 0, {hard: !1 === a}), 3456 & e.$$.dirty && o(1, i = Object.keys(J).map(((e, t) => {
            const o = J[e], i = jf[o](s), a = 1 === o.length ? "edge" : "corner", c = "corner" === a;
            let d;
            if ("edge" === a && l) {
                let e, t, i;
                "l" === o && (e = l.x, t = Math.min(l.width, s.x + s.width), i = s.x), "t" === o && (e = l.y, t = Math.min(l.height, s.y + s.height), i = s.y), "r" === o && (e = s.x, t = l.width, i = s.x + s.width), "b" === o && (e = s.y, t = l.height, i = s.y + s.height), d = {
                    role: "slider",
                    tabindex: 0,
                    label: "Drag " + Uf[o],
                    orientation: "" + Gf[o],
                    valuemin: Math.round(e),
                    valuemax: Math.round(t),
                    valuenow: Math.round(i)
                }
            }
            return {
                key: o,
                type: a,
                scale: {
                    x: /^(t|b)$/.test(o) ? s.width : c ? gs(r, .5, 1.25) : 1,
                    y: /^(r|l)$/.test(o) ? s.height : c ? gs(r, .5, 1.25) : 1
                },
                translate: {x: i.x, y: i.y},
                opacity: n, ...d
            }
        })))
    }, [d, i, u, h, p, (e, t) => ({detail: o}) => {
        m && t !== m || "resizestart" !== e && void 0 === m || ("resizestart" === e && (m = t), "resizeend" === e && (m = void 0), g(e, {
            direction: t,
            translation: o && o.translation
        }))
    }, e => ({detail: t}) => {
        g("resizestart", {direction: e, translation: {x: 0, y: 0}}), g("resizemove", {
            direction: e,
            translation: t
        }), g("resizeend", {direction: e, translation: {x: 0, y: 0}})
    }, s, l, c, n, r, a]
}

class Kf extends Ga {
    constructor(e) {
        super(), Ua(this, e, qf, Yf, lr, {rect: 7, bounds: 8, visible: 9, cornerStyle: 0})
    }
}

var Jf = e => {
    function t(t, o) {
        e.dispatchEvent(new CustomEvent(t, {detail: o}))
    }

    const o = o => {
        o.preventDefault(), e.addEventListener("gesturechange", i), e.addEventListener("gestureend", n), t("gesturedown")
    }, i = e => {
        e.preventDefault(), t("gestureupdate", e.scale)
    }, n = e => {
        t("gestureup", e.scale), e.preventDefault(), r()
    }, r = () => {
        e.removeEventListener("gesturechange", i), e.removeEventListener("gestureend", n)
    };
    return e.addEventListener("gesturestart", o), {
        destroy: () => {
            r(), e.removeEventListener("gesturestart", o)
        }
    }
}, Qf = {[Q]: te, [ee]: oe, [te]: Q, [oe]: ee, [ie]: re, [ne]: ae, [re]: ie, [ae]: ne}, ey = e => {
    const t = e === oe || e === ee, o = e === Q || e === te;
    return [e === ee || e === ne || e === re, e === oe || e === ae || e === ie, e === Q || e === ne || e === ie, e === te || e === re || e === ae, t, o, t || o]
}, ty = (e, t, o, i = {}) => {
    const {target: n, translate: r} = t, {aspectRatio: a, minSize: s, maxSize: l} = i, c = se[Qf[n]],
        d = we(he(e.x, e.y), he(c[0] * e.width, c[1] * e.height)), u = se[n],
        h = we(Je(e), he(u[0] * e.width, u[1] * e.height)), [p, m, g, $, f, y, b] = ey(n);
    let x = r.x, v = r.y;
    f ? v = 0 : y && (x = 0);
    const {inner: w, outer: S} = oy(d, n, o, {aspectRatio: a, minSize: s, maxSize: l});
    let [k, C, T, M] = wt(e);
    if (p ? M = d.x : m && (C = d.x), $ ? k = d.y : g && (T = d.y), p) {
        const e = w.x + w.width, t = S.x + S.width;
        C = gs(h.x + x, e, t)
    } else if (m) {
        const e = S.x, t = w.x;
        M = gs(h.x + x, e, t)
    }
    if ($) {
        const e = w.y + w.height, t = S.y + S.height;
        T = gs(h.y + v, e, t)
    } else if (g) {
        const e = S.y, t = w.y;
        k = gs(h.y + v, e, t)
    }
    if (M > w.x && (M = w.x), C < w.x + w.width && (C = w.x + w.width), k > w.y && (k = w.y), T < w.y + w.height && (T = w.y + w.height), M < S.x) {
        const e = S.x - M;
        M = S.x, C += e
    }
    if (C > S.x + S.width) {
        const e = C - (S.x + S.width);
        C = S.x + S.width, M -= e
    }
    if (k < S.y) {
        const e = S.y - k;
        k = S.y, T += e
    }
    if (T > S.y + S.height) {
        const e = T - (S.y + S.height);
        T = S.y + S.height, k -= e
    }
    if (a) if (b) {
        let e = C - M, t = T - k;
        f ? (t = e / a, k = d.y - .5 * t, T = d.y + .5 * t) : y && (e = t * a, M = d.x - .5 * e, C = d.x + .5 * e)
    } else {
        const e = he(h.x + x - d.x, h.y + v - d.y);
        n === ne ? (e.x = Math.max(0, e.x), e.y = Math.min(0, e.y)) : n === re ? (e.x = Math.max(0, e.x), e.y = Math.max(0, e.y)) : n === ae ? (e.x = Math.min(0, e.x), e.y = Math.max(0, e.y)) : n === ie && (e.x = Math.min(0, e.x), e.y = Math.min(0, e.y));
        const t = fe(e), o = fe(he(w.width, w.height)), i = fe(he(S.width, S.height)), r = gs(t, o, i), s = he(a, 1),
            l = Ce(ye(s), r);
        n === ne ? (C = d.x + l.x, k = d.y - l.y) : n === re ? (C = d.x + l.x, T = d.y + l.y) : n === ae ? (M = d.x - l.x, T = d.y + l.y) : n === ie && (M = d.x - l.x, k = d.y - l.y)
    }
    return at(M, k, C - M, T - k)
};
const oy = (e, t, o, i) => {
    const {aspectRatio: n, minSize: r, maxSize: a} = i, s = t === ee || t === ne || t === re,
        l = t === oe || t === ae || t === ie, c = t === Q || t === ne || t === ie, d = t === te || t === re || t === ae,
        u = t === oe || t === ee, h = t === Q || t === te, p = Je(o);
    s ? (p.x = e.x, p.width -= e.x) : l && (p.width = e.x), d ? (p.y = e.y, p.height -= e.y) : c && (p.height = e.y);
    const m = ((e, t) => Ke(0, 0, e, t))(Math.min(p.width, a.width), Math.min(p.height, a.height));
    if (n) if (u) {
        const t = Math.min(e.y, o.height - e.y);
        m.height = Math.min(2 * t, m.height)
    } else if (h) {
        const t = Math.min(e.x, o.width - e.x);
        m.width = Math.min(2 * t, m.width)
    }
    const g = n ? Be(xt(et(r), n)) : r, $ = n ? Be(vt(m, n)) : m;
    let f, y, b, x;
    s ? f = e.x : l && (y = e.x), d ? b = e.y : c && (x = e.y), s ? y = f + g.width : l && (f = y - g.width), d ? x = b + g.height : c && (b = x - g.height), u ? (b = e.y - .5 * g.height, x = e.y + .5 * g.height) : h && (f = e.x - .5 * g.width, y = e.x + .5 * g.width);
    const v = it([he(f, b), he(y, x)]);
    s ? y = f + $.width : l && (f = y - $.width), d ? x = b + $.height : c && (b = x - $.height), u ? (b = e.y - .5 * $.height, x = e.y + .5 * $.height) : h && (f = e.x - .5 * $.width, y = e.x + .5 * $.width), f = Math.max(o.x, f), y = Math.min(o.x + o.width, y), b = Math.max(o.y, b), x = Math.min(o.y + o.height, x);
    return {inner: v, outer: it([he(f, b), he(y, x)])}
};
var iy = e => 180 * e / Math.PI;

function ny(e) {
    let t, o, i;
    return o = new Hf({
        props: {
            elasticity: e[5],
            min: e[9],
            max: e[10],
            value: e[11],
            valueMin: Math.max(e[9], e[0]),
            valueMax: Math.min(e[10], e[1]),
            labelReset: e[6],
            base: e[12],
            valueLabel: Math.round(iy(e[11])) + "&deg;",
            oninputstart: e[2],
            oninputmove: e[17],
            oninputend: e[18]
        }
    }), {
        c() {
            t = Fr("div"), Na(o.$$.fragment), Nr(t, "class", "PinturaImageRotator")
        }, m(e, n) {
            Ar(e, t, n), Ha(o, t, null), i = !0
        }, p(e, [t]) {
            const i = {};
            32 & t && (i.elasticity = e[5]), 512 & t && (i.min = e[9]), 1024 & t && (i.max = e[10]), 2048 & t && (i.value = e[11]), 513 & t && (i.valueMin = Math.max(e[9], e[0])), 1026 & t && (i.valueMax = Math.min(e[10], e[1])), 64 & t && (i.labelReset = e[6]), 4096 & t && (i.base = e[12]), 2048 & t && (i.valueLabel = Math.round(iy(e[11])) + "&deg;"), 4 & t && (i.oninputstart = e[2]), 392 & t && (i.oninputmove = e[17]), 400 & t && (i.oninputend = e[18]), o.$set(i)
        }, i(e) {
            i || (Ea(o.$$.fragment, e), i = !0)
        }, o(e) {
            Aa(o.$$.fragment, e), i = !1
        }, d(e) {
            e && Lr(t), ja(o)
        }
    }
}

function ry(e, t, o) {
    let n, r, a, s, l, c,
        d, {rotation: u} = t, {valueMin: h} = t, {valueMax: p} = t, {oninputstart: m = i} = t, {oninputmove: g = i} = t, {oninputend: $ = i} = t, {elasticity: f = 0} = t, {labelReset: y} = t, {rotationMin: b} = t, {rotationMax: x} = t;
    return e.$$set = e => {
        "rotation" in e && o(13, u = e.rotation), "valueMin" in e && o(0, h = e.valueMin), "valueMax" in e && o(1, p = e.valueMax), "oninputstart" in e && o(2, m = e.oninputstart), "oninputmove" in e && o(3, g = e.oninputmove), "oninputend" in e && o(4, $ = e.oninputend), "elasticity" in e && o(5, f = e.elasticity), "labelReset" in e && o(6, y = e.labelReset), "rotationMin" in e && o(14, b = e.rotationMin), "rotationMax" in e && o(15, x = e.rotationMax)
    }, e.$$.update = () => {
        16384 & e.$$.dirty && o(9, n = b + 1e-9), 32768 & e.$$.dirty && o(10, r = x - 1e-9), 1536 & e.$$.dirty && o(12, a = n + .5 * (r - n)), 32768 & e.$$.dirty && o(16, s = 2 * x), 8192 & e.$$.dirty && o(8, l = Math.sign(u)), 73728 & e.$$.dirty && o(7, c = Math.round(Math.abs(u) / s) * s), 8576 & e.$$.dirty && o(11, d = u - l * c)
    }, [h, p, m, g, $, f, y, c, l, n, r, d, a, u, b, x, s, e => g(l * c + e), e => $(l * c + e)]
}

class ay extends Ga {
    constructor(e) {
        super(), Ua(this, e, ry, ny, lr, {
            rotation: 13,
            valueMin: 0,
            valueMax: 1,
            oninputstart: 2,
            oninputmove: 3,
            oninputend: 4,
            elasticity: 5,
            labelReset: 6,
            rotationMin: 14,
            rotationMax: 15
        })
    }
}

function sy(e) {
    let t, o;
    return t = new Eu({
        props: {
            class: "PinturaPresetListFilter",
            layout: "row",
            options: e[8],
            selectedIndex: e[7],
            onchange: e[10]
        }
    }), {
        c() {
            Na(t.$$.fragment)
        }, m(e, i) {
            Ha(t, e, i), o = !0
        }, p(e, o) {
            const i = {};
            256 & o && (i.options = e[8]), 128 & o && (i.selectedIndex = e[7]), t.$set(i)
        }, i(e) {
            o || (Ea(t.$$.fragment, e), o = !0)
        }, o(e) {
            Aa(t.$$.fragment, e), o = !1
        }, d(e) {
            ja(t, e)
        }
    }
}

function ly(e) {
    let t, o;
    return t = new eh({
        props: {
            icon: e[0],
            label: e[1],
            labelClass: e[2],
            hideLabel: e[3],
            options: e[9],
            selectedIndex: e[4],
            onchange: e[5],
            optionMapper: e[6],
            $$slots: {controls: [sy]},
            $$scope: {ctx: e}
        }
    }), {
        c() {
            Na(t.$$.fragment)
        }, m(e, i) {
            Ha(t, e, i), o = !0
        }, p(e, [o]) {
            const i = {};
            1 & o && (i.icon = e[0]), 2 & o && (i.label = e[1]), 4 & o && (i.labelClass = e[2]), 8 & o && (i.hideLabel = e[3]), 512 & o && (i.options = e[9]), 16 & o && (i.selectedIndex = e[4]), 32 & o && (i.onchange = e[5]), 64 & o && (i.optionMapper = e[6]), 262528 & o && (i.$$scope = {
                dirty: o,
                ctx: e
            }), t.$set(i)
        }, i(e) {
            o || (Ea(t.$$.fragment, e), o = !0)
        }, o(e) {
            Aa(t.$$.fragment, e), o = !1
        }, d(e) {
            ja(t, e)
        }
    }
}

const cy = 'fill="none" stroke="currentColor"';

function dy(e, t, o) {
    let n, r,
        a, {icon: s} = t, {label: l} = t, {labelClass: c} = t, {hideLabel: d} = t, {options: u} = t, {selectedIndex: p} = t, {onchange: m} = t, {optionMapper: g} = t, {filter: $ = "landscape"} = t, {onfilterchange: f = i} = t;
    const y = (e, t, o, i, n) => `\n    <rect ${cy} x="${e}" y="${t}" width="${o}" height="${i}" rx="${n}"/>`,
        b = (e, t) => `<path ${cy} d="M${e} ${t} l2 2 l3 -4"/>`;
    return e.$$set = e => {
        "icon" in e && o(0, s = e.icon), "label" in e && o(1, l = e.label), "labelClass" in e && o(2, c = e.labelClass), "hideLabel" in e && o(3, d = e.hideLabel), "options" in e && o(12, u = e.options), "selectedIndex" in e && o(4, p = e.selectedIndex), "onchange" in e && o(5, m = e.onchange), "optionMapper" in e && o(6, g = e.optionMapper), "filter" in e && o(11, $ = e.filter), "onfilterchange" in e && o(13, f = e.onfilterchange)
    }, e.$$.update = () => {
        6144 & e.$$.dirty && o(9, n = ((e, t) => (e || []).map((e => h(e[0]) ? (e[1] = e[1].map(t), e) : t(e))))(u, (e => t => {
            const [o, i, n = {}] = t;
            return zo(o) && (n.hidden = "landscape" === e ? o < 1 : o > 1), [o, i, n]
        })($))), 2048 & e.$$.dirty && o(7, r = "landscape" === $ ? 0 : 1), 128 & e.$$.dirty && o(8, a = [["landscape", "Landscape", {
            hideLabel: !0,
            icon: y(2, 6, 19, 12, 2) + (0 === r ? b(9, 12) : "")
        }], ["portrait", "Portrait", {hideLabel: !0, icon: y(5, 3, 13, 18, 2) + (1 === r ? b(9, 12) : "")}]])
    }, [s, l, c, d, p, m, g, r, a, n, e => {
        o(11, $ = e.value), f(e.value)
    }, $, u, f]
}

class uy extends Ga {
    constructor(e) {
        super(), Ua(this, e, dy, ly, lr, {
            icon: 0,
            label: 1,
            labelClass: 2,
            hideLabel: 3,
            options: 12,
            selectedIndex: 4,
            onchange: 5,
            optionMapper: 6,
            filter: 11,
            onfilterchange: 13
        })
    }
}

const hy = e => ve(e, (e => le(e, 6))), py = e => kt(e, (e => le(e, 6))), my = (e, t, o = 1e-4) => Math.abs(e - t) < o;
var gy = (e, t, o, i, n = {}) => {
    const {aspectRatio: r} = n;
    e = py(e), i = i.map(hy);
    const a = ut(e, Qf[o.target]), s = ve(a, (e => le(e, 6))), l = r ? xt(n.minSize, r) : n.minSize,
        c = r ? vt(n.maxSize, r) : n.maxSize, d = ut(t, o.target);
    if (Re(d, a) < 1) {
        t = Je(e);
        const o = Math.min(l.width / e.width, l.height / e.height);
        ct(t, o, a)
    }
    t = dt(Je(t), l, c, a);
    let u = Je(t);
    t = py(t);
    const h = zt(i, 1), p = St(e), m = St(t), g = p.findIndex((e => xe(ve(e, (e => le(e, 6))), s))),
        $ = e => h.map((t => Pt(t, e))).filter(Boolean).pop();
    if (r) {
        const t = m.map(((e, t) => {
            if (t === g) return;
            const o = he(a.x - e.x, a.y - e.y);
            ye(o), Ce(o, .5);
            const i = he(a.x - o.x, a.y - o.y), n = Ze(i, hy(e)), r = $(n);
            if (!r) return;
            const s = p[t];
            return {intersection: r, cornerDist: Re(a, s), intersectionDist: Re(a, r)}
        })).filter(Boolean);
        if (t.length) {
            const o = t.reduce(((e, t) => {
                const o = t.intersectionDist / t.cornerDist;
                return o < e ? o : e
            }), Number.MAX_SAFE_INTEGER);
            u = Je(e), ct(u, o, a)
        }
    } else {
        const e = 1 === o.target.length, n = !(i[0].y === i[1].y || i[0].x === i[1].x), r = p.map(((t, o) => {
            if (o === g) return;
            const i = m[o], r = !my(i.x, s.x) && !my(i.y, s.y);
            if (!e && !n && r) return;
            if (e && (my(i.x, s.x) || my(i.y, s.y))) return;
            const l = me(e ? t : a), c = Se(me(l), i);
            ye(c), Ce(c, .5), e ? we(l, c) : Se(l, c);
            const d = Ze(l, i), u = $(d);
            return u || void 0
        })).filter(Boolean);
        if (r.length) {
            const [e, i, n, l] = ey(o.target);
            let [c, d, h, p] = wt(t);
            r.forEach((({x: t, y: o}) => {
                const r = le(t, 6), a = le(o, 6);
                n && !my(a, s.y) && (c = Math.max(c, o)), e && !my(r, s.x) && (d = Math.min(d, t)), l && !my(a, s.y) && (h = Math.min(h, o)), i && !my(r, s.x) && (p = Math.max(p, t))
            })), u = tt([c, d, h, p]), ct(u, .9999, a)
        }
    }
    return dt(u, l, c, a), u
};

function $y(e) {
    let t, o;
    return t = new pp({props: {items: e[12]}}), {
        c() {
            Na(t.$$.fragment)
        }, m(e, i) {
            Ha(t, e, i), o = !0
        }, p(e, o) {
            const i = {};
            4096 & o[0] && (i.items = e[12]), t.$set(i)
        }, i(e) {
            o || (Ea(t.$$.fragment, e), o = !0)
        }, o(e) {
            Aa(t.$$.fragment, e), o = !1
        }, d(e) {
            ja(t, e)
        }
    }
}

function fy(e) {
    let t, o, i;
    return o = new Cf({props: {$$slots: {default: [$y]}, $$scope: {ctx: e}}}), {
        c() {
            t = Fr("div"), Na(o.$$.fragment), Nr(t, "slot", "header")
        }, m(e, n) {
            Ar(e, t, n), Ha(o, t, null), i = !0
        }, p(e, t) {
            const i = {};
            4096 & t[0] | 1024 & t[7] && (i.$$scope = {dirty: t, ctx: e}), o.$set(i)
        }, i(e) {
            i || (Ea(o.$$.fragment, e), i = !0)
        }, o(e) {
            Aa(o.$$.fragment, e), i = !1
        }, d(e) {
            e && Lr(t), ja(o)
        }
    }
}

function yy(e) {
    let t, o;
    return t = new xp({
        props: {
            onclick: e[90],
            label: e[4].cropLabelButtonRecenter,
            icon: e[4].cropIconButtonRecenter,
            disabled: !e[9],
            hideLabel: !0,
            class: "PinturaButtonCenter",
            style: `opacity:${e[31]};transform:translate3d(${e[32].x}px, ${e[32].y}px,0)`
        }
    }), {
        c() {
            Na(t.$$.fragment)
        }, m(e, i) {
            Ha(t, e, i), o = !0
        }, p(e, o) {
            const i = {};
            16 & o[0] && (i.label = e[4].cropLabelButtonRecenter), 16 & o[0] && (i.icon = e[4].cropIconButtonRecenter), 512 & o[0] && (i.disabled = !e[9]), 3 & o[1] && (i.style = `opacity:${e[31]};transform:translate3d(${e[32].x}px, ${e[32].y}px,0)`), t.$set(i)
        }, i(e) {
            o || (Ea(t.$$.fragment, e), o = !0)
        }, o(e) {
            Aa(t.$$.fragment, e), o = !1
        }, d(e) {
            ja(t, e)
        }
    }
}

function by(e) {
    let t, o;
    return t = new Kf({
        props: {
            rect: e[8],
            bounds: e[14],
            visible: e[13],
            cornerStyle: e[1]
        }
    }), t.$on("resizestart", e[70]), t.$on("resizemove", e[71]), t.$on("resizeend", e[72]), {
        c() {
            Na(t.$$.fragment)
        }, m(e, i) {
            Ha(t, e, i), o = !0
        }, p(e, o) {
            const i = {};
            256 & o[0] && (i.rect = e[8]), 16384 & o[0] && (i.bounds = e[14]), 8192 & o[0] && (i.visible = e[13]), 2 & o[0] && (i.cornerStyle = e[1]), t.$set(i)
        }, i(e) {
            o || (Ea(t.$$.fragment, e), o = !0)
        }, o(e) {
            Aa(t.$$.fragment, e), o = !1
        }, d(e) {
            ja(t, e)
        }
    }
}

function xy(e) {
    let t, o;
    return {
        c() {
            t = Fr("div"), o = Fr("p"), Nr(t, "class", "PinturaImageInfo"), Nr(t, "data-custom", e[24])
        }, m(i, n) {
            Ar(i, t, n), Rr(t, o), o.innerHTML = e[23]
        }, p(e, i) {
            8388608 & i[0] && (o.innerHTML = e[23]), 16777216 & i[0] && Nr(t, "data-custom", e[24])
        }, d(e) {
            e && Lr(t)
        }
    }
}

function vy(e) {
    let t, o, i, n, r, a, s, l, c = e[22] && e[10] && yy(e), d = e[22] && by(e), u = e[11] && xy(e);
    return {
        c() {
            t = Fr("div"), o = Fr("div"), c && c.c(), i = Br(), d && d.c(), r = Br(), u && u.c(), Nr(o, "class", "PinturaStage"), Nr(t, "slot", "main")
        }, m(h, p) {
            Ar(h, t, p), Rr(t, o), c && c.m(o, null), Rr(o, i), d && d.m(o, null), e[168](o), Rr(t, r), u && u.m(t, null), a = !0, s || (l = [wr(zc.call(null, o)), Wr(o, "measure", e[166]), Wr(o, "wheel", (function () {
                sr(e[2] && e[89]) && (e[2] && e[89]).apply(this, arguments)
            }), {passive: !1}), Wr(o, "interactionstart", e[76]), Wr(o, "interactionupdate", e[77]), Wr(o, "interactionrelease", e[79]), Wr(o, "interactionend", e[78]), wr(n = Sp.call(null, o, {
                drag: !0,
                inertia: !0,
                pinch: e[2],
                shouldStartInteraction: Ey,
                getEventPosition: e[169]
            })), Wr(o, "gesturedown", e[86]), Wr(o, "gestureupdate", e[87]), Wr(o, "gestureup", e[88]), wr(Jf.call(null, o))], s = !0)
        }, p(r, a) {
            (e = r)[22] && e[10] ? c ? (c.p(e, a), 4195328 & a[0] && Ea(c, 1)) : (c = yy(e), c.c(), Ea(c, 1), c.m(o, i)) : c && (Ra(), Aa(c, 1, 1, (() => {
                c = null
            })), Ia()), e[22] ? d ? (d.p(e, a), 4194304 & a[0] && Ea(d, 1)) : (d = by(e), d.c(), Ea(d, 1), d.m(o, null)) : d && (Ra(), Aa(d, 1, 1, (() => {
                d = null
            })), Ia()), n && sr(n.update) && 67108868 & a[0] && n.update.call(null, {
                drag: !0,
                inertia: !0,
                pinch: e[2],
                shouldStartInteraction: Ey,
                getEventPosition: e[169]
            }), e[11] ? u ? u.p(e, a) : (u = xy(e), u.c(), u.m(t, null)) : u && (u.d(1), u = null)
        }, i(e) {
            a || (Ea(c), Ea(d), a = !0)
        }, o(e) {
            Aa(c), Aa(d), a = !1
        }, d(o) {
            o && Lr(t), c && c.d(), d && d.d(), e[168](null), u && u.d(), s = !1, ar(l)
        }
    }
}

function wy(e) {
    let t, o, i, n;
    const r = [{class: "PinturaControlList"}, {tabs: e[7]}, e[19]];
    let a = {
        $$slots: {default: [Sy, ({tab: e}) => ({226: e}), ({tab: e}) => [0, 0, 0, 0, 0, 0, 0, e ? 512 : 0]]},
        $$scope: {ctx: e}
    };
    for (let e = 0; e < r.length; e += 1) a = ir(a, r[e]);
    t = new td({props: a}), t.$on("select", e[167]);
    const s = [{class: "PinturaControlPanels"}, {panelClass: "PinturaControlPanel"}, {panels: e[18]}, e[19]];
    let l = {
        $$slots: {default: [Ty, ({panel: e}) => ({225: e}), ({panel: e}) => [0, 0, 0, 0, 0, 0, 0, e ? 256 : 0]]},
        $$scope: {ctx: e}
    };
    for (let e = 0; e < s.length; e += 1) l = ir(l, s[e]);
    return i = new md({props: l}), {
        c() {
            Na(t.$$.fragment), o = Br(), Na(i.$$.fragment)
        }, m(e, r) {
            Ha(t, e, r), Ar(e, o, r), Ha(i, e, r), n = !0
        }, p(e, o) {
            const n = 524416 & o[0] ? Wa(r, [r[0], 128 & o[0] && {tabs: e[7]}, 524288 & o[0] && Va(e[19])]) : {};
            1536 & o[7] && (n.$$scope = {dirty: o, ctx: e}), t.$set(n);
            const a = 786432 & o[0] ? Wa(s, [s[0], s[1], 262144 & o[0] && {panels: e[18]}, 524288 & o[0] && Va(e[19])]) : {};
            2046853144 & o[0] | 1280 & o[7] && (a.$$scope = {dirty: o, ctx: e}), i.$set(a)
        }, i(e) {
            n || (Ea(t.$$.fragment, e), Ea(i.$$.fragment, e), n = !0)
        }, o(e) {
            Aa(t.$$.fragment, e), Aa(i.$$.fragment, e), n = !1
        }, d(e) {
            ja(t, e), e && Lr(o), ja(i, e)
        }
    }
}

function Sy(e) {
    let t, o, i = e[226].label + "";
    return {
        c() {
            t = Fr("span"), o = Dr(i)
        }, m(e, i) {
            Ar(e, t, i), Rr(t, o)
        }, p(e, t) {
            512 & t[7] && i !== (i = e[226].label + "") && Ur(o, i)
        }, d(e) {
            e && Lr(t)
        }
    }
}

function ky(e) {
    let t, o;
    return t = new Hf({
        props: {
            elasticity: e[27] * e[46],
            base: Iy,
            min: e[25],
            max: Ry,
            valueMin: e[29][0],
            valueMax: e[29][1],
            value: e[30],
            labelReset: e[4].labelReset,
            valueLabel: Math.round(100 * e[30]) + "%",
            oninputstart: e[83],
            oninputmove: e[84],
            oninputend: e[85]
        }
    }), {
        c() {
            Na(t.$$.fragment)
        }, m(e, i) {
            Ha(t, e, i), o = !0
        }, p(e, o) {
            const i = {};
            134217728 & o[0] && (i.elasticity = e[27] * e[46]), 33554432 & o[0] && (i.min = e[25]), 536870912 & o[0] && (i.valueMin = e[29][0]), 536870912 & o[0] && (i.valueMax = e[29][1]), 1073741824 & o[0] && (i.value = e[30]), 16 & o[0] && (i.labelReset = e[4].labelReset), 1073741824 & o[0] && (i.valueLabel = Math.round(100 * e[30]) + "%"), t.$set(i)
        }, i(e) {
            o || (Ea(t.$$.fragment, e), o = !0)
        }, o(e) {
            Aa(t.$$.fragment, e), o = !1
        }, d(e) {
            ja(t, e)
        }
    }
}

function Cy(e) {
    let t, o;
    return t = new ay({
        props: {
            elasticity: e[27] * e[46],
            rotation: e[15],
            labelReset: e[4].labelReset,
            valueMin: e[28][0],
            valueMax: e[28][1],
            rotationMin: -e[3],
            rotationMax: e[3],
            oninputstart: e[73],
            oninputmove: e[74],
            oninputend: e[75]
        }
    }), {
        c() {
            Na(t.$$.fragment)
        }, m(e, i) {
            Ha(t, e, i), o = !0
        }, p(e, o) {
            const i = {};
            134217728 & o[0] && (i.elasticity = e[27] * e[46]), 32768 & o[0] && (i.rotation = e[15]), 16 & o[0] && (i.labelReset = e[4].labelReset), 268435456 & o[0] && (i.valueMin = e[28][0]), 268435456 & o[0] && (i.valueMax = e[28][1]), 8 & o[0] && (i.rotationMin = -e[3]), 8 & o[0] && (i.rotationMax = e[3]), t.$set(i)
        }, i(e) {
            o || (Ea(t.$$.fragment, e), o = !0)
        }, o(e) {
            Aa(t.$$.fragment, e), o = !1
        }, d(e) {
            ja(t, e)
        }
    }
}

function Ty(e) {
    let t, o, i, n;
    const r = [Cy, ky], a = [];

    function s(e, t) {
        return e[225] === e[95] + "-rotation" ? 0 : e[225] === e[95] + "-zoom" ? 1 : -1
    }

    return ~(t = s(e)) && (o = a[t] = r[t](e)), {
        c() {
            o && o.c(), i = Or()
        }, m(e, o) {
            ~t && a[t].m(e, o), Ar(e, i, o), n = !0
        }, p(e, n) {
            let l = t;
            t = s(e), t === l ? ~t && a[t].p(e, n) : (o && (Ra(), Aa(a[l], 1, 1, (() => {
                a[l] = null
            })), Ia()), ~t ? (o = a[t], o ? o.p(e, n) : (o = a[t] = r[t](e), o.c()), Ea(o, 1), o.m(i.parentNode, i)) : o = null)
        }, i(e) {
            n || (Ea(o), n = !0)
        }, o(e) {
            Aa(o), n = !1
        }, d(e) {
            ~t && a[t].d(e), e && Lr(i)
        }
    }
}

function My(e) {
    let t, o, i = e[20] && wy(e);
    return {
        c() {
            t = Fr("div"), i && i.c(), Nr(t, "slot", "footer"), Zr(t, "transform", e[17])
        }, m(e, n) {
            Ar(e, t, n), i && i.m(t, null), o = !0
        }, p(e, o) {
            e[20] ? i ? (i.p(e, o), 1048576 & o[0] && Ea(i, 1)) : (i = wy(e), i.c(), Ea(i, 1), i.m(t, null)) : i && (Ra(), Aa(i, 1, 1, (() => {
                i = null
            })), Ia()), 131072 & o[0] && Zr(t, "transform", e[17])
        }, i(e) {
            o || (Ea(i), o = !0)
        }, o(e) {
            Aa(i), o = !1
        }, d(e) {
            e && Lr(t), i && i.d()
        }
    }
}

function Py(e) {
    let t, o, i;

    function n(t) {
        e[170](t)
    }

    let r = {hasHeader: e[21], $$slots: {footer: [My], main: [vy], header: [fy]}, $$scope: {ctx: e}};
    return void 0 !== e[16] && (r.root = e[16]), t = new Wf({props: r}), ha.push((() => _a(t, "root", n))), t.$on("measure", e[171]), {
        c() {
            Na(t.$$.fragment)
        }, m(e, o) {
            Ha(t, e, o), i = !0
        }, p(e, i) {
            const n = {};
            2097152 & i[0] && (n.hasHeader = e[21]), 2145320958 & i[0] | 3 & i[1] | 1024 & i[7] && (n.$$scope = {
                dirty: i,
                ctx: e
            }), !o && 65536 & i[0] && (o = !0, n.root = e[16], xa((() => o = !1))), t.$set(n)
        }, i(e) {
            i || (Ea(t.$$.fragment, e), i = !0)
        }, o(e) {
            Aa(t.$$.fragment, e), i = !1
        }, d(e) {
            ja(t, e)
        }
    }
}

const Ry = 1, Iy = 0, Ey = (e, t) => e.target === t;

function Ay(e, t, o) {
    let i, n, r, a, s, l, c, d, u, h, p, m, g, $, f, y, b, x, v, w, S, k, C, T, P, R, I, A, L, F, z, D, B, O, W, V, _,
        N, H, j, U, X, Y, J, Q, ee, te, oe, ce, de, ue, pe, $e, be, ve, ke, Te, Me, Pe, Re, Ie, Ee, Ae, Le, Fe, De, We,
        _e, Ze, Xe, Ye, qe, Ke, Qe, tt = tr, ot = () => (tt(), tt = ur(it, (e => o(13, z = e))), it);
    e.$$.on_destroy.push((() => tt()));
    let {isActive: it} = t;
    ot();
    let {stores: nt} = t, {cropImageSelectionCornerStyle: dt = "circle"} = t, {
        cropWillRenderImageSelectionGuides: ut = ((e, t) => {
            const o = "rotate" == e;
            return {rows: o ? 5 : 3, cols: o ? 5 : 3, opacity: .25 * t}
        })
    } = t, {cropAutoCenterImageSelectionTimeout: gt} = t, {cropEnableZoomMatchImageAspectRatio: $t = !0} = t, {cropEnableRotateMatchImageAspectRatio: ft = "never"} = t, {cropEnableRotationInput: St = !0} = t, {cropEnableZoom: Ct = !0} = t, {cropEnableZoomInput: Tt = !0} = t, {cropEnableZoomAutoHide: Mt = !0} = t, {cropEnableImageSelection: Pt = !0} = t, {cropEnableInfoIndicator: Rt = !1} = t, {cropEnableZoomTowardsWheelPosition: It = !0} = t, {cropEnableLimitWheelInputToCropSelection: Et = !0} = t, {cropEnableCenterImageSelection: At = !0} = t, {cropEnableButtonRotateLeft: Lt = !0} = t, {cropEnableButtonRotateRight: Ft = !1} = t, {cropEnableButtonFlipHorizontal: zt = !0} = t, {cropEnableButtonFlipVertical: Dt = !1} = t, {cropSelectPresetOptions: Bt} = t, {cropEnableSelectPreset: Ot = !0} = t, {cropEnableFilterMatchAspectRatio: Wt = !0} = t, {cropSelectPresetFilter: Vt = !1} = t, {cropEnableButtonToggleCropLimit: _t = !1} = t, {cropWillRenderTools: Nt = Z} = t, {cropWillRenderInfoIndicator: Ht} = t, {cropActiveTransformTool: jt = "rotation"} = t, {cropMinimizeToolbar: Ut = "auto"} = t, {cropInteractionFocus: Gt = "image"} = t, {cropRotationRange: Zt = q} = t, {cropMaskOpacity: Xt = .85} = t, {locale: Yt = {}} = t, {
        cropFormatIconSelectPreset: qt = function (e) {
            const {aspectRatio: t} = e, [o, i, n] = t ? [t < 1 ? 1 : .3, 1 === t ? .85 : .5, t > 1 ? 1 : .3] : [.2, .3, .4];
            return {a: o, b: i, c: n}
        }
    } = t, {
        cropFormatIconCropBoundary: Kt = function (e) {
            const {isBoundToImage: t} = e, [o, i, n, r] = t ? [.3, 1, 0, 0] : [0, 0, .3, 1];
            return {a: o, b: i, c: n, d: r}
        }
    } = t;
    const Jt = ca("isAnimated");
    pr(e, Jt, (e => o(144, D = e)));
    const Qt = ca("elasticityMultiplier");
    pr(e, Qt, (e => o(27, Ze = e)));
    const eo = ca("redrawTrigger");
    pr(e, eo, (e => o(165, _e = e)));
    const to = ca("imageIsStatic");
    pr(e, to, (e => o(150, H = e)));
    const oo = ca("imageStaticVisualCorners");
    pr(e, oo, (e => o(187, Ie = e)));
    const io = ca("fixScrollDirection");
    pr(e, io, (e => o(181, be = e)));
    let no = "idle";
    const ro = Ya();
    pr(e, ro, (e => o(162, Fe = e)));
    const ao = () => void 0 === Pe, so = e => 1 / e, lo = e => {
            Wt && Vt !== e && (o(97, Vt = e), Pe && 1 !== Pe && co() && vr(Xo, Pe = so(Pe), Pe))
        }, co = () => {
            if (1 === Pe || !i) return !1;
            const e = so(Pe);
            return !!tu(Fe).find((([t]) => t === e))
        },
        uo = (e, t, o) => K(o) ? t.width === Math.round(e.height) || t.height === Math.round(e.width) : t.width === Math.round(e.width) || t.height === Math.round(e.height),
        ho = () => (ao() || "always" === ft && co()) && ((e, t, o) => {
            const i = Ge(je(ze(t), o), (e => Math.abs(Math.round(e)))), n = He(i), r = st(e);
            return xe(n, r)
        })(U, de, ue) && uo(U, de, ue), po = e => {
            if ("never" !== ft && ho()) {
                vr(Fo, ue += e, ue);
                const t = K(ue), o = t ? de.height : de.width, i = t ? de.width : de.height;
                vr(jo, U = at(0, 0, o, i), U), ao() || vr(Xo, Pe = G(o, i), Pe)
            } else vr(Fo, ue += e, ue)
        }, {
            history: mo,
            env: go,
            isInteracting: $o,
            isInteractingFraction: fo,
            isTransformingImage: yo,
            rootRect: bo,
            stageRect: xo,
            utilRect: vo,
            utilRectPadded: wo,
            rootLineColor: So,
            allowPan: ko,
            allowZoom: Co,
            allowPlayPause: To,
            rangeInputElasticity: Mo,
            presentationScalar: Po,
            utilTools: Ro,
            imagePreviewModifiers: Io,
            imageOutlineOpacity: Eo,
            imageFlipX: Ao,
            imageFlipY: Lo,
            imageRotation: Fo,
            imageRotationRange: zo,
            imageOutputSize: Do,
            imageSelectionRect: Bo,
            imageSelectionRectSnapshot: Wo,
            imageSelectionRectIntent: Vo,
            imageSelectionRectPresentation: _o,
            imageCropRectIntent: No,
            imageCropRectOrigin: Ho,
            imageCropRect: jo,
            imageCropMinSize: Uo,
            imageCropMaxSize: Go,
            imageCropRange: Zo,
            imageCropAspectRatio: Xo,
            imageCropLimitToImage: Yo,
            imageSize: qo,
            imageScalar: Ko,
            imageOverlayMarkup: Jo,
            stagePadded: Qo,
            stageRecenter: ei
        } = nt;

    function ti(e, t) {
        return M(e.cropIconSelectPreset) ? iu(e.cropIconSelectPreset, e, t) : Pl(e.cropIconSelectPreset, qt({aspectRatio: t}), "{", "}")
    }

    function oi(e, t) {
        return M(e.cropIconCropBoundary) ? iu(e.cropIconCropBoundary, e, t) : Pl(e.cropIconCropBoundary, Kt({isBoundToImage: t}), "{", "}")
    }

    let ii;
    pr(e, go, (e => o(145, B = e))), pr(e, $o, (e => o(149, N = e))), pr(e, yo, (e => o(179, oe = e))), pr(e, bo, (e => o(26, ve = e))), pr(e, xo, (e => o(157, te = e))), pr(e, wo, (e => o(14, J = e))), pr(e, Po, (e => o(154, Y = e))), pr(e, Ro, (e => o(189, Ae = e))), pr(e, Io, (e => o(178, V = e))), pr(e, Ao, (e => o(164, We = e))), pr(e, Lo, (e => o(163, De = e))), pr(e, Fo, (e => o(15, ue = e))), pr(e, zo, (e => o(28, Xe = e))), pr(e, Do, (e => o(151, j = e))), pr(e, Bo, (e => o(156, ee = e))), pr(e, Wo, (e => o(155, Q = e))), pr(e, Vo, (e => o(188, Ee = e))), pr(e, _o, (e => o(148, _ = e))), pr(e, No, (e => o(182, ke = e))), pr(e, Ho, (e => o(184, Me = e))), pr(e, jo, (e => o(152, U = e))), pr(e, Uo, (e => o(160, $e = e))), pr(e, Go, (e => o(186, Re = e))), pr(e, Zo, (e => o(183, Te = e))), pr(e, Xo, (e => o(185, Pe = e))), pr(e, Yo, (e => o(159, pe = e))), pr(e, qo, (e => o(158, de = e))), pr(e, Ko, (e => o(153, X = e))), pr(e, Qo, (e => o(147, W = e)));
    const ni = (e, t) => {
        const o = {target: e, translate: t}, i = Ne(ze($e), Y), n = Ne(ze(Re), Y);
        let r = ty(Q, o, {...J, x: 0, y: 0}, {aspectRatio: Pe, minSize: i, maxSize: n});
        if (r = ((e, t, o) => {
            const [i, n, r, a] = wt(e), s = {...e};
            if (i < t.y && (e.height = e.height - (t.y - i), e.y = t.y), n > t.x + t.width && (e.width = t.x + t.width - e.x), r > t.y + t.height && (e.height = t.y + t.height - e.y), a < t.x && (e.width = e.width - (t.x - a), e.x = t.x), o) {
                const t = Math.min(1, s.width / e.width, s.height / e.height);
                return ht(s, t)
            }
            return e
        })(r, {...J, x: 0, y: 0}, Pe), !pe) return {boundsLimited: r, boundsIntent: r};
        let a = gy(Q, r, o, Ie, {aspectRatio: Pe, minSize: i, maxSize: n});
        return {boundsLimited: a, boundsIntent: a}
    }, ri = (e, t) => {
        const o = {target: e, translate: t}, i = Ne(ze($e), Y), n = Ne(ze(Re), Y), r = ((e, t, o = {}) => {
            const {target: i, translate: n} = t, {aspectRatio: r, minSize: a} = o, s = se[Qf[i]],
                l = we(Je(e), he(s[0] * e.width, s[1] * e.height)), c = se[i],
                d = we(Je(e), he(c[0] * e.width, c[1] * e.height)), [u, h, p, m, g, $, f] = ey(i);
            let y = n.x, b = n.y;
            g ? b = 0 : $ && (y = 0);
            let [x, v, w, S] = wt(e);
            if (u ? S = l.x : h && (v = l.x), m ? x = l.y : p && (w = l.y), u ? v = d.x + y : h && (S = d.x + y), m ? w = d.y + b : p && (x = d.y + b), a && g && w - x < a.height) {
                const e = a.height - (w - x);
                x -= .5 * e, w += .5 * e
            }
            if (a && $ && v - S < a.width) {
                const e = a.width - (v - S);
                S -= .5 * e, v += .5 * e
            }
            if (r) if (f) {
                let e = v - S, t = w - x;
                g ? (t = e / r, x = l.y - .5 * t, w = l.y + .5 * t) : $ && (e = t * r, S = l.x - .5 * e, v = l.x + .5 * e)
            } else {
                const e = he(d.x + y - l.x, d.y + b - l.y);
                i === ne ? (e.x = Math.max(0, e.x), e.y = Math.min(0, e.y)) : i === re ? (e.x = Math.max(0, e.x), e.y = Math.max(0, e.y)) : i === ae ? (e.x = Math.min(0, e.x), e.y = Math.max(0, e.y)) : i === ie && (e.x = Math.min(0, e.x), e.y = Math.min(0, e.y));
                const t = fe(e), o = he(r, 1), n = Ce(ye(o), t);
                i === ne ? (v = l.x + n.x, x = l.y - n.y) : i === re ? (v = l.x + n.x, w = l.y + n.y) : i === ae ? (S = l.x - n.x, w = l.y + n.y) : i === ie && (S = l.x - n.x, x = l.y - n.y)
            }
            return at(S, x, v - S, w - x)
        })(Q, o, {aspectRatio: Pe, minSize: i});
        return {boundsLimited: ty(Q, o, {...J, x: 0, y: 0}, {aspectRatio: Pe, minSize: i, maxSize: n}), boundsIntent: r}
    };
    let ai = void 0, si = void 0;
    const li = ({translation: e, scalar: t}) => {
        H && (t = 1, e = ge(me(e)));
        const o = Math.min(ee.width / U.width, ee.height / U.height), i = Ce(me(e), 1 / o);
        let n;
        if (si) {
            const t = Se(me(si), e);
            si = e, n = lt(Je(U), t)
        } else n = lt(Je(ai), ge(me(i))), void 0 !== t && ct(n, 1 / t);
        vr(No, ke = n, ke), vr(jo, U = n, U)
    }, ci = qa([Zo, jo], (([e, t], o) => {
        if (!t) return;
        const [i, n] = e, r = mt(t);
        o([Be(kt(xt(i, r), le)), Be(kt(vt(n, r), le))])
    }));
    pr(e, ci, (e => o(180, ce = e)));
    const di = qa([qo, Yo, Uo, Go, Zo, Fo], (([e, t, o, i, n, r], a) => {
        if (!e) return;
        const s = n[0], l = n[1];
        let c, d;
        t ? (c = ((e, t, o) => K(o) ? 1 - 1 / Math.min(e.height / t.width, e.width / t.height) : 1 - 1 / Math.min(e.width / t.width, e.height / t.height))(e, l, r), d = Math.min(s.width / o.width, s.height / o.height)) : (c = -1, d = 1);
        a([c, d].map((e => le(e))))
    }));
    pr(e, di, (e => o(29, Ye = e)));
    const ui = qa([qo, jo, Zo, Fo], (([e, t, o, i], n) => {
        if (!e || !t) return n(0);
        let r;
        const a = o[0], s = o[1], l = t.width, c = t.height, d = mt(t), u = K(i) ? Ve(e.height, e.width) : e,
            h = vt(u, d);
        if (l <= h.width || c <= h.height) {
            const e = h.width - a.width, t = h.height - a.height;
            r = 0 === e || 0 === t ? 1 : 1 - Math.min((l - a.width) / e, (c - a.height) / t)
        } else {
            const e = s.width - h.width, t = s.height - h.height, o = vt({width: e, height: t}, d);
            r = -Math.min((l - h.width) / o.width, (c - h.height) / o.height)
        }
        n(r)
    }));
    pr(e, ui, (e => o(30, qe = e)));
    const hi = e => {
        const t = mt(ai);
        let o, i, n;
        const r = K(ue) ? Ve(de.height, de.width) : de, a = vt(r, t);
        if (e >= 0) {
            const r = a.width - Te[0].width, s = a.height - Te[0].height;
            o = a.width - r * e, i = a.height - s * e, n = xt({width: o, height: i}, t)
        } else {
            const r = Te[1].width - a.width, s = Te[1].height - a.height;
            o = a.width + r * -e, i = a.height + s * -e, n = vt({width: o, height: i}, t)
        }
        o = n.width, i = n.height;
        const s = ai.x + .5 * ai.width - .5 * o, l = ai.y + .5 * ai.height - .5 * i;
        vr(jo, U = {x: s, y: l, width: o, height: i}, U)
    };
    let pi;
    const mi = e => {
        const t = ct(Je(pi), 1 / e);
        vr(No, ke = t, ke), vr(jo, U = t, U)
    };
    let gi;
    const $i = () => {
        ei.set({})
    };
    let fi;
    const yi = bc(0, {precision: 1e-4});
    pr(e, yi, (e => o(31, Ke = e)));
    const bi = bc();
    pr(e, bi, (e => o(32, Qe = e)));
    const xi = qa([Xo, Do, ro], (([e, t, o], n) => {
        if (!i) return;
        const r = tu(o), a = [...r].map((e => e[0])).sort(((e, t) => Oo(e[0]) && !Oo(t[0]) ? 1 : -1)).find((o => {
            if (Oo(o) && t) {
                const [i, n] = o, r = t.width === i && t.height === n, a = e === G(i, n);
                return r && a
            }
            return o === e
        }));
        if (!a) return n(void 0);
        n(r.map((e => e[0])).findIndex((e => Oo(e) ? xs(e, a) : e === a)))
    }));
    pr(e, xi, (e => o(161, Le = e)));
    const vi = (e, t) => {
        if (!i || -1 === e || void 0 === e) return;
        const o = tu(t)[e][0];
        return o ? Oo(o) ? G(o[0], o[1]) : o : void 0
    }, wi = qa([So, _o, fo], (([e, t, o], i) => {
        const {rows: n, cols: r, opacity: a} = ut(no, o);
        if (!t || a <= 0) return i([]);
        const {x: s, y: l, width: c, height: d} = t, u = c / r, h = d / n, p = [];
        for (let t = 1; t <= n - 1; t++) {
            const o = l + h * t;
            p.push({
                id: "image-selection-guide-row-" + t,
                points: [he(s, o), he(s + c, o)],
                opacity: a,
                strokeWidth: 1,
                strokeColor: e
            })
        }
        for (let t = 1; t <= r - 1; t++) {
            const o = s + u * t;
            p.push({
                id: "image-selection-guide-col-" + t,
                points: [he(o, l), he(o, l + d)],
                opacity: a,
                strokeWidth: 1,
                strokeColor: e
            })
        }
        i(p)
    }));
    pr(e, wi, (e => o(146, O = e)));
    const Si = "crop-" + E();
    let ki, Ci = Si + "-" + (St ? jt : "zoom"), Ti = Ci, Mi = void 0;
    const Pi = bc(D ? 20 : 0);
    pr(e, Pi, (e => o(143, F = e)));
    return e.$$set = e => {
        "isActive" in e && ot(o(0, it = e.isActive)), "stores" in e && o(99, nt = e.stores), "cropImageSelectionCornerStyle" in e && o(1, dt = e.cropImageSelectionCornerStyle), "cropWillRenderImageSelectionGuides" in e && o(100, ut = e.cropWillRenderImageSelectionGuides), "cropAutoCenterImageSelectionTimeout" in e && o(101, gt = e.cropAutoCenterImageSelectionTimeout), "cropEnableZoomMatchImageAspectRatio" in e && o(102, $t = e.cropEnableZoomMatchImageAspectRatio), "cropEnableRotateMatchImageAspectRatio" in e && o(103, ft = e.cropEnableRotateMatchImageAspectRatio), "cropEnableRotationInput" in e && o(104, St = e.cropEnableRotationInput), "cropEnableZoom" in e && o(2, Ct = e.cropEnableZoom), "cropEnableZoomInput" in e && o(105, Tt = e.cropEnableZoomInput), "cropEnableZoomAutoHide" in e && o(106, Mt = e.cropEnableZoomAutoHide), "cropEnableImageSelection" in e && o(107, Pt = e.cropEnableImageSelection), "cropEnableInfoIndicator" in e && o(108, Rt = e.cropEnableInfoIndicator), "cropEnableZoomTowardsWheelPosition" in e && o(109, It = e.cropEnableZoomTowardsWheelPosition), "cropEnableLimitWheelInputToCropSelection" in e && o(110, Et = e.cropEnableLimitWheelInputToCropSelection), "cropEnableCenterImageSelection" in e && o(111, At = e.cropEnableCenterImageSelection), "cropEnableButtonRotateLeft" in e && o(112, Lt = e.cropEnableButtonRotateLeft), "cropEnableButtonRotateRight" in e && o(113, Ft = e.cropEnableButtonRotateRight), "cropEnableButtonFlipHorizontal" in e && o(114, zt = e.cropEnableButtonFlipHorizontal), "cropEnableButtonFlipVertical" in e && o(115, Dt = e.cropEnableButtonFlipVertical), "cropSelectPresetOptions" in e && o(116, Bt = e.cropSelectPresetOptions), "cropEnableSelectPreset" in e && o(117, Ot = e.cropEnableSelectPreset), "cropEnableFilterMatchAspectRatio" in e && o(118, Wt = e.cropEnableFilterMatchAspectRatio), "cropSelectPresetFilter" in e && o(97, Vt = e.cropSelectPresetFilter), "cropEnableButtonToggleCropLimit" in e && o(119, _t = e.cropEnableButtonToggleCropLimit), "cropWillRenderTools" in e && o(120, Nt = e.cropWillRenderTools), "cropWillRenderInfoIndicator" in e && o(121, Ht = e.cropWillRenderInfoIndicator), "cropActiveTransformTool" in e && o(122, jt = e.cropActiveTransformTool), "cropMinimizeToolbar" in e && o(123, Ut = e.cropMinimizeToolbar), "cropInteractionFocus" in e && o(124, Gt = e.cropInteractionFocus), "cropRotationRange" in e && o(3, Zt = e.cropRotationRange), "cropMaskOpacity" in e && o(125, Xt = e.cropMaskOpacity), "locale" in e && o(4, Yt = e.locale), "cropFormatIconSelectPreset" in e && o(126, qt = e.cropFormatIconSelectPreset), "cropFormatIconCropBoundary" in e && o(127, Kt = e.cropFormatIconCropBoundary)
    }, e.$$.update = () => {
        8192 & e.$$.dirty[0] | 1 & e.$$.dirty[4] && to.set("selection" === Gt && z), 8388608 & e.$$.dirty[3] && o(134, i = Bt && Array.isArray(Bt) && Bt.length), 8388608 & e.$$.dirty[3] | 1024 & e.$$.dirty[4] && ro.set(i ? Bt : []), 8192 & e.$$.dirty[0] | 1048576 & e.$$.dirty[4] && z && Eo.set(1, {hard: !D}), 8192 & e.$$.dirty[0] && ko.set(!z), 8192 & e.$$.dirty[0] && Co.set(!z), 8192 & e.$$.dirty[0] && z && To.set(!0), 2097152 & e.$$.dirty[4] && o(129, p = "overlay" === B.layoutMode), 16777216 & e.$$.dirty[3] | 32 & e.$$.dirty[4] && o(133, S = Ot && !p), 16384 & e.$$.dirty[0] | 2 & e.$$.dirty[5] && o(142, l = J && ee && yt(J, ee)), 262144 & e.$$.dirty[4] | 2 & e.$$.dirty[5] && o(140, c = !(!ee || !l)), 327680 & e.$$.dirty[4] | 2 & e.$$.dirty[5] && o(138, d = c && pt(ee, l, (e => le(e, 5)))), 32784 & e.$$.dirty[0] | 209190928 & e.$$.dirty[3] | 2115072 & e.$$.dirty[4] | 2040 & e.$$.dirty[5] && o(12, n = _e && Nt([Lt && ["Button", "rotate-left", {
            label: Yt.cropLabelButtonRotateLeft,
            labelClass: "PinturaToolbarContentWide",
            icon: Yt.cropIconButtonRotateLeft,
            onclick: () => {
                po(-Math.PI / 2), mo.write()
            }
        }], Ft && ["Button", "rotate-right", {
            label: Yt.cropLabelButtonRotateRight,
            labelClass: "PinturaToolbarContentWide",
            icon: Yt.cropIconButtonRotateRight,
            onclick: () => {
                po(Math.PI / 2), mo.write()
            }
        }], zt && ["Button", "flip-horizontal", {
            label: Yt.cropLabelButtonFlipHorizontal,
            labelClass: "PinturaToolbarContentWide",
            icon: Yt.cropIconButtonFlipHorizontal,
            onclick: () => {
                K(ue) ? vr(Lo, De = !De, De) : vr(Ao, We = !We, We), mo.write()
            }
        }], Dt && ["Button", "flip-vertical", {
            label: Yt.cropLabelButtonFlipVertical,
            labelClass: "PinturaToolbarContentWide",
            icon: Yt.cropIconButtonFlipVertical,
            onclick: () => {
                K(ue) ? vr(Ao, We = !We, We) : vr(Lo, De = !De, De), mo.write()
            }
        }], S && i && [!1 === Vt ? "Dropdown" : uy, "select-preset", {
            icon: ti(Yt, vi(Le, Fe)),
            label: iu(Yt.cropLabelSelectPreset, Yt, vi(Le, Fe)),
            labelClass: "PinturaToolbarContentWide",
            options: Fe,
            filter: Vt,
            onfilterchange: lo,
            selectedIndex: Le,
            onchange: ({value: e}) => {
                Oo(e) ? (vr(Xo, Pe = G(e[0], e[1]), Pe), vr(Do, j = Oe(e), j)) : vr(Xo, Pe = e, Pe), d && $i(), mo.write()
            },
            optionMapper: e => {
                let t = !1;
                const o = Oo(e.value) ? e.value[0] / e.value[1] : e.value;
                if (o) {
                    const e = hs(de, ue, o);
                    t = e.width < $e.width || e.height < $e.height
                }
                return e.icon = ((e, t = {}) => {
                    const {width: o = 24, height: i = 24, bounds: n = 16, radius: r = 3} = t;
                    let a, s, l, c, d = Oo(e) ? G(e[0], e[1]) : e, u = !!d;
                    return d = u ? d : 1, l = d > 1 ? n : d * n, c = l / d, a = Math.round(.5 * (o - l)), s = Math.round(.5 * (i - c)), `<rect fill="${u ? "currentColor" : "none"}" stroke="${u ? "none" : "currentColor"}" stroke-width="${o / 16}" stroke-dasharray="${[o / 12, o / 6].join(" ")}" x="${a}" y="${s}" width="${l}" height="${c}" rx="${r}"/>`
                })(e.value, {bounds: 14}), {...e, disabled: t}
            }
        }], _t && ["Dropdown", "select-crop-limit", {
            icon: oi(Yt, pe),
            label: Yt.cropLabelCropBoundary,
            labelClass: "PinturaToolbarContentWide",
            onchange: ({value: e}) => {
                vr(Yo, pe = e, pe), mo.write()
            },
            options: [[!0, Yt.cropLabelCropBoundaryEdge, {icon: oi(Yt, !0)}], [!1, Yt.cropLabelCropBoundaryNone, {icon: oi(Yt, !1)}]]
        }]].filter(Boolean), B, (() => eo.set({}))).filter(Boolean)), 12288 & e.$$.dirty[0] | 1073741824 & e.$$.dirty[3] | 2097184 & e.$$.dirty[4] && vr(Ro, Ae = z && "never" !== Ut && ("always" === Ut || "short" === B.verticalSpace || p) ? n.map((([e, t, o]) => Array.isArray(o) ? [e, t, o] : [e, t, {
            ...o,
            hideLabel: !0
        }])) : [], Ae), 16 & e.$$.dirty[5] && o(25, r = pe ? 0 : -1), 16384 & e.$$.dirty[0] | 4 & e.$$.dirty[5] && o(135, a = J && he(-(te.x - J.x), -(te.y - J.y))), 16779264 & e.$$.dirty[4] && o(136, s = _ && a && he(Dd(_.x + .5 * _.width + a.x), Dd(_.y + .5 * _.height + a.y))), 1 & e.$$.dirty[5] && o(139, u = null != Q), 16384 & e.$$.dirty[0] | 262144 & e.$$.dirty[4] && o(141, h = J && l && (l.height === J.height || l.width === J.width)), 1610743808 & e.$$.dirty[4] && o(137, m = !h && Y < 1 && X < 1), 122880 & e.$$.dirty[4] && o(9, g = c && !u && (!d || m)), 32768 & e.$$.dirty[3] | 268435488 & e.$$.dirty[4] && o(11, $ = Rt && !!U && !p), 268435456 & e.$$.dirty[3] && o(24, f = !!Ht || void 0), 2048 & e.$$.dirty[0] | 268435456 & e.$$.dirty[3] | 402653184 & e.$$.dirty[4] && o(23, y = $ && Ht ? Ht(U, j) : $ && function (e, t) {
            let o = {};
            if (t) {
                const i = e.width / e.height;
                t.width && !t.height && (o = Ve(t.width, t.width / i)), t.height && !t.width && (o = Ve(t.height * i, t.height)), o = ze(t)
            } else o = Ve(e.width, e.height);
            return `${Math.round(o.width)} &times; ${Math.round(o.height)}`
        }(U, j)), 16779264 & e.$$.dirty[4] && o(8, v = _ && a && {
            x: _.x + a.x,
            y: _.y + a.y,
            width: _.width,
            height: _.height
        }), 256 & e.$$.dirty[0] | 16384 & e.$$.dirty[3] | 32 & e.$$.dirty[4] && o(22, b = Pt && !!v && !p), 262400 & e.$$.dirty[3] | 67112960 & e.$$.dirty[4] && o(10, x = At && !!s && !gt && !H), 512 & e.$$.dirty[0] | 256 & e.$$.dirty[3] | 33554448 & e.$$.dirty[4] && g && gt && !N && (clearTimeout(fi), o(128, fi = setTimeout($i, gt))), 33554448 & e.$$.dirty[4] && N && clearTimeout(fi), 1536 & e.$$.dirty[0] | 1048576 & e.$$.dirty[4] && yi.set(x && g ? 1 : 0, {hard: !1 === D}), 1052672 & e.$$.dirty[4] && bi.set(s, {hard: !1 === D}), 8192 & e.$$.dirty[0] | 8388608 & e.$$.dirty[4] && (z && !W ? (vr(Io, V.crop = {
            maskOpacity: Xt,
            maskMarkupOpacity: Xt
        }, V), Io.set(V)) : (delete V.crop, Io.set(V))), 4194304 & e.$$.dirty[4] && O && Jo.update((e => {
            const t = e.filter((e => !/^image\-selection\-guide/.test(e.id)));
            return z ? [...t, ...O] : t
        })), 2097152 & e.$$.dirty[4] && o(132, w = "short" !== B.verticalSpace), 1073741824 & e.$$.dirty[3] | 288 & e.$$.dirty[4] && o(21, k = "never" === Ut && !p || w && "always" !== Ut), 4 & e.$$.dirty[0] | 4096 & e.$$.dirty[3] && o(131, C = Ct && Tt), 8192 & e.$$.dirty[3] | 384 & e.$$.dirty[4] && o(130, T = Mt ? w && C : C), 2048 & e.$$.dirty[3] | 64 & e.$$.dirty[4] && o(20, P = St || T), 64 & e.$$.dirty[4] && (T || o(5, Ti = Ci)), 32 & e.$$.dirty[0] && o(19, R = {
            name: Si,
            selected: Ti
        }), 16 & e.$$.dirty[0] | 2048 & e.$$.dirty[3] | 64 & e.$$.dirty[4] && o(7, I = [St && {
            id: Si + "-rotation",
            label: Yt.cropLabelTabRotation
        }, T && {
            id: Si + "-zoom",
            label: Yt.cropLabelTabZoom
        }].filter(Boolean)), 128 & e.$$.dirty[0] && o(18, A = I.map((e => e.id))), 64 & e.$$.dirty[0] | 32 & e.$$.dirty[4] && ki && !ki.children.length && p && ki.dispatchEvent(new CustomEvent("measure", {detail: ki.rect})), 8192 & e.$$.dirty[0] | 1048576 & e.$$.dirty[4] && D && Pi.set(z ? 0 : 20), 524288 & e.$$.dirty[4] && o(17, L = F ? `translateY(${F}px)` : "none")
    }, [it, dt, Ct, Zt, Yt, Ti, ki, I, v, g, x, $, n, z, J, ue, Mi, L, A, R, P, k, b, y, f, r, ve, Ze, Xe, Ye, qe, Ke, Qe, Jt, Qt, eo, to, oo, io, ro, go, $o, yo, bo, xo, wo, Mo, Po, Ro, Io, Ao, Lo, Fo, zo, Do, Bo, Wo, Vo, _o, No, Ho, jo, Uo, Go, Zo, Xo, Yo, qo, Ko, Qo, () => {
        no = "select", vr($o, N = !0, N), vr(Wo, Q = Je(ee), Q), ii = H ? ni : ri
    }, ({detail: e}) => {
        const {boundsLimited: t, boundsIntent: o} = ii(e.direction, e.translation);
        vr(yo, oe = !0, oe), vr(Vo, Ee = o, Ee), vr(Bo, ee = t, ee)
    }, ({detail: e}) => {
        const {boundsLimited: t} = ii(e.direction, e.translation);
        vr(yo, oe = !1, oe), vr($o, N = !1, N), vr(Vo, Ee = void 0, Ee), fe(e.translation) && (vr(Bo, ee = t, ee), mo.write()), vr(Wo, Q = void 0, Q), no = void 0
    }, () => {
        no = "rotate", vr($o, N = !0, N), vr(Ho, Me = Je(U), Me)
    }, e => {
        vr(yo, oe = !0, oe), vr(Fo, ue = e, ue)
    }, e => {
        vr(yo, oe = !1, oe), vr($o, N = !1, N), vr(Fo, ue = e, ue), mo.write(), vr(Ho, Me = void 0, Me)
    }, () => {
        no = "pan", si = void 0, vr($o, N = !0, N), ai = Je(U)
    }, ({detail: e}) => {
        vr(yo, oe = !0, oe), li(e)
    }, ({detail: e}) => {
        vr(yo, oe = !1, oe), vr($o, N = !1, N), (fe(e.translation) > 0 || 0 !== e.scalar) && (li(e), mo.write()), vr(No, ke = void 0, ke), ai = void 0
    }, ({detail: {translation: e}}) => {
        H && (e = ge(me(e))), si = e, vr($o, N = !1, N)
    }, ci, di, ui, () => {
        no = "zoom", vr($o, N = !0, N), ai = Je(U)
    }, e => {
        vr(yo, oe = !1, oe), hi(e)
    }, e => {
        hi(e), mo.write(), vr(yo, oe = !1, oe), vr($o, N = !1, N), ai = void 0
    }, () => {
        no = "zoom", ai || (pi = Je(U), vr($o, N = !0, N))
    }, ({detail: e}) => {
        pi && (vr(yo, oe = !0, oe), mi(e))
    }, ({detail: e}) => {
        pi && (vr(yo, oe = !1, oe), vr($o, N = !1, N), mi(e), vr(No, ke = void 0, ke), pi = void 0, mo.write())
    }, e => {
        const t = hm(e, ve, te);
        if (Et && !bt(ee, t)) return;
        no = "zoom", vr($o, N = !0, N), vr(yo, oe = !0, oe), e.preventDefault(), e.stopPropagation();
        const o = Pp(e, {fixScrollDirection: be}), i = 1 + o / 100, n = Je(U),
            r = 1 === Math.min(U.width / $e.width, U.height / $e.height);
        if ($t && pe) {
            const e = uo(U, de, ue);
            if (ao() && e && o > 0 && d) {
                vr($o, N = !1, N), vr(yo, oe = !1, oe);
                const e = K(ue) ? et({height: de.width, width: de.height}) : et(de);
                if (pt(n, e)) return;
                if (clearTimeout(gi), pt(mo.state.crop, e)) return;
                return vr(jo, U = e, U), void mo.write()
            }
        }
        let a = st(U);
        if (It && "selection" !== Gt && o < 0 && !r) {
            const e = Se(me(t), ee), o = Math.min(ee.width / U.width, ee.height / U.height), i = ct(Je(ee), 1.1);
            a = bt(i, t) ? we(Je(U), Ce(e, 1 / o)) : a
        }
        let s = ct(Je(U), i, a);
        if (Ue(ce[1], s) || (s = rt(st(s), ce[1])), Ue(s, ce[0]) || (s = rt(st(s), ce[0])), pt(n, s, le)) return vr($o, N = !1, N), void vr(yo, oe = !1, oe);
        vr(jo, U = kt(s, (e => le(e, 5))), U), vr($o, N = !1, N), vr(yo, oe = !1, oe), clearTimeout(gi), gi = setTimeout((() => {
            mo.write()
        }), 500)
    }, $i, yi, bi, xi, wi, Si, Pi, Vt, "crop", nt, ut, gt, $t, ft, St, Tt, Mt, Pt, Rt, It, Et, At, Lt, Ft, zt, Dt, Bt, Ot, Wt, _t, Nt, Ht, jt, Ut, Gt, Xt, qt, Kt, fi, p, T, C, w, S, i, a, s, m, d, u, c, h, l, F, D, B, O, W, _, N, H, j, U, X, Y, Q, ee, te, de, pe, $e, Le, Fe, De, We, _e, function (t) {
        da.call(this, e, t)
    }, ({detail: e}) => o(5, Ti = e), function (e) {
        ha[e ? "unshift" : "push"]((() => {
            ki = e, o(6, ki)
        }))
    }, e => um(e), function (e) {
        Mi = e, o(16, Mi)
    }, function (t) {
        da.call(this, e, t)
    }]
}

var Ly = {
    util: ["crop", class extends Ga {
        constructor(e) {
            super(), Ua(this, e, Ay, Py, lr, {
                name: 98,
                isActive: 0,
                stores: 99,
                cropImageSelectionCornerStyle: 1,
                cropWillRenderImageSelectionGuides: 100,
                cropAutoCenterImageSelectionTimeout: 101,
                cropEnableZoomMatchImageAspectRatio: 102,
                cropEnableRotateMatchImageAspectRatio: 103,
                cropEnableRotationInput: 104,
                cropEnableZoom: 2,
                cropEnableZoomInput: 105,
                cropEnableZoomAutoHide: 106,
                cropEnableImageSelection: 107,
                cropEnableInfoIndicator: 108,
                cropEnableZoomTowardsWheelPosition: 109,
                cropEnableLimitWheelInputToCropSelection: 110,
                cropEnableCenterImageSelection: 111,
                cropEnableButtonRotateLeft: 112,
                cropEnableButtonRotateRight: 113,
                cropEnableButtonFlipHorizontal: 114,
                cropEnableButtonFlipVertical: 115,
                cropSelectPresetOptions: 116,
                cropEnableSelectPreset: 117,
                cropEnableFilterMatchAspectRatio: 118,
                cropSelectPresetFilter: 97,
                cropEnableButtonToggleCropLimit: 119,
                cropWillRenderTools: 120,
                cropWillRenderInfoIndicator: 121,
                cropActiveTransformTool: 122,
                cropMinimizeToolbar: 123,
                cropInteractionFocus: 124,
                cropRotationRange: 3,
                cropMaskOpacity: 125,
                locale: 4,
                cropFormatIconSelectPreset: 126,
                cropFormatIconCropBoundary: 127
            }, null, [-1, -1, -1, -1, -1, -1, -1, -1])
        }

        get name() {
            return this.$$.ctx[98]
        }

        get isActive() {
            return this.$$.ctx[0]
        }

        set isActive(e) {
            this.$$set({isActive: e}), ka()
        }

        get stores() {
            return this.$$.ctx[99]
        }

        set stores(e) {
            this.$$set({stores: e}), ka()
        }

        get cropImageSelectionCornerStyle() {
            return this.$$.ctx[1]
        }

        set cropImageSelectionCornerStyle(e) {
            this.$$set({cropImageSelectionCornerStyle: e}), ka()
        }

        get cropWillRenderImageSelectionGuides() {
            return this.$$.ctx[100]
        }

        set cropWillRenderImageSelectionGuides(e) {
            this.$$set({cropWillRenderImageSelectionGuides: e}), ka()
        }

        get cropAutoCenterImageSelectionTimeout() {
            return this.$$.ctx[101]
        }

        set cropAutoCenterImageSelectionTimeout(e) {
            this.$$set({cropAutoCenterImageSelectionTimeout: e}), ka()
        }

        get cropEnableZoomMatchImageAspectRatio() {
            return this.$$.ctx[102]
        }

        set cropEnableZoomMatchImageAspectRatio(e) {
            this.$$set({cropEnableZoomMatchImageAspectRatio: e}), ka()
        }

        get cropEnableRotateMatchImageAspectRatio() {
            return this.$$.ctx[103]
        }

        set cropEnableRotateMatchImageAspectRatio(e) {
            this.$$set({cropEnableRotateMatchImageAspectRatio: e}), ka()
        }

        get cropEnableRotationInput() {
            return this.$$.ctx[104]
        }

        set cropEnableRotationInput(e) {
            this.$$set({cropEnableRotationInput: e}), ka()
        }

        get cropEnableZoom() {
            return this.$$.ctx[2]
        }

        set cropEnableZoom(e) {
            this.$$set({cropEnableZoom: e}), ka()
        }

        get cropEnableZoomInput() {
            return this.$$.ctx[105]
        }

        set cropEnableZoomInput(e) {
            this.$$set({cropEnableZoomInput: e}), ka()
        }

        get cropEnableZoomAutoHide() {
            return this.$$.ctx[106]
        }

        set cropEnableZoomAutoHide(e) {
            this.$$set({cropEnableZoomAutoHide: e}), ka()
        }

        get cropEnableImageSelection() {
            return this.$$.ctx[107]
        }

        set cropEnableImageSelection(e) {
            this.$$set({cropEnableImageSelection: e}), ka()
        }

        get cropEnableInfoIndicator() {
            return this.$$.ctx[108]
        }

        set cropEnableInfoIndicator(e) {
            this.$$set({cropEnableInfoIndicator: e}), ka()
        }

        get cropEnableZoomTowardsWheelPosition() {
            return this.$$.ctx[109]
        }

        set cropEnableZoomTowardsWheelPosition(e) {
            this.$$set({cropEnableZoomTowardsWheelPosition: e}), ka()
        }

        get cropEnableLimitWheelInputToCropSelection() {
            return this.$$.ctx[110]
        }

        set cropEnableLimitWheelInputToCropSelection(e) {
            this.$$set({cropEnableLimitWheelInputToCropSelection: e}), ka()
        }

        get cropEnableCenterImageSelection() {
            return this.$$.ctx[111]
        }

        set cropEnableCenterImageSelection(e) {
            this.$$set({cropEnableCenterImageSelection: e}), ka()
        }

        get cropEnableButtonRotateLeft() {
            return this.$$.ctx[112]
        }

        set cropEnableButtonRotateLeft(e) {
            this.$$set({cropEnableButtonRotateLeft: e}), ka()
        }

        get cropEnableButtonRotateRight() {
            return this.$$.ctx[113]
        }

        set cropEnableButtonRotateRight(e) {
            this.$$set({cropEnableButtonRotateRight: e}), ka()
        }

        get cropEnableButtonFlipHorizontal() {
            return this.$$.ctx[114]
        }

        set cropEnableButtonFlipHorizontal(e) {
            this.$$set({cropEnableButtonFlipHorizontal: e}), ka()
        }

        get cropEnableButtonFlipVertical() {
            return this.$$.ctx[115]
        }

        set cropEnableButtonFlipVertical(e) {
            this.$$set({cropEnableButtonFlipVertical: e}), ka()
        }

        get cropSelectPresetOptions() {
            return this.$$.ctx[116]
        }

        set cropSelectPresetOptions(e) {
            this.$$set({cropSelectPresetOptions: e}), ka()
        }

        get cropEnableSelectPreset() {
            return this.$$.ctx[117]
        }

        set cropEnableSelectPreset(e) {
            this.$$set({cropEnableSelectPreset: e}), ka()
        }

        get cropEnableFilterMatchAspectRatio() {
            return this.$$.ctx[118]
        }

        set cropEnableFilterMatchAspectRatio(e) {
            this.$$set({cropEnableFilterMatchAspectRatio: e}), ka()
        }

        get cropSelectPresetFilter() {
            return this.$$.ctx[97]
        }

        set cropSelectPresetFilter(e) {
            this.$$set({cropSelectPresetFilter: e}), ka()
        }

        get cropEnableButtonToggleCropLimit() {
            return this.$$.ctx[119]
        }

        set cropEnableButtonToggleCropLimit(e) {
            this.$$set({cropEnableButtonToggleCropLimit: e}), ka()
        }

        get cropWillRenderTools() {
            return this.$$.ctx[120]
        }

        set cropWillRenderTools(e) {
            this.$$set({cropWillRenderTools: e}), ka()
        }

        get cropWillRenderInfoIndicator() {
            return this.$$.ctx[121]
        }

        set cropWillRenderInfoIndicator(e) {
            this.$$set({cropWillRenderInfoIndicator: e}), ka()
        }

        get cropActiveTransformTool() {
            return this.$$.ctx[122]
        }

        set cropActiveTransformTool(e) {
            this.$$set({cropActiveTransformTool: e}), ka()
        }

        get cropMinimizeToolbar() {
            return this.$$.ctx[123]
        }

        set cropMinimizeToolbar(e) {
            this.$$set({cropMinimizeToolbar: e}), ka()
        }

        get cropInteractionFocus() {
            return this.$$.ctx[124]
        }

        set cropInteractionFocus(e) {
            this.$$set({cropInteractionFocus: e}), ka()
        }

        get cropRotationRange() {
            return this.$$.ctx[3]
        }

        set cropRotationRange(e) {
            this.$$set({cropRotationRange: e}), ka()
        }

        get cropMaskOpacity() {
            return this.$$.ctx[125]
        }

        set cropMaskOpacity(e) {
            this.$$set({cropMaskOpacity: e}), ka()
        }

        get locale() {
            return this.$$.ctx[4]
        }

        set locale(e) {
            this.$$set({locale: e}), ka()
        }

        get cropFormatIconSelectPreset() {
            return this.$$.ctx[126]
        }

        set cropFormatIconSelectPreset(e) {
            this.$$set({cropFormatIconSelectPreset: e}), ka()
        }

        get cropFormatIconCropBoundary() {
            return this.$$.ctx[127]
        }

        set cropFormatIconCropBoundary(e) {
            this.$$set({cropFormatIconCropBoundary: e}), ka()
        }
    }]
};

function Fy(e) {
    let t, o, i, n, r, a, s, l = e[77], c = (M(e[77].label) ? e[77].label(e[2]) : e[77].label) + "";

    function d(...t) {
        return e[51](e[77], ...t)
    }

    const u = () => e[52](o, l), h = () => e[52](null, l);
    return {
        c() {
            t = Fr("div"), o = Fr("div"), i = Br(), n = Fr("span"), r = Dr(c), Nr(o, "class", Oy), Nr(t, "slot", "option"), Nr(t, "class", "PinturaFilterOption")
        }, m(e, l) {
            Ar(e, t, l), Rr(t, o), u(), Rr(t, i), Rr(t, n), Rr(n, r), a || (s = [Wr(o, "measure", d), wr(zc.call(null, o))], a = !0)
        }, p(t, o) {
            l !== (e = t)[77] && (h(), l = e[77], u()), 4 & o[0] | 32768 & o[2] && c !== (c = (M(e[77].label) ? e[77].label(e[2]) : e[77].label) + "") && Ur(r, c)
        }, d(e) {
            e && Lr(t), h(), a = !1, ar(s)
        }
    }
}

function zy(e) {
    let t, o;
    return t = new Eu({
        props: {
            locale: e[2],
            layout: "row",
            options: e[3],
            selectedIndex: e[12],
            onchange: e[32],
            $$slots: {option: [Fy, ({option: e}) => ({77: e}), ({option: e}) => [0, 0, e ? 32768 : 0]]},
            $$scope: {ctx: e}
        }
    }), {
        c() {
            Na(t.$$.fragment)
        }, m(e, i) {
            Ha(t, e, i), o = !0
        }, p(e, o) {
            const i = {};
            4 & o[0] && (i.locale = e[2]), 8 & o[0] && (i.options = e[3]), 4096 & o[0] && (i.selectedIndex = e[12]), 1028 & o[0] | 98304 & o[2] && (i.$$scope = {
                dirty: o,
                ctx: e
            }), t.$set(i)
        }, i(e) {
            o || (Ea(t.$$.fragment, e), o = !0)
        }, o(e) {
            Aa(t.$$.fragment, e), o = !1
        }, d(e) {
            ja(t, e)
        }
    }
}

function Dy(e) {
    let t, o, i, n, r, a, s, l;

    function c(t) {
        e[54](t)
    }

    function d(t) {
        e[55](t)
    }

    function u(t) {
        e[56](t)
    }

    let h = {elasticity: e[13] * e[19], onscroll: e[53], $$slots: {default: [zy]}, $$scope: {ctx: e}};
    return void 0 !== e[4] && (h.maskFeatherStartOpacity = e[4]), void 0 !== e[5] && (h.maskFeatherEndOpacity = e[5]), void 0 !== e[6] && (h.maskFeatherSize = e[6]), o = new Ep({props: h}), ha.push((() => _a(o, "maskFeatherStartOpacity", c))), ha.push((() => _a(o, "maskFeatherEndOpacity", d))), ha.push((() => _a(o, "maskFeatherSize", u))), o.$on("measure", e[57]), {
        c() {
            t = Fr("div"), Na(o.$$.fragment), Nr(t, "slot", "footer"), Zr(t, "transform", e[11])
        }, m(i, n) {
            Ar(i, t, n), Ha(o, t, null), a = !0, s || (l = [Wr(t, "transitionend", e[30]), Wr(t, "measure", e[58]), wr(zc.call(null, t, {observePosition: !0}))], s = !0)
        }, p(e, a) {
            const s = {};
            8192 & a[0] && (s.elasticity = e[13] * e[19]), 128 & a[0] && (s.onscroll = e[53]), 5132 & a[0] | 65536 & a[2] && (s.$$scope = {
                dirty: a,
                ctx: e
            }), !i && 16 & a[0] && (i = !0, s.maskFeatherStartOpacity = e[4], xa((() => i = !1))), !n && 32 & a[0] && (n = !0, s.maskFeatherEndOpacity = e[5], xa((() => n = !1))), !r && 64 & a[0] && (r = !0, s.maskFeatherSize = e[6], xa((() => r = !1))), o.$set(s), 2048 & a[0] && Zr(t, "transform", e[11])
        }, i(e) {
            a || (Ea(o.$$.fragment, e), a = !0)
        }, o(e) {
            Aa(o.$$.fragment, e), a = !1
        }, d(e) {
            e && Lr(t), ja(o), s = !1, ar(l)
        }
    }
}

function By(e) {
    let t, o;
    return t = new Wf({props: {$$slots: {footer: [Dy]}, $$scope: {ctx: e}}}), t.$on("measure", e[59]), {
        c() {
            Na(t.$$.fragment)
        }, m(e, i) {
            Ha(t, e, i), o = !0
        }, p(e, o) {
            const i = {};
            16380 & o[0] | 65536 & o[2] && (i.$$scope = {dirty: o, ctx: e}), t.$set(i)
        }, i(e) {
            o || (Ea(t.$$.fragment, e), o = !0)
        }, o(e) {
            Aa(t.$$.fragment, e), o = !1
        }, d(e) {
            ja(t, e)
        }
    }
}

let Oy = "PinturaFilterPreview";

function Wy(e, t, o) {
    let i, n, r, a, s, l, c, d, u, h, p, m, g, $, f, y, b, x, v, w, S = tr,
        k = () => (S(), S = ur(R, (e => o(43, d = e))), R), C = tr, T = () => (C(), C = ur(P, (e => o(49, b = e))), P);
    e.$$.on_destroy.push((() => S())), e.$$.on_destroy.push((() => C()));
    let {isActive: P} = t;
    T();
    let {isActiveFraction: R} = t;
    k();
    let {stores: I} = t, {locale: E} = t, {filterFunctions: A} = t, {filterOptions: L} = t;
    const F = ca("elasticityMultiplier");
    pr(e, F, (e => o(13, w = e)));
    const {
        history: z,
        interfaceImages: D,
        stageRectBase: B,
        utilRect: O,
        animation: W,
        scrollElasticity: V,
        imageSize: _,
        imagePreview: N,
        imageCropRect: H,
        imageRotation: j,
        imageFlipX: U,
        imageFlipY: G,
        imageBackgroundColor: Z,
        imageGamma: X,
        imageColorMatrix: Y,
        allowPan: q,
        allowZoom: K,
        allowZoomControls: J,
        allowPlayPause: Q
    } = I;
    pr(e, D, (e => o(60, u = e))), pr(e, B, (e => o(48, y = e))), pr(e, O, (e => o(47, f = e))), pr(e, W, (e => o(50, x = e))), pr(e, _, (e => o(62, p = e))), pr(e, N, (e => o(42, c = e))), pr(e, Z, (e => o(61, h = e))), pr(e, X, (e => o(44, m = e))), pr(e, Y, (e => o(40, s = e)));
    const ee = Ya({});
    pr(e, ee, (e => o(46, $ = e)));
    const te = (e, t) => vr(ee, $[e.value] = t, $), oe = qa(ee, (e => {
        if (!e[void 0]) return;
        const t = e[void 0];
        return v && _e(v, t) ? v : ze(t)
    }));
    pr(e, oe, (e => o(63, v = e)));
    const ie = qa([P, oe, H, _, j, U, G], (([e, t, o, i, n, r, a], s) => {
        if (!e || !t || !i) return g;
        const l = et(i), c = st(l), d = ms(i, o, n), u = st(d), h = Se(me(c), u), p = ge(me(h)),
            m = Math.max(t.width / o.width, t.height / o.height);
        s({origin: p, translation: h, rotation: {x: a ? Math.PI : 0, y: r ? Math.PI : 0, z: n}, scale: m})
    }));
    pr(e, ie, (e => o(45, g = e)));
    const ne = bc(x ? 20 : 0);
    let re;
    pr(e, ne, (e => o(39, a = e)));
    const ae = {};
    let se, le, ce, de, ue, pe, $e = {x: 0, y: 0};
    const fe = Ya([]);
    pr(e, fe, (e => o(41, l = e)));
    const ye = e => {
        const t = {...e, data: c, size: p, offset: {...e.offset}, mask: {...e.mask}, backgroundColor: h};
        return t.opacity = d, t.offset.y += a, t.mask.y += a, t.id = "filter", t
    }, be = () => u.filter((e => "filter" !== e.id));
    aa((() => {
        D.set([])
    }));
    return e.$$set = e => {
        "isActive" in e && T(o(0, P = e.isActive)), "isActiveFraction" in e && k(o(1, R = e.isActiveFraction)), "stores" in e && o(34, I = e.stores), "locale" in e && o(2, E = e.locale), "filterFunctions" in e && o(35, A = e.filterFunctions), "filterOptions" in e && o(3, L = e.filterOptions)
    }, e.$$.update = () => {
        if (262144 & e.$$.dirty[1] && q.set(b), 262144 & e.$$.dirty[1] && K.set(b), 262144 & e.$$.dirty[1] && J.set(b), 262144 & e.$$.dirty[1] && b && Q.set(!1), 8 & e.$$.dirty[0] && o(38, i = tu(L)), 640 & e.$$.dirty[1] && o(12, n = ((e, t) => {
            if (!e || !e.filter || !t) return 0;
            const o = e.filter;
            return t.findIndex((([e]) => {
                if (!A[e]) return !1;
                const t = A[e]();
                return xs(t, o)
            }))
        })(s, i)), 786432 & e.$$.dirty[1] && x && ne.set(b ? 0 : 20), 512 & e.$$.dirty[0] | 458752 & e.$$.dirty[1] && b && f && y && pe && o(37, ue = {
            x: y.x - f.x,
            y: y.y - f.y + pe.y
        }), 496 & e.$$.dirty[0] | 58096 & e.$$.dirty[1] && g && ue && $e && de && re) {
            const e = ue.x + de.x + $e.x, t = ue.y, o = de.x + ue.x, n = o + de.width;
            fe.set(i.map((([i], r) => {
                const a = $[i], l = $e.x + a.x, c = l + a.width;
                if (c < 0 || l > de.width) return !1;
                const d = e + a.x, u = t + a.y, h = (e => ({
                    origin: me(e.origin),
                    translation: me(e.translation),
                    rotation: {...e.rotation},
                    scale: e.scale
                }))(g);
                h.offset = he(.5 * a.width + d, .5 * a.height + u);
                h.maskOpacity = 1, h.mask = at(d + 0, u, a.width + 0, a.height), h.maskFeather = [1, 0, 1, 0, 1, n, 1, n], l < ce && se < 1 && (h.maskFeather[0] = se, h.maskFeather[1] = o, h.maskFeather[2] = 1, h.maskFeather[3] = o + ce), c > de.width - ce && le < 1 && (h.maskFeather[4] = le, h.maskFeather[5] = n - ce, h.maskFeather[6] = 1, h.maskFeather[7] = n), h.maskCornerRadius = re[i];
                let p = s && Object.keys(s).filter((e => "filter" != e)).map((e => s[e])) || [];
                return M(A[i]) && p.push(A[i]()), h.colorMatrix = p.length ? Qn(p) : void 0, h.gamma = m, h
            })).filter(Boolean))
        }
        if (7424 & e.$$.dirty[1]) if (d > 0 && l) {
            const e = [...be(), ...l.map(ye)];
            D.set(e)
        } else D.set(be());
        256 & e.$$.dirty[1] && o(11, r = a ? `translateY(${a}px)` : "none")
    }, [P, R, E, L, se, le, ce, $e, de, pe, ae, r, n, w, F, D, B, O, W, V, _, N, Z, X, Y, ee, te, oe, ie, ne, e => {
        e.target.className === Oy && o(36, re = Object.keys(ae).reduce(((e, t) => {
            const o = ae[t], i = getComputedStyle(o),
                n = ["top-left", "top-right", "bottom-left", "bottom-right"].map((e => i.getPropertyValue(`border-${e}-radius`))).map(Mp).map((e => 1.25 * e));
            return e[t] = n, e
        }), {}))
    }, fe, ({value: e}) => {
        vr(Y, s = {...s, filter: M(A[e]) ? A[e]() : void 0}, s), z.write()
    }, "filter", I, A, re, ue, i, a, s, l, c, d, m, g, $, f, y, b, x, (e, t) => te(e, t.detail), function (e, t) {
        ha[e ? "unshift" : "push"]((() => {
            ae[t.value] = e, o(10, ae)
        }))
    }, e => o(7, $e = e), function (e) {
        se = e, o(4, se)
    }, function (e) {
        le = e, o(5, le)
    }, function (e) {
        ce = e, o(6, ce)
    }, e => o(8, de = e.detail), e => o(9, pe = e.detail), function (t) {
        da.call(this, e, t)
    }]
}

var Vy = {
    util: ["filter", class extends Ga {
        constructor(e) {
            super(), Ua(this, e, Wy, By, lr, {
                name: 33,
                isActive: 0,
                isActiveFraction: 1,
                stores: 34,
                locale: 2,
                filterFunctions: 35,
                filterOptions: 3
            }, null, [-1, -1, -1])
        }

        get name() {
            return this.$$.ctx[33]
        }

        get isActive() {
            return this.$$.ctx[0]
        }

        set isActive(e) {
            this.$$set({isActive: e}), ka()
        }

        get isActiveFraction() {
            return this.$$.ctx[1]
        }

        set isActiveFraction(e) {
            this.$$set({isActiveFraction: e}), ka()
        }

        get stores() {
            return this.$$.ctx[34]
        }

        set stores(e) {
            this.$$set({stores: e}), ka()
        }

        get locale() {
            return this.$$.ctx[2]
        }

        set locale(e) {
            this.$$set({locale: e}), ka()
        }

        get filterFunctions() {
            return this.$$.ctx[35]
        }

        set filterFunctions(e) {
            this.$$set({filterFunctions: e}), ka()
        }

        get filterOptions() {
            return this.$$.ctx[3]
        }

        set filterOptions(e) {
            this.$$set({filterOptions: e}), ka()
        }
    }]
};

function _y(e) {
    let t, o, i, n;
    t = new Ep({
        props: {
            elasticity: e[6] * e[9],
            class: "PinturaControlListScroller",
            $$slots: {default: [Hy]},
            $$scope: {ctx: e}
        }
    });
    const r = [{class: "PinturaControlPanels"}, {panelClass: "PinturaControlPanel"}, {panels: e[4]}, e[5]];
    let a = {$$slots: {default: [jy, ({panel: e}) => ({42: e}), ({panel: e}) => [0, e ? 2048 : 0]]}, $$scope: {ctx: e}};
    for (let e = 0; e < r.length; e += 1) a = ir(a, r[e]);
    return i = new md({props: a}), {
        c() {
            Na(t.$$.fragment), o = Br(), Na(i.$$.fragment)
        }, m(e, r) {
            Ha(t, e, r), Ar(e, o, r), Ha(i, e, r), n = !0
        }, p(e, o) {
            const n = {};
            64 & o[0] && (n.elasticity = e[6] * e[9]), 38 & o[0] | 8192 & o[1] && (n.$$scope = {
                dirty: o,
                ctx: e
            }), t.$set(n);
            const a = 48 & o[0] ? Wa(r, [r[0], r[1], 16 & o[0] && {panels: e[4]}, 32 & o[0] && Va(e[5])]) : {};
            128 & o[0] | 10240 & o[1] && (a.$$scope = {dirty: o, ctx: e}), i.$set(a)
        }, i(e) {
            n || (Ea(t.$$.fragment, e), Ea(i.$$.fragment, e), n = !0)
        }, o(e) {
            Aa(t.$$.fragment, e), Aa(i.$$.fragment, e), n = !1
        }, d(e) {
            ja(t, e), e && Lr(o), ja(i, e)
        }
    }
}

function Ny(e) {
    let t, o, i = e[43].label + "";
    return {
        c() {
            t = Fr("span"), o = Dr(i)
        }, m(e, i) {
            Ar(e, t, i), Rr(t, o)
        }, p(e, t) {
            4096 & t[1] && i !== (i = e[43].label + "") && Ur(o, i)
        }, d(e) {
            e && Lr(t)
        }
    }
}

function Hy(e) {
    let t, o;
    const i = [{class: "PinturaControlList"}, {tabs: e[1]}, e[5]];
    let n = {$$slots: {default: [Ny, ({tab: e}) => ({43: e}), ({tab: e}) => [0, e ? 4096 : 0]]}, $$scope: {ctx: e}};
    for (let e = 0; e < i.length; e += 1) n = ir(n, i[e]);
    return t = new td({props: n}), t.$on("select", e[24]), {
        c() {
            Na(t.$$.fragment)
        }, m(e, i) {
            Ha(t, e, i), o = !0
        }, p(e, o) {
            const n = 34 & o[0] ? Wa(i, [i[0], 2 & o[0] && {tabs: e[1]}, 32 & o[0] && Va(e[5])]) : {};
            12288 & o[1] && (n.$$scope = {dirty: o, ctx: e}), t.$set(n)
        }, i(e) {
            o || (Ea(t.$$.fragment, e), o = !0)
        }, o(e) {
            Aa(t.$$.fragment, e), o = !1
        }, d(e) {
            ja(t, e)
        }
    }
}

function jy(e) {
    let t, o;
    const i = [e[7][e[42]]];
    let n = {};
    for (let e = 0; e < i.length; e += 1) n = ir(n, i[e]);
    return t = new Hf({props: n}), {
        c() {
            Na(t.$$.fragment)
        }, m(e, i) {
            Ha(t, e, i), o = !0
        }, p(e, o) {
            const n = 128 & o[0] | 2048 & o[1] ? Wa(i, [Va(e[7][e[42]])]) : {};
            t.$set(n)
        }, i(e) {
            o || (Ea(t.$$.fragment, e), o = !0)
        }, o(e) {
            Aa(t.$$.fragment, e), o = !1
        }, d(e) {
            ja(t, e)
        }
    }
}

function Uy(e) {
    let t, o, i = e[5] && _y(e);
    return {
        c() {
            t = Fr("div"), i && i.c(), Nr(t, "slot", "footer"), Zr(t, "transform", e[3])
        }, m(e, n) {
            Ar(e, t, n), i && i.m(t, null), o = !0
        }, p(e, o) {
            e[5] ? i ? (i.p(e, o), 32 & o[0] && Ea(i, 1)) : (i = _y(e), i.c(), Ea(i, 1), i.m(t, null)) : i && (Ra(), Aa(i, 1, 1, (() => {
                i = null
            })), Ia()), 8 & o[0] && Zr(t, "transform", e[3])
        }, i(e) {
            o || (Ea(i), o = !0)
        }, o(e) {
            Aa(i), o = !1
        }, d(e) {
            e && Lr(t), i && i.d()
        }
    }
}

function Gy(e) {
    let t, o;
    return t = new Wf({props: {$$slots: {footer: [Uy]}, $$scope: {ctx: e}}}), t.$on("measure", e[25]), {
        c() {
            Na(t.$$.fragment)
        }, m(e, i) {
            Ha(t, e, i), o = !0
        }, p(e, o) {
            const i = {};
            254 & o[0] | 8192 & o[1] && (i.$$scope = {dirty: o, ctx: e}), t.$set(i)
        }, i(e) {
            o || (Ea(t.$$.fragment, e), o = !0)
        }, o(e) {
            Aa(t.$$.fragment, e), o = !1
        }, d(e) {
            ja(t, e)
        }
    }
}

function Zy(e, t, o) {
    let i, n, r, a, s, l, c, d, u, h, p, m = tr, g = () => (m(), m = ur(f, (e => o(21, c = e))), f);
    e.$$.on_destroy.push((() => m()));
    let {stores: $} = t, {isActive: f} = t;
    g();
    let {locale: y = {}} = t, {finetuneControlConfiguration: b} = t, {finetuneOptions: x} = t, {finetuneNudgePrecision: v} = t;
    const {
        history: w,
        animation: S,
        scrollElasticity: k,
        rangeInputElasticity: C,
        imageColorMatrix: T,
        imageConvolutionMatrix: P,
        imageGamma: R,
        imageVignette: I,
        imageNoise: A,
        allowPan: L,
        allowZoom: F,
        allowZoomControls: z,
        allowPlayPause: D
    } = $;
    pr(e, S, (e => o(22, d = e)));
    const B = {imageColorMatrix: T, imageConvolutionMatrix: P, imageGamma: R, imageVignette: I, imageNoise: A},
        O = ca("elasticityMultiplier");
    pr(e, O, (e => o(6, h = e)));
    const W = "finetune-" + E(), V = Ya({});
    pr(e, V, (e => o(23, u = e)));
    const _ = Ya({});
    pr(e, _, (e => o(7, p = e)));
    let N = [];
    const H = bc(d ? 20 : 0);
    pr(e, H, (e => o(20, l = e)));
    return e.$$set = e => {
        "stores" in e && o(15, $ = e.stores), "isActive" in e && g(o(0, f = e.isActive)), "locale" in e && o(16, y = e.locale), "finetuneControlConfiguration" in e && o(17, b = e.finetuneControlConfiguration), "finetuneOptions" in e && o(18, x = e.finetuneOptions), "finetuneNudgePrecision" in e && o(19, v = e.finetuneNudgePrecision)
    }, e.$$.update = () => {
        var t;
        2097152 & e.$$.dirty[0] && L.set(c), 2097152 & e.$$.dirty[0] && F.set(c), 2097152 & e.$$.dirty[0] && z.set(c), 2097152 & e.$$.dirty[0] && c && D.set(!0), 327680 & e.$$.dirty[0] && o(1, i = x ? x.map((([e, t]) => ({
            id: e,
            label: M(t) ? t(y) : t
        }))) : []), 2 & e.$$.dirty[0] && o(2, n = i.length ? i[0].id : void 0), 4 & e.$$.dirty[0] && o(5, r = n && {
            name: W,
            selected: n
        }), 2 & e.$$.dirty[0] && o(4, a = i.map((e => e.id))), 131072 & e.$$.dirty[0] && b && (t = b, N && N.forEach((e => e())), N = a.map((e => {
            const {getStore: o, getValue: i = Z} = t[e];
            return o(B).subscribe((t => {
                const o = null != t ? i(t) : t;
                vr(V, u = {...u, [e]: o}, u)
            }))
        }))), 8519680 & e.$$.dirty[0] && b && u && vr(_, p = Object.keys(u).reduce(((e, t) => {
            const {base: o, min: i, max: n, getLabel: r, getStore: a, setValue: s = ((e, t) => e.set(t))} = b[t],
                l = a(B), c = null != u[t] ? u[t] : o;
            return e[t] = {
                base: o,
                min: i,
                max: n,
                value: c,
                valueLabel: r ? r(c, i, n, n - i) : Math.round(100 * c),
                oninputmove: e => {
                    s(l, e)
                },
                oninputend: e => {
                    s(l, e), w.write()
                },
                elasticity: h * C,
                labelReset: y.labelReset,
                nudgeMultiplier: v
            }, e
        }), {}), p), 6291456 & e.$$.dirty[0] && d && H.set(c ? 0 : 20), 1048576 & e.$$.dirty[0] && o(3, s = l ? `translateY(${l}px)` : "none")
    }, [f, i, n, s, a, r, h, p, S, k, O, V, _, H, "finetune", $, y, b, x, v, l, c, d, u, ({detail: e}) => o(2, n = e), function (t) {
        da.call(this, e, t)
    }]
}

var Xy = {
    util: ["finetune", class extends Ga {
        constructor(e) {
            super(), Ua(this, e, Zy, Gy, lr, {
                name: 14,
                stores: 15,
                isActive: 0,
                locale: 16,
                finetuneControlConfiguration: 17,
                finetuneOptions: 18,
                finetuneNudgePrecision: 19
            }, null, [-1, -1])
        }

        get name() {
            return this.$$.ctx[14]
        }

        get stores() {
            return this.$$.ctx[15]
        }

        set stores(e) {
            this.$$set({stores: e}), ka()
        }

        get isActive() {
            return this.$$.ctx[0]
        }

        set isActive(e) {
            this.$$set({isActive: e}), ka()
        }

        get locale() {
            return this.$$.ctx[16]
        }

        set locale(e) {
            this.$$set({locale: e}), ka()
        }

        get finetuneControlConfiguration() {
            return this.$$.ctx[17]
        }

        set finetuneControlConfiguration(e) {
            this.$$set({finetuneControlConfiguration: e}), ka()
        }

        get finetuneOptions() {
            return this.$$.ctx[18]
        }

        set finetuneOptions(e) {
            this.$$set({finetuneOptions: e}), ka()
        }

        get finetuneNudgePrecision() {
            return this.$$.ctx[19]
        }

        set finetuneNudgePrecision(e) {
            this.$$set({finetuneNudgePrecision: e}), ka()
        }
    }]
}, Yy = (e, t) => {
    const o = t.length;
    return e < 0 ? e % o + o : e >= o ? e % o : e
};

function qy(e, t, o) {
    const i = e.slice();
    return i[51] = t[o].key, i[52] = t[o].index, i[53] = t[o].translate, i[16] = t[o].scale, i[54] = t[o].selected, i[15] = t[o].rotate, i[55] = t[o].dir, i[56] = t[o].center, i[57] = t[o].type, i[4] = t[o].visible, i[58] = t[o].role, i[59] = t[o].tabindex, i[60] = t[o].label, i[61] = t[o].orientation, i[62] = t[o].valuemin, i[63] = t[o].valuemax, i[64] = t[o].valuenow, i
}

function Ky(e) {
    let t;
    return {
        c() {
            t = Fr("div"), Nr(t, "class", "PinturaShapeManipulator"), Nr(t, "data-control", "point"), Zr(t, "pointer-events", "none"), Zr(t, "opacity", e[6]), Zr(t, "transform", `translate3d(${e[56].x}px, ${e[56].y}px, 0) scale(${e[7]}, ${e[7]})`)
        }, m(e, o) {
            Ar(e, t, o)
        }, p(e, o) {
            64 & o[0] && Zr(t, "opacity", e[6]), 160 & o[0] && Zr(t, "transform", `translate3d(${e[56].x}px, ${e[56].y}px, 0) scale(${e[7]}, ${e[7]})`)
        }, d(e) {
            e && Lr(t)
        }
    }
}

function Jy(e, t) {
    let o, i, n, r, a, s, l, c, d, u, h, p, m, g;

    function $(...e) {
        return t[23](t[52], ...e)
    }

    let f = "edge" === t[57] && t[4] && Ky(t);
    return {
        key: e, first: null, c() {
            o = Fr("div"), h = Br(), f && f.c(), p = Or(), Nr(o, "role", i = t[58]), Nr(o, "tabindex", n = t[59]), Nr(o, "aria-label", r = t[60]), Nr(o, "aria-orientation", a = t[61]), Nr(o, "aria-valuemin", s = t[62]), Nr(o, "aria-valuemax", l = t[63]), Nr(o, "aria-valuenow", c = t[64]), Nr(o, "class", "PinturaShapeManipulator"), Nr(o, "data-control", d = t[57]), Nr(o, "data-selected", u = t[54]), Zr(o, "cursor", t[55] ? t[55] + "-resize" : "move"), Zr(o, "opacity", t[6]), Zr(o, "--tx", t[53].x), Zr(o, "--ty", t[53].y), Zr(o, "--r", ("edge" === t[57] ? t[15] : 0) + "rad"), Zr(o, "--sx", "point" === t[57] ? t[7] : t[16].x), Zr(o, "--sy", "point" === t[57] ? t[7] : t[16].y), this.first = o
        }, m(e, i) {
            Ar(e, o, i), Ar(e, h, i), f && f.m(e, i), Ar(e, p, i), m || (g = [Wr(o, "nudge", $), wr(rh.call(null, o, {preventDefault: !0})), Wr(o, "interactionstart", (function () {
                sr(t[11]("start", t[52])) && t[11]("start", t[52]).apply(this, arguments)
            })), Wr(o, "interactionupdate", (function () {
                sr(t[11]("move", t[52])) && t[11]("move", t[52]).apply(this, arguments)
            })), Wr(o, "interactionend", (function () {
                sr(t[11]("end", t[52])) && t[11]("end", t[52]).apply(this, arguments)
            })), wr(Sp.call(null, o, {observeKeys: !0}))], m = !0)
        }, p(e, h) {
            t = e, 32 & h[0] && i !== (i = t[58]) && Nr(o, "role", i), 32 & h[0] && n !== (n = t[59]) && Nr(o, "tabindex", n), 32 & h[0] && r !== (r = t[60]) && Nr(o, "aria-label", r), 32 & h[0] && a !== (a = t[61]) && Nr(o, "aria-orientation", a), 32 & h[0] && s !== (s = t[62]) && Nr(o, "aria-valuemin", s), 32 & h[0] && l !== (l = t[63]) && Nr(o, "aria-valuemax", l), 32 & h[0] && c !== (c = t[64]) && Nr(o, "aria-valuenow", c), 32 & h[0] && d !== (d = t[57]) && Nr(o, "data-control", d), 32 & h[0] && u !== (u = t[54]) && Nr(o, "data-selected", u), 32 & h[0] && Zr(o, "cursor", t[55] ? t[55] + "-resize" : "move"), 64 & h[0] && Zr(o, "opacity", t[6]), 32 & h[0] && Zr(o, "--tx", t[53].x), 32 & h[0] && Zr(o, "--ty", t[53].y), 32 & h[0] && Zr(o, "--r", ("edge" === t[57] ? t[15] : 0) + "rad"), 160 & h[0] && Zr(o, "--sx", "point" === t[57] ? t[7] : t[16].x), 160 & h[0] && Zr(o, "--sy", "point" === t[57] ? t[7] : t[16].y), "edge" === t[57] && t[4] ? f ? f.p(t, h) : (f = Ky(t), f.c(), f.m(p.parentNode, p)) : f && (f.d(1), f = null)
        }, d(e) {
            e && Lr(o), e && Lr(h), f && f.d(e), e && Lr(p), m = !1, ar(g)
        }
    }
}

function Qy(e) {
    let t, o, i;
    return {
        c() {
            t = Fr("div"), Nr(t, "role", "button"), Nr(t, "aria-label", "Drag rotator"), Nr(t, "tabindex", "0"), Nr(t, "class", "PinturaShapeManipulator"), Nr(t, "data-control", "rotate"), Zr(t, "transform", `translate3d(${e[0].x}px, ${e[0].y}px, 0) scale(${e[7]}, ${e[7]})`), Zr(t, "opacity", e[6])
        }, m(n, r) {
            Ar(n, t, r), o || (i = [Wr(t, "nudge", e[13]), wr(rh.call(null, t, {preventDefault: !0})), Wr(t, "interactionstart", e[15]("start")), Wr(t, "interactionupdate", e[15]("move")), Wr(t, "interactionend", e[15]("end")), wr(Sp.call(null, t, {observeKeys: !0}))], o = !0)
        }, p(e, o) {
            129 & o[0] && Zr(t, "transform", `translate3d(${e[0].x}px, ${e[0].y}px, 0) scale(${e[7]}, ${e[7]})`), 64 & o[0] && Zr(t, "opacity", e[6])
        }, d(e) {
            e && Lr(t), o = !1, ar(i)
        }
    }
}

function eb(e) {
    let t, o, i;
    return {
        c() {
            t = Fr("div"), Nr(t, "role", "button"), Nr(t, "aria-label", "Drag scalar"), Nr(t, "tabindex", "0"), Nr(t, "class", "PinturaShapeManipulator"), Nr(t, "data-control", "scale"), Zr(t, "transform", `translate3d(${e[1].x}px, ${e[1].y}px, 0) scale(${e[7]}, ${e[7]})`), Zr(t, "opacity", e[6])
        }, m(n, r) {
            Ar(n, t, r), o || (i = [Wr(t, "nudge", e[14]), wr(rh.call(null, t, {preventDefault: !0})), Wr(t, "interactionstart", e[16]("start")), Wr(t, "interactionupdate", e[16]("move")), Wr(t, "interactionend", e[16]("end")), wr(Sp.call(null, t, {observeKeys: !0}))], o = !0)
        }, p(e, o) {
            130 & o[0] && Zr(t, "transform", `translate3d(${e[1].x}px, ${e[1].y}px, 0) scale(${e[7]}, ${e[7]})`), 64 & o[0] && Zr(t, "opacity", e[6])
        }, d(e) {
            e && Lr(t), o = !1, ar(i)
        }
    }
}

function tb(e) {
    let t, o, i, n = [], r = new Map, a = e[5];
    const s = e => e[51];
    for (let t = 0; t < a.length; t += 1) {
        let o = qy(e, a, t), i = s(o);
        r.set(i, n[t] = Jy(i, o))
    }
    let l = e[2] && e[0] && Qy(e), c = e[3] && e[1] && eb(e);
    return {
        c() {
            for (let e = 0; e < n.length; e += 1) n[e].c();
            t = Br(), l && l.c(), o = Br(), c && c.c(), i = Or()
        }, m(e, r) {
            for (let t = 0; t < n.length; t += 1) n[t].m(e, r);
            Ar(e, t, r), l && l.m(e, r), Ar(e, o, r), c && c.m(e, r), Ar(e, i, r)
        }, p(e, d) {
            6368 & d[0] && (a = e[5], n = Oa(n, d, s, 1, e, a, r, t.parentNode, Da, Jy, t, qy)), e[2] && e[0] ? l ? l.p(e, d) : (l = Qy(e), l.c(), l.m(o.parentNode, o)) : l && (l.d(1), l = null), e[3] && e[1] ? c ? c.p(e, d) : (c = eb(e), c.c(), c.m(i.parentNode, i)) : c && (c.d(1), c = null)
        }, i: tr, o: tr, d(e) {
            for (let t = 0; t < n.length; t += 1) n[t].d(e);
            e && Lr(t), l && l.d(e), e && Lr(o), c && c.d(e), e && Lr(i)
        }
    }
}

function ob(e, t, o) {
    let i, n, r, a;
    const s = sa(), l = .5 * q, c = Y - l, d = Y + l, u = -Y, h = u - l, p = u + l, m = X - l, g = -X + l, $ = l,
        f = -l, y = Y - q, b = y - l, x = y + l, v = X - q, w = v - l, S = v + l, k = u - q, C = k + l, T = k - l,
        M = u + q, P = M + l, R = M - l;
    let {visible: I = !1} = t, {points: E = []} = t, {rotatorPoint: A} = t, {bounds: L = null} = t, {scalarPoint: F} = t, {selectedPoint: z} = t, {enableDragEdges: D = !0} = t, {enableDragPoints: B = !0} = t, {enableRotatePoints: O = !0} = t, {enableScalePoints: W = !0} = t;
    const V = ca("isAnimated");
    pr(e, V, (e => o(22, n = e)));
    const _ = bc(.5, {precision: 1e-4, stiffness: .3, damping: .7});
    pr(e, _, (e => o(7, a = e)));
    const N = bc(0, {precision: .001, stiffness: .3, damping: .7});
    pr(e, N, (e => o(6, r = e)));
    const H = e => {
        let t = "";
        return (e <= d && e >= c || e >= h && e <= p) && (t = "ns"), (e <= g || e >= m || e >= f && e <= $) && (t = "ew"), (e >= w && e <= S || e <= P && e >= R) && (t = "nesw"), (e >= b && e <= x || e <= C && e >= T) && (t = "nwse"), t
    }, j = (e, t) => {
        let o = 0;
        const i = Ee(e), n = [], r = e.length, [a, s, l, c] = e.reduce((([e, t, o, i], {
            x: n,
            y: r
        }) => (i = Math.min(i, n), t = Math.max(t, n), [e = Math.min(e, r), t, o = Math.max(o, r), i])), [1 / 0, -1 / 0, -1 / 0, 1 / 0]);
        for (; o < r; o++) {
            const t = Yy(o - 1, e), r = Yy(o + 1, e), d = e[t], u = e[o], h = e[r],
                p = Math.atan2(h.y - u.y, h.x - u.x);
            if (B) {
                const e = ye(he(d.x - u.x, d.y - u.y)), t = ye(he(h.x - u.x, h.y - u.y)), i = he(e.x + t.x, e.y + t.y),
                    r = D ? B && H(Math.atan2(i.y, i.x)) : void 0;
                n.push({
                    index: [o],
                    key: "point-" + o,
                    type: "point",
                    selected: z === o,
                    scale: {x: 1, y: 1},
                    translate: {x: u.x, y: u.y},
                    angle: void 0,
                    rotate: O,
                    center: u,
                    dir: r
                })
            }
            if (!D) continue;
            if (Array.isArray(D) && !D.some((([e, t]) => o === e && r === t))) continue;
            const m = he(u.x + .5 * (h.x - u.x), u.y + .5 * (h.y - u.y)), g = ["t", "r", "b", "l"][o];
            let $, f, y;
            "l" === g && ($ = L.x, f = s, y = c), "t" === g && ($ = L.y, f = l, y = a), "r" === g && ($ = c, f = L.width, y = s), "b" === g && ($ = a, f = L.height, y = l), n.push({
                index: [o, r],
                key: "edge-" + o,
                type: "edge",
                scale: {x: Re(u, h), y: 1},
                translate: {x: u.x, y: u.y},
                angle: p,
                rotate: p,
                center: m,
                visible: Array.isArray(D),
                dir: H(Math.atan2(i.y - m.y, i.x - m.x)),
                tabindex: 0,
                role: "slider",
                tabindex: 0,
                label: "Drag " + Uf[g],
                orientation: "" + Gf[g],
                valuemin: Math.round($),
                valuemax: Math.round(f),
                valuenow: Math.round(y)
            })
        }
        return n
    }, U = (e, t) => {
        s("resizestart", {indexes: e, translation: ue(), isNudge: !0}), s("resizemove", {
            indexes: e,
            translation: t,
            isNudge: !0
        }), s("resizeend", {indexes: e, translation: ue(), isNudge: !0})
    };
    return e.$$set = e => {
        "visible" in e && o(4, I = e.visible), "points" in e && o(17, E = e.points), "rotatorPoint" in e && o(0, A = e.rotatorPoint), "bounds" in e && o(18, L = e.bounds), "scalarPoint" in e && o(1, F = e.scalarPoint), "selectedPoint" in e && o(19, z = e.selectedPoint), "enableDragEdges" in e && o(20, D = e.enableDragEdges), "enableDragPoints" in e && o(21, B = e.enableDragPoints), "enableRotatePoints" in e && o(2, O = e.enableRotatePoints), "enableScalePoints" in e && o(3, W = e.enableScalePoints)
    }, e.$$.update = () => {
        4194320 & e.$$.dirty[0] && _.set(I ? 1 : .5, {hard: !1 === n}), 4194320 & e.$$.dirty[0] && N.set(I ? 1 : 0, {hard: !1 === n}), 131072 & e.$$.dirty[0] && o(5, i = j(E))
    }, [A, F, O, W, I, i, r, a, V, _, N, (e, t) => ({detail: o}) => {
        const i = o && o.translation ? o.translation : he(0, 0);
        s("resize" + e, {...o, indexes: t, translation: i})
    }, U, ({detail: e}) => {
        s("rotatestart", {translation: ue(), isNudge: !0}), s("rotatemove", {
            translation: e,
            isNudge: !0
        }), s("rotateend", {translation: ue(), isNudge: !0})
    }, ({detail: e}) => {
        s("scalestart", {translation: ue(), isNudge: !0}), s("scalemove", {
            translation: e,
            isNudge: !0
        }), s("scaleend", {translation: ue(), isNudge: !0})
    }, e => ({detail: t}) => {
        const o = t && t.translation ? t.translation : he(0, 0);
        s("rotate" + e, {...t, translation: o})
    }, e => ({detail: t}) => {
        const o = t && t.translation ? t.translation : he(0, 0);
        s("scale" + e, {...t, translation: o})
    }, E, L, z, D, B, n, (e, {detail: t}) => U(e, t)]
}

class ib extends Ga {
    constructor(e) {
        super(), Ua(this, e, ob, tb, lr, {
            visible: 4,
            points: 17,
            rotatorPoint: 0,
            bounds: 18,
            scalarPoint: 1,
            selectedPoint: 19,
            enableDragEdges: 20,
            enableDragPoints: 21,
            enableRotatePoints: 2,
            enableScalePoints: 3
        }, null, [-1, -1, -1])
    }
}

var nb = (e, t) => {
        const o = um(e);
        return Se(o, t)
    }, rb = e => document.createTextNode(e),
    ab = e => (Kt() && e.endsWith("<div><br></div>") ? e.replace(/<div><br><\/div>$/, "<br><br>") : e).replace(/<div><br><\/div>/g, "<br>").replace(/<\/div>/g, "").replace(/<div>/g, "<br>");

function sb(e) {
    let t, o, i, n;
    return {
        c() {
            t = Fr("pre"), Nr(t, "class", "PinturaContentEditable")
        }, m(r, a) {
            Ar(r, t, a), t.innerHTML = e[0], i || (n = wr(o = od.call(null, t, e[7] + ";position:absolute;z-index:-1;pointer-events:none;")), i = !0)
        }, p(e, i) {
            1 & i[0] && (t.innerHTML = e[0]), o && sr(o.update) && 128 & i[0] && o.update.call(null, e[7] + ";position:absolute;z-index:-1;pointer-events:none;")
        }, d(e) {
            e && Lr(t), i = !1, n()
        }
    }
}

function lb(e) {
    let t, o, i, n, r, a, s = e[8] && sb(e);
    return {
        c() {
            s && s.c(), t = Br(), o = Fr("pre"), Nr(o, "class", "PinturaContentEditable"), Nr(o, "data-wrap-content", i = e[4] || e[5] ? "wrap" : "nowrap"), Nr(o, "contenteditable", ""), Nr(o, "spellcheck", e[1]), Nr(o, "autocorrect", e[2]), Nr(o, "autocapitalize", e[3])
        }, m(i, l) {
            s && s.m(i, l), Ar(i, t, l), Ar(i, o, l), e[26](o), r || (a = [wr(n = od.call(null, o, e[8] ? e[15](e[7]) : e[7])), Wr(o, "input", e[13]), Wr(o, "compositionend", e[12]), Wr(o, "paste", e[14]), Wr(o, "keydown", e[10]), Wr(o, "keyup", e[11]), Wr(o, "blur", e[9])], r = !0)
        }, p(e, r) {
            e[8] ? s ? s.p(e, r) : (s = sb(e), s.c(), s.m(t.parentNode, t)) : s && (s.d(1), s = null), 48 & r[0] && i !== (i = e[4] || e[5] ? "wrap" : "nowrap") && Nr(o, "data-wrap-content", i), 2 & r[0] && Nr(o, "spellcheck", e[1]), 4 & r[0] && Nr(o, "autocorrect", e[2]), 8 & r[0] && Nr(o, "autocapitalize", e[3]), n && sr(n.update) && 384 & r[0] && n.update.call(null, e[8] ? e[15](e[7]) : e[7])
        }, i: tr, o: tr, d(i) {
            s && s.d(i), i && Lr(t), i && Lr(o), e[26](null), r = !1, ar(a)
        }
    }
}

function cb(e, t, o) {
    let n,
        r, {spellcheck: a = "false"} = t, {autocorrect: s = "off"} = t, {autocapitalize: l = "off"} = t, {wrapLines: c = !0} = t, {allowNewline: d = !0} = t, {textFormat: u = "text"} = t, {formatInput: h = Z} = t, {formatPaste: p = Z} = t, {styles: g} = t, {innerHTML: $} = t, {oninput: f = i} = t, {enableTextStyleShortcuts: y = !1} = t;
    const b = () => {
        if (!v) return;
        const e = document.createRange();
        e.selectNodeContents(v);
        const t = P();
        t.removeAllRanges(), t.addRange(e)
    }, x = sa();
    let v;
    document.execCommand("defaultParagraphSeparator", !1, "br");
    const w = e => e.replace(/<\/?(?:i|b|em|u|s|strike|strong|font)>/, "").replace(/style=".*?"/g, "").replace(/\n/gim, "<br>"),
        S = () => {
            o(0, $ = v.innerHTML);
            const e = ab($);
            x("input", e), f(e), requestAnimationFrame((() => v && v.scrollTo(0, 0)))
        }, k = () => {
            R(v);
            const e = "html" === u ? v.innerHTML : w(v.innerHTML);
            o(6, v.innerHTML = h(e), v), I(v), S()
        }, C = {b: "bold", i: "italic", u: "underline", s: "strikethrough"}, T = e => {
            const t = m("span");
            return t.dataset.bookmark = e, t
        }, M = (e, t, o) => {
            const i = T(o);
            if (e.nodeType === Node.TEXT_NODE) {
                const n = e.textContent;
                if ("start" === o) {
                    const o = rb(n.substring(0, t)), r = rb(n.substring(t));
                    e.replaceWith(o, i, r)
                } else {
                    const o = rb(n.substring(0, t)), r = rb(n.substring(t));
                    e.replaceWith(o, i, r)
                }
            } else e.nodeType === Node.ELEMENT_NODE && e.insertBefore(i, e.childNodes[t])
        }, P = () => {
            const e = v.getRootNode();
            return "getSelection" in e ? e.getSelection() : document.getSelection()
        }, R = e => {
            const t = P();
            if (!t.getRangeAt || !t.rangeCount) return;
            const o = t.getRangeAt(0), {startOffset: i, endOffset: n, startContainer: r, endContainer: a} = o;
            if (e.contains(o.startContainer) && e.contains(o.endContainer)) if (r.nodeType === Node.TEXT_NODE && r === a) {
                const e = r.textContent, t = e.substring(0, i), o = T("start"), a = n - i > 0 ? e.substring(i, n) : "",
                    s = T("end"), l = e.substring(n);
                r.replaceWith(t, o, a, s, l)
            } else M(r, i, "start"), M(a, n + (r === a ? 1 : 0), "end")
        }, I = e => {
            const t = E(e, "start"), o = E(e, "end");
            if (!t || !o) return;
            const i = document.createRange();
            i.setStart(t, 0), i.setEnd(o, 0);
            const n = P();
            n.removeAllRanges(), n.addRange(i), t.remove(), o.remove()
        }, E = (e, t) => {
            const o = e.children;
            for (let e = 0; e < o.length; e++) {
                const i = o[e];
                if (i.dataset.bookmark === t) return i;
                if (i.children.length) {
                    const e = E(i, t);
                    if (e) return e
                }
            }
        };
    let A;
    return e.$$set = e => {
        "spellcheck" in e && o(1, a = e.spellcheck), "autocorrect" in e && o(2, s = e.autocorrect), "autocapitalize" in e && o(3, l = e.autocapitalize), "wrapLines" in e && o(4, c = e.wrapLines), "allowNewline" in e && o(5, d = e.allowNewline), "textFormat" in e && o(16, u = e.textFormat), "formatInput" in e && o(17, h = e.formatInput), "formatPaste" in e && o(18, p = e.formatPaste), "styles" in e && o(19, g = e.styles), "innerHTML" in e && o(0, $ = e.innerHTML), "oninput" in e && o(20, f = e.oninput), "enableTextStyleShortcuts" in e && o(21, y = e.enableTextStyleShortcuts)
    }, e.$$.update = () => {
        var t;
        if (64 & e.$$.dirty[0] && o(25, n = !!v), 33554433 & e.$$.dirty[0] && n && $ && (t = $) !== v.innerHTML && (o(6, v.innerHTML = t, v), v === document.activeElement && b()), 524336 & e.$$.dirty[0]) if (!c && d) {
            const e = g.includes(":right") ? "text-indent:-100px!important" : g.includes(":center") ? "" : "min-width:calc(100% + 100px)!important";
            o(7, A = g + ";overflow:visible;" + e)
        } else o(7, A = g);
        524288 & e.$$.dirty[0] && o(8, r = g.includes("text-stroke"))
    }, [$, a, s, l, c, d, v, A, r, () => {
        x("blur")
    }, e => {
        if (/escape/i.test(e.code)) return e.stopPropagation(), void x("cancel");
        const t = e.ctrlKey || e.metaKey;
        if ("html" === u && t && /b|i|u|s/.test(e.key)) return y && (e => {
            const t = C[e];
            t && document.execCommand(t)
        })(e.key), void e.preventDefault();
        /enter/i.test(e.code) && (e.stopPropagation(), e.isComposing || (t ? x("confirm") : (d || e.preventDefault(), document.execCommand("insertLineBreak"), e.preventDefault())))
    }, () => {
    }, e => {
        "" !== e.data && k()
    }, e => {
        const {inputType: t} = e;
        "insertCompositionText" !== t && "deleteCompositionText" !== t && k()
    }, e => {
        e.preventDefault();
        const t = e.clipboardData.getData("text/plain"), o = "html" === u ? t : w(t), i = p(o);
        if (!i.length) return;
        const n = P().getRangeAt(0);
        n.deleteContents(), n.insertNode(document.createTextNode(i)), S()
    }, e => e.replace("-webkit-text-stroke", "--text-stroke").replace("text-shadow", "--text-shadow"), u, h, p, g, f, y, () => k(), () => v && v.focus(), b, n, function (e) {
        ha[e ? "unshift" : "push"]((() => {
            v = e, o(6, v)
        }))
    }]
}

class db extends Ga {
    constructor(e) {
        super(), Ua(this, e, cb, lb, lr, {
            spellcheck: 1,
            autocorrect: 2,
            autocapitalize: 3,
            wrapLines: 4,
            allowNewline: 5,
            textFormat: 16,
            formatInput: 17,
            formatPaste: 18,
            styles: 19,
            innerHTML: 0,
            oninput: 20,
            enableTextStyleShortcuts: 21,
            confirm: 22,
            focus: 23,
            select: 24
        }, null, [-1, -1])
    }

    get spellcheck() {
        return this.$$.ctx[1]
    }

    set spellcheck(e) {
        this.$$set({spellcheck: e}), ka()
    }

    get autocorrect() {
        return this.$$.ctx[2]
    }

    set autocorrect(e) {
        this.$$set({autocorrect: e}), ka()
    }

    get autocapitalize() {
        return this.$$.ctx[3]
    }

    set autocapitalize(e) {
        this.$$set({autocapitalize: e}), ka()
    }

    get wrapLines() {
        return this.$$.ctx[4]
    }

    set wrapLines(e) {
        this.$$set({wrapLines: e}), ka()
    }

    get allowNewline() {
        return this.$$.ctx[5]
    }

    set allowNewline(e) {
        this.$$set({allowNewline: e}), ka()
    }

    get textFormat() {
        return this.$$.ctx[16]
    }

    set textFormat(e) {
        this.$$set({textFormat: e}), ka()
    }

    get formatInput() {
        return this.$$.ctx[17]
    }

    set formatInput(e) {
        this.$$set({formatInput: e}), ka()
    }

    get formatPaste() {
        return this.$$.ctx[18]
    }

    set formatPaste(e) {
        this.$$set({formatPaste: e}), ka()
    }

    get styles() {
        return this.$$.ctx[19]
    }

    set styles(e) {
        this.$$set({styles: e}), ka()
    }

    get innerHTML() {
        return this.$$.ctx[0]
    }

    set innerHTML(e) {
        this.$$set({innerHTML: e}), ka()
    }

    get oninput() {
        return this.$$.ctx[20]
    }

    set oninput(e) {
        this.$$set({oninput: e}), ka()
    }

    get enableTextStyleShortcuts() {
        return this.$$.ctx[21]
    }

    set enableTextStyleShortcuts(e) {
        this.$$set({enableTextStyleShortcuts: e}), ka()
    }

    get confirm() {
        return this.$$.ctx[22]
    }

    get focus() {
        return this.$$.ctx[23]
    }

    get select() {
        return this.$$.ctx[24]
    }
}

const ub = ["i", "b", "u", "strike"].map((e => ({
    tag: e,
    tagOpen: new RegExp(`<${e}>`, "g"),
    tagClose: new RegExp(`</${e}>`, "g"),
    placeholderOpen: new RegExp(`___${e}O___`, "g"),
    placeholderClose: new RegExp(`___${e}C___`, "g")
})));
var hb = e => e = ((e, t = ub) => (t.forEach((({tag: t, placeholderOpen: o, placeholderClose: i}) => {
        e = e.replace(o, `<${t}>`).replace(i, `</${t}>`)
    })), e))(e = (e = ((e, t = ub) => (t.forEach((({tag: t, tagOpen: o, tagClose: i}) => {
        e = e.replace(o, `___${t}O___`).replace(i, `___${t}C___`)
    })), e))(e)).replace(/ {2,}/g, " ").replace(/\u00a0/g, "&nbsp;").split("\n").join("<br>")),
    pb = (e, t) => h(e) ? parseFloat(e) / 100 * t : e, mb = (e, t) => ({x: Uo(e.x, t.width), y: Uo(e.y, t.height)});

function gb(e, t, o) {
    const i = e.slice();
    return i[318] = t[o], i[320] = o, i
}

function $b(e, t) {
    let o, i, n, r, a, s, l, c, d, u, h, p = t[318].name + "";

    function m() {
        return t[198](t[320])
    }

    return n = new Fh({props: {color: t[318].color}}), {
        key: e, first: null, c() {
            o = Fr("li"), i = Fr("button"), Na(n.$$.fragment), r = Br(), a = Fr("span"), s = Dr(p), c = Br(), Nr(i, "class", "PinturaShapeListItem"), Nr(i, "type", "button"), Nr(i, "aria-label", l = "Select shape " + t[318].name), this.first = o
        }, m(e, t) {
            Ar(e, o, t), Rr(o, i), Ha(n, i, null), Rr(i, r), Rr(i, a), Rr(a, s), Rr(o, c), d = !0, u || (h = Wr(i, "click", m), u = !0)
        }, p(e, o) {
            t = e;
            const r = {};
            8388608 & o[0] && (r.color = t[318].color), n.$set(r), (!d || 8388608 & o[0]) && p !== (p = t[318].name + "") && Ur(s, p), (!d || 8388608 & o[0] && l !== (l = "Select shape " + t[318].name)) && Nr(i, "aria-label", l)
        }, i(e) {
            d || (Ea(n.$$.fragment, e), d = !0)
        }, o(e) {
            Aa(n.$$.fragment, e), d = !1
        }, d(e) {
            e && Lr(o), ja(n), u = !1, h()
        }
    }
}

function fb(e) {
    let t, o;
    return t = new ib({
        props: {
            visible: !0,
            points: e[14],
            bounds: e[4],
            rotatorPoint: e[31],
            scalarPoint: e[30],
            selectedPoint: e[19],
            enableDragEdges: e[20],
            enableDragPoints: e[33],
            enableRotatePoints: e[18],
            enableScalePoints: e[16]
        }
    }), t.$on("resizestart", e[42]), t.$on("resizemove", e[43]), t.$on("resizeend", e[44]), t.$on("rotatestart", e[45]), t.$on("rotatemove", e[46]), t.$on("rotateend", e[47]), t.$on("scalestart", e[48]), t.$on("scalemove", e[49]), t.$on("scaleend", e[50]), {
        c() {
            Na(t.$$.fragment)
        }, m(e, i) {
            Ha(t, e, i), o = !0
        }, p(e, o) {
            const i = {};
            16384 & o[0] && (i.points = e[14]), 16 & o[0] && (i.bounds = e[4]), 1 & o[1] && (i.rotatorPoint = e[31]), 1073741824 & o[0] && (i.scalarPoint = e[30]), 524288 & o[0] && (i.selectedPoint = e[19]), 1048576 & o[0] && (i.enableDragEdges = e[20]), 4 & o[1] && (i.enableDragPoints = e[33]), 262144 & o[0] && (i.enableRotatePoints = e[18]), 65536 & o[0] && (i.enableScalePoints = e[16]), t.$set(i)
        }, i(e) {
            o || (Ea(t.$$.fragment, e), o = !0)
        }, o(e) {
            Aa(t.$$.fragment, e), o = !1
        }, d(e) {
            ja(t, e)
        }
    }
}

function yb(e) {
    let t, o, i, n;
    const r = [xb, bb], a = [];

    function s(e, t) {
        return "modal" === e[5] ? 0 : "inline" === e[5] ? 1 : -1
    }

    return ~(t = s(e)) && (o = a[t] = r[t](e)), {
        c() {
            o && o.c(), i = Or()
        }, m(e, o) {
            ~t && a[t].m(e, o), Ar(e, i, o), n = !0
        }, p(e, n) {
            let l = t;
            t = s(e), t === l ? ~t && a[t].p(e, n) : (o && (Ra(), Aa(a[l], 1, 1, (() => {
                a[l] = null
            })), Ia()), ~t ? (o = a[t], o ? o.p(e, n) : (o = a[t] = r[t](e), o.c()), Ea(o, 1), o.m(i.parentNode, i)) : o = null)
        }, i(e) {
            n || (Ea(o), n = !0)
        }, o(e) {
            Aa(o), n = !1
        }, d(e) {
            ~t && a[t].d(e), e && Lr(i)
        }
    }
}

function bb(e) {
    let t, o, i, n, r, a, s = {
        formatInput: e[52],
        wrapLines: !!e[15].width,
        textFormat: e[15].format,
        enableTextStyleShortcuts: e[6],
        allowNewline: e[32],
        styles: e[29]
    };
    return o = new db({props: s}), e[202](o), o.$on("input", e[53]), o.$on("keyup", e[57]), o.$on("cancel", e[59]), o.$on("confirm", e[58]), {
        c() {
            t = Fr("div"), Na(o.$$.fragment), Nr(t, "class", "PinturaInlineInput")
        }, m(s, l) {
            Ar(s, t, l), Ha(o, t, null), n = !0, r || (a = [wr(i = od.call(null, t, e[28])), Wr(t, "focusout", e[203])], r = !0)
        }, p(e, t) {
            const n = {};
            32768 & t[0] && (n.wrapLines = !!e[15].width), 32768 & t[0] && (n.textFormat = e[15].format), 64 & t[0] && (n.enableTextStyleShortcuts = e[6]), 2 & t[1] && (n.allowNewline = e[32]), 536870912 & t[0] && (n.styles = e[29]), o.$set(n), i && sr(i.update) && 268435456 & t[0] && i.update.call(null, e[28])
        }, i(e) {
            n || (Ea(o.$$.fragment, e), n = !0)
        }, o(e) {
            Aa(o.$$.fragment, e), n = !1
        }, d(i) {
            i && Lr(t), e[202](null), ja(o), r = !1, ar(a)
        }
    }
}

function xb(e) {
    let t, o;
    return t = new jp({
        props: {
            panelOffset: e[2],
            onconfirm: e[58],
            oncancel: e[59],
            buttonCancel: {icon: e[7].shapeIconInputCancel, label: e[7].shapeLabelInputCancel},
            buttonConfirm: {icon: e[7].shapeIconInputConfirm, label: e[7].shapeLabelInputConfirm, hideLabel: !0},
            willHandleKeydown: e[201],
            $$slots: {default: [vb]},
            $$scope: {ctx: e}
        }
    }), {
        c() {
            Na(t.$$.fragment)
        }, m(e, i) {
            Ha(t, e, i), o = !0
        }, p(e, o) {
            const i = {};
            4 & o[0] && (i.panelOffset = e[2]), 128 & o[0] && (i.buttonCancel = {
                icon: e[7].shapeIconInputCancel,
                label: e[7].shapeLabelInputCancel
            }), 128 & o[0] && (i.buttonConfirm = {
                icon: e[7].shapeIconInputConfirm,
                label: e[7].shapeLabelInputConfirm,
                hideLabel: !0
            }), 4096 & o[0] && (i.willHandleKeydown = e[201]), 671088896 & o[0] | 2048 & o[10] && (i.$$scope = {
                dirty: o,
                ctx: e
            }), t.$set(i)
        }, i(e) {
            o || (Ea(t.$$.fragment, e), o = !0)
        }, o(e) {
            Aa(t.$$.fragment, e), o = !1
        }, d(e) {
            ja(t, e)
        }
    }
}

function vb(e) {
    let t, o, i, n;
    return {
        c() {
            t = Fr("textarea"), Nr(t, "spellcheck", "false"), Nr(t, "autocorrect", "off"), Nr(t, "autocapitalize", "off")
        }, m(r, a) {
            Ar(r, t, a), e[199](t), Gr(t, e[27]), i || (n = [Wr(t, "keydown", e[55]), Wr(t, "keypress", e[54]), Wr(t, "keyup", e[57]), Wr(t, "input", e[53]), Wr(t, "input", e[200]), wr(o = od.call(null, t, e[29]))], i = !0)
        }, p(e, i) {
            134217728 & i[0] && Gr(t, e[27]), o && sr(o.update) && 536870912 & i[0] && o.update.call(null, e[29])
        }, d(o) {
            o && Lr(t), e[199](null), i = !1, ar(n)
        }
    }
}

function wb(e) {
    let t, o, i, n, r;
    return o = new pp({props: {items: e[24], key: e[11]}}), {
        c() {
            t = Fr("div"), Na(o.$$.fragment), Nr(t, "class", "PinturaShapeControls"), Zr(t, "transform", e[26]), Zr(t, "opacity", e[25])
        }, m(a, s) {
            Ar(a, t, s), Ha(o, t, null), i = !0, n || (r = [Wr(t, "measure", e[204]), wr(zc.call(null, t))], n = !0)
        }, p(e, i) {
            const n = {};
            16777216 & i[0] && (n.items = e[24]), 2048 & i[0] && (n.key = e[11]), o.$set(n), 67108864 & i[0] && Zr(t, "transform", e[26]), 33554432 & i[0] && Zr(t, "opacity", e[25])
        }, i(e) {
            i || (Ea(o.$$.fragment, e), i = !0)
        }, o(e) {
            Aa(o.$$.fragment, e), i = !1
        }, d(e) {
            e && Lr(t), ja(o), n = !1, ar(r)
        }
    }
}

function Sb(e) {
    let t, o, n, r, a, s, l, c, d, u, h = [], p = new Map, m = e[23];
    const g = e => e[318].id;
    for (let t = 0; t < m.length; t += 1) {
        let o = gb(e, m, t), i = g(o);
        p.set(i, h[t] = $b(i, o))
    }
    let $ = e[17] && fb(e), f = e[13] && yb(e), y = e[21] > 0 && wb(e);
    return {
        c() {
            t = Fr("div"), o = Fr("nav"), n = Fr("ul");
            for (let e = 0; e < h.length; e += 1) h[e].c();
            r = Br(), $ && $.c(), a = Br(), f && f.c(), s = Br(), y && y.c(), Nr(o, "class", "PinturaShapeList"), Nr(o, "data-visible", e[22]), Nr(t, "class", "PinturaShapeEditor"), Nr(t, "tabindex", "0")
        }, m(p, m) {
            Ar(p, t, m), Rr(t, o), Rr(o, n);
            for (let e = 0; e < h.length; e += 1) h[e].m(n, null);
            Rr(t, r), $ && $.m(t, null), Rr(t, a), f && f.m(t, null), Rr(t, s), y && y.m(t, null), e[205](t), c = !0, d || (u = [Wr(o, "focusin", e[62]), Wr(o, "focusout", e[63]), Wr(t, "keydown", (function () {
                sr(e[0] ? i : e[51]) && (e[0] ? i : e[51]).apply(this, arguments)
            })), Wr(t, "nudge", (function () {
                sr(e[0] ? i : e[61]) && (e[0] ? i : e[61]).apply(this, arguments)
            })), Wr(t, "measure", e[197]), Wr(t, "pointermove", (function () {
                sr(e[0] ? i : e[64]) && (e[0] ? i : e[64]).apply(this, arguments)
            })), Wr(t, "pointerleave", (function () {
                sr(e[0] ? i : e[65]) && (e[0] ? i : e[65]).apply(this, arguments)
            })), Wr(t, "interactionstart", (function () {
                sr(e[0] ? i : e[36]) && (e[0] ? i : e[36]).apply(this, arguments)
            })), Wr(t, "interactionupdate", (function () {
                sr(e[0] ? i : e[38]) && (e[0] ? i : e[38]).apply(this, arguments)
            })), Wr(t, "interactioncancel", (function () {
                sr(e[0] ? i : e[37]) && (e[0] ? i : e[37]).apply(this, arguments)
            })), Wr(t, "interactionrelease", (function () {
                sr(e[0] ? i : e[39]) && (e[0] ? i : e[39]).apply(this, arguments)
            })), Wr(t, "interactionend", (function () {
                sr(e[0] ? i : e[40]) && (e[0] ? i : e[40]).apply(this, arguments)
            })), wr(zc.call(null, t)), wr(rh.call(null, t)), wr(l = Sp.call(null, t, {
                drag: !0,
                inertia: !0,
                multiTouch: !1,
                observeKeys: !0,
                shouldStartInteraction: kb,
                getEventPosition: e[206]
            }))], d = !0)
        }, p(i, r) {
            e = i, 8388608 & r[0] | 16 & r[2] && (m = e[23], Ra(), h = Oa(h, r, g, 1, e, m, p, n, Ba, $b, null, gb), Ia()), (!c || 4194304 & r[0]) && Nr(o, "data-visible", e[22]), e[17] ? $ ? ($.p(e, r), 131072 & r[0] && Ea($, 1)) : ($ = fb(e), $.c(), Ea($, 1), $.m(t, a)) : $ && (Ra(), Aa($, 1, 1, (() => {
                $ = null
            })), Ia()), e[13] ? f ? (f.p(e, r), 8192 & r[0] && Ea(f, 1)) : (f = yb(e), f.c(), Ea(f, 1), f.m(t, s)) : f && (Ra(), Aa(f, 1, 1, (() => {
                f = null
            })), Ia()), e[21] > 0 ? y ? (y.p(e, r), 2097152 & r[0] && Ea(y, 1)) : (y = wb(e), y.c(), Ea(y, 1), y.m(t, null)) : y && (Ra(), Aa(y, 1, 1, (() => {
                y = null
            })), Ia()), l && sr(l.update) && 8 & r[0] && l.update.call(null, {
                drag: !0,
                inertia: !0,
                multiTouch: !1,
                observeKeys: !0,
                shouldStartInteraction: kb,
                getEventPosition: e[206]
            })
        }, i(e) {
            if (!c) {
                for (let e = 0; e < m.length; e += 1) Ea(h[e]);
                Ea($), Ea(f), Ea(y), c = !0
            }
        }, o(e) {
            for (let e = 0; e < h.length; e += 1) Aa(h[e]);
            Aa($), Aa(f), Aa(y), c = !1
        }, d(o) {
            o && Lr(t);
            for (let e = 0; e < h.length; e += 1) h[e].d();
            $ && $.d(), f && f.d(), y && y.d(), e[205](null), d = !1, ar(u)
        }
    }
}

const kb = (e, t) => e.target === t || "PinturaContentEditable" === e.target.className;

function Cb(e, t, o) {
    let n, r, a, s, l, c, d, u, p, m, g, $, f, y, b, x, v, w, S, k, C, T, M, P, R, I, A, L, F, D, B, O, W, V, _, N, H,
        j, U, G, X, Y, q, K, J, Q, ee, te, oe, ie, ne, re, ae, se, ce, pe, ge, fe, ke, Te, Me, Ie, Fe, ze, Be, Oe,
        We = tr, _e = () => (We(), We = ur(Ue, (e => o(193, Ie = e))), Ue);
    e.$$.on_destroy.push((() => We()));
    let {uid: Ne = E()} = t, {ui: He} = t, {disabled: je = !1} = t, {shapes: Ue} = t;
    _e();
    let {selection: Xe} = t, {offset: qe} = t, {contextRotation: Ke = 0} = t, {contextFlipX: Je = !1} = t, {contextFlipY: Qe = !1} = t, {contextZoom: et = 1} = t, {active: tt = !1} = t, {opacity: rt = 1} = t, {parentRect: lt} = t, {rootRect: ct} = t, {utilRect: dt} = t, {hoverColor: ut} = t, {caretColor: ht} = t, {gridColor: pt} = t, {snapColor: mt} = t, {textInputMode: gt = "inline"} = t, {oninteractionstart: $t = i} = t, {oninteractionupdate: yt = i} = t, {oninteractionrelease: bt = i} = t, {oninteractionend: xt = i} = t, {oninteractioncancel: kt = i} = t, {onaddshape: Ct = i} = t, {onupdateshape: Tt = i} = t, {onselectshape: Mt = i} = t, {onblurshape: Pt = i} = t, {onremoveshape: Rt = i} = t, {ontapshape: At = i} = t, {onhovershape: Ft = i} = t, {ontriggerhistorywrite: zt = i} = t, {onhovercanvas: _t = i} = t, {ontapcanvas: Nt = i} = t, {onleavecanvas: Ht = i} = t, {beforeSelectShape: jt = (() => !0)} = t, {beforeDeselectShape: Ut = (() => !0)} = t, {beforeRemoveShape: Gt = (() => !0)} = t, {beforeUpdateShape: Zt = ((e, t, o) => t)} = t, {willRenderShapeControls: Xt = Z} = t, {willRenderShapeTextControls: Yt = Z} = t, {willStartInteraction: qt = ((e, t) => !0)} = t, {mapEditorPointToImagePoint: Kt} = t, {mapImagePointToEditorPoint: Jt} = t, {eraseRadius: Qt} = t, {selectRadius: eo} = t, {enableButtonFlipVertical: to = !1} = t, {enableTapToAddText: oo = !0} = t, {enableMultiSelect: io = !1} = t, {enableTextStyleControls: no = !0} = t, {locale: ro} = t, {snapThreshold: ao = 0} = t, {snapPointer: so = !0} = t, {enableSnapToContext: lo = !0} = t, {gridSize: co = 0} = t;
    const uo = e => {
        if (0 === ao) return [];
        let t;
        return lo && (t = {
            ...lt,
            x: 0,
            y: 0
        }), [...Ie.filter((t => t !== e)).filter((e => !Di(e))).filter((e => (e => !0 !== e.disableAcceptSnap)(e))).map((e => xn({...e}, lt))), t].filter(Boolean)
    }, ho = (e, t, o, i) => 0 === e ? {snapTargets: []} : {
        snapThreshold: e,
        gridSize: t,
        gridRect: o,
        snapTargets: uo(i)
    }, po = ca("isAnimated");
    pr(e, po, (e => o(194, ze = e)));
    const mo = ca("softKeyboardState"), go = e => e.set(hr(e)), $o = e => hr(e).find(Di), fo = (e, t) => {
        if (!$o(t)) return _i(e), vo(e, t)
    }, yo = e => {
        $o(e) && e.update((e => e.filter((e => !Di(e)))))
    }, bo = e => {
        const t = $o(e);
        if (t) return Ni(t), go(e), t
    }, xo = (e, t, o = ((e, t) => ({...e, ...t}))) => {
        $o(t) && t.update((t => t.map((t => Di(t) ? o(t, e) : t))))
    }, vo = (e, t = Ue) => (t.update((t => [...t, e])), e), wo = (e, t, o) => {
        const i = Zt({...e}, t, {...o});
        return kn(e, i, o), e
    }, So = (e, t) => {
        const o = Re(e, t), i = be(e, t), n = Math.PI / 8, r = n * Math.round(i / n) - Ke % n;
        t.x = e.x + o * Math.cos(r), t.y = e.y + o * Math.sin(r)
    }, ko = ca("keysPressed");
    pr(e, ko, (e => o(195, Be = e)));
    const Co = (e, t, o) => 0 === e || t && o ? e : t || o ? -e : e, To = e => {
        if (null === e.x && null === e.y) return Mo();
        e.x && o(149, Po = Kt({x: e.x, y: 0}).x), e.y && o(150, Ro = Kt({x: 0, y: e.y}).y)
    }, Mo = () => {
        o(149, Po = null), o(150, Ro = null)
    };
    let Po = null, Ro = null;
    const Io = (e, t) => {
        const o = Jt(e);
        return Kt(we(o, t))
    }, Eo = (e, t, o) => {
        const i = (o - t) / e + 1;
        return Array.from({length: i}, ((o, i) => t + i * e))
    }, Ao = e => {
        let t = [], o = [], i = e.points;
        if (void 0 !== e.x1 && (i = [{x: e.x1, y: e.y1}, {x: e.x2, y: e.y2}]), i) {
            const e = i.map(Jt), n = it(e), r = e[0], a = e[e.length - 1];
            t = [n.x, n.x + .5 * n.width, n.x + n.width, r.x, a.x], o = [n.y, n.y + .5 * n.height, n.y + n.height, r.y, a.y]
        } else if (e.text || void 0 !== e.width || void 0 !== e.rx) {
            let i;
            if (e.text && void 0 === e.height) {
                const t = ai(e.text, e);
                i = at(e.x, e.y, t.width, t.height)
            } else i = void 0 !== e.width ? ot(e) : ot({
                x: e.x - e.rx,
                y: e.y - e.ry,
                width: 2 * e.rx,
                height: 2 * e.ry
            });
            const n = St(i).map(Jt), r = Math.abs(e.rotation) > 0 ? ft(i, e.rotation).map(Jt) : n, a = it(r), s = st(a),
                l = .5 * a.width, c = .5 * a.height;
            t = [s.x - l, s.x, s.x + l], o = [s.y - c, s.y, s.y + c]
        } else if (void 0 !== e.x) {
            const i = Jt(e);
            t = [i.x], o = [i.y]
        }
        return {x: t, y: o}
    }, Lo = (e, t, o) => {
        let i, n, r, a = Number.Infinity, s = null, l = null;
        for (let c = 0; c < e.length; c++) {
            n = e[c];
            for (let e = 0; e < t.length; e++) r = t[e], i = Math.abs(n - r), i < o && (null === l || i < a) && (a = i, s = n, l = r)
        }
        return {origin: s, target: l}
    }, Fo = (e, t, o, i, n) => {
        const r = {x: null, y: null}, a = {x: null, y: null}, s = t.map(Ao);
        if (i > 0) {
            const e = Jt({x: 0, y: 0}), t = Jt({x: i, y: i}), o = Jt({x: n.width, y: n.height}), r = t.x - e.x,
                a = Eo(r, e.x, o.x), l = Eo(r, e.y, o.y);
            s.push({x: a, y: l})
        }
        return s.forEach((t => {
            const {snapTranslation: i, snapLine: n} = ((e, t, o) => {
                const i = {x: null, y: null}, n = {x: null, y: null}, r = Lo(e.x, t.x, o);
                null !== r.target && (i.x = r.target, n.x = r.target - r.origin);
                const a = Lo(e.y, t.y, o);
                return null !== a.target && (i.y = a.target, n.y = a.target - a.origin), {
                    snapTranslation: n,
                    snapLine: i
                }
            })(e, t, o);
            null !== i.x && (null === a.x || Math.abs(i.x) < Math.abs(a.x)) && (a.x = i.x || 0, r.x = n.x), null !== i.y && (null === a.y || Math.abs(i.y) < Math.abs(a.y)) && (a.y = i.y || 0, r.y = n.y)
        })), {snapTranslation: a, snapLines: r}
    }, Do = (e, t) => (null !== t.x && (e.x += t.x), null !== t.y && (e.y += t.y), e), Oo = (e, t, o, i) => {
        const {snapThreshold: n = 0, gridSize: r = 0, gridRect: a, snapTargets: s = []} = i || {};
        let l = null;
        if (Ii(e)) {
            if (n) {
                const i = xn({...e}, lt), l = Io(Si(t), o), c = Io(ki(t), o),
                    d = Ao({...i, x1: l.x, y1: l.y, x2: c.x, y2: c.y}), {
                        snapTranslation: u,
                        snapLines: h
                    } = Fo(d, s, n, r, a);
                Do(o, u), To(h)
            }
            const i = Io(Si(t), o), c = Io(ki(t), o);
            l = {x1: i.x, y1: i.y, x2: c.x, y2: c.y}
        } else if (e.points) {
            if (qi(Li) && Jo(Li, {selectedPoint: void 0}), n) {
                const i = xn({...e}, lt), l = Ao({...i, points: t.points.map((e => Io(e, o)))}), {
                    snapTranslation: c,
                    snapLines: d
                } = Fo(l, s, n, r, a);
                Do(o, c), To(d)
            }
            l = {points: t.points.map((e => Io(e, o)))}
        } else if (Pi(e) || Ci(e) || Ri(e)) {
            if (n) {
                const i = xn({...e}, lt), l = Io(t, o), c = Ao({...i, ...l}), {
                    snapTranslation: d,
                    snapLines: u
                } = Fo(c, s, n, r, a);
                Do(o, d), To(u)
            }
            l = Io(t, o)
        }
        l && (wo(e, l, lt), qo())
    }, Wo = {0: 1, 1: 0, 2: 3, 3: 2}, Vo = {0: 3, 1: 2, 2: 1, 3: 0}, _o = (e, t, o, n, r) => {
        const {
            shiftKey: a,
            snapThreshold: s = 0,
            gridSize: l = 0,
            gridRect: c,
            snapTargets: d = [],
            aspectRatio: u,
            beforeResizeShape: h = i
        } = r || {}, p = s ? (e, t, o) => {
            const {snapTranslation: i, snapLines: n} = Fo(Ao(e), d, s, l, c);
            Do(t, i), To(n);
            const r = Io(o(), t);
            e.x = r.x, e.y = r.y
        } : i;
        if (Ii(e) || Ei(e) && Bo(e, "pathClose")) {
            const [i] = o, r = a ? So : (e, t) => t;
            let s, l, c;
            if (Ii(e)) 0 === i ? (s = () => Si(t), l = e => r(ki(t), e), c = (e, t) => {
                e.x1 = t.x, e.y1 = t.y
            }) : 1 === i && (s = () => ki(t), l = e => r(Si(t), e), c = (e, t) => {
                e.x2 = t.x, e.y2 = t.y
            }); else {
                const e = t.points;
                s = () => ({...e[i]}), l = t => {
                    const o = e[Yy(i - 1, e)], n = e[Yy(i + 1, e)];
                    r(o, t), r(n, t)
                }, c = (e, t) => e.points = e.points.map(((e, o) => i === o ? t : e))
            }
            const d = Io(s(), n);
            p(d, n, s), l(d), c(e, d)
        } else if (Bi(e) || Ri(e) || Ci(e)) {
            let i, a = !1, s = !1;
            if (Ri(t)) i = nt(t); else if (Bi(t)) i = ot(t); else if (Bo(t, "width")) {
                a = !0, i = ot(t);
                const e = ai(t.text, t);
                i.height = e.height
            } else {
                s = !0, i = ot(t);
                const e = ai(t.text, t);
                i.width = e.width, i.height = e.height
            }
            let l = u;
            e.aspectRatio ? l = e.aspectRatio : !r.shiftKey || a || s || (l = i.width / i.height);
            const c = ot(i), d = st(c), m = e.rotation, g = St(c), $ = ft(c, m);
            if (1 === o.length) {
                let t = o[0];
                e.flipX && (t = Wo[t]), e.flipY && (t = Vo[t]);
                const [i, r, a, s] = g, c = Jt($[t]), u = we({...c}, n), f = Kt(u);
                p(f, n, (() => Kt(c)));
                const y = he(f.x - $[t].x, f.y - $[t].y), b = $e(me(y), -m), x = he(g[t].x + b.x, g[t].y + b.y);
                let v;
                0 === t && (v = a), 1 === t && (v = s), 2 === t && (v = i), 3 === t && (v = r);
                const w = it([v, x]);
                if (l) {
                    const {width: e, height: t} = vt(w, l), [o, i, n, r] = wt(w);
                    w.width = e, w.height = t, x.y < v.y && (w.y = n - t), x.x < v.x && (w.x = i - e)
                }
                const S = ft(w, m, d), k = Ee(S), C = $e(S[0], -m, k), T = $e(S[2], -m, k), M = it([C, T]);
                h(M), wo(e, Ri(e) ? de(M) : M, lt)
            } else {
                o = o.map((t => (e.flipX && (t = Wo[t]), e.flipY && (t = Vo[t]), t)));
                const [t, i] = o.map((e => $[e])), r = {
                        x: t.x + .5 * (i.x - t.x),
                        y: t.y + .5 * (i.y - t.y)
                    }, [s, c] = o.map((e => g[e])), [u, h] = o.map((e => {
                        const t = e + 2;
                        return t < 4 ? g[t] : g[t - 4]
                    })), f = {x: u.x + .5 * (h.x - u.x), y: u.y + .5 * (h.y - u.y)}, y = Jt(r), b = we({...y}, n),
                    x = Kt(b);
                p(x, n, (() => Kt(y)));
                const v = he(x.x - r.x, x.y - r.y), w = $e(me(v), -m), S = Se(me(s), c),
                    k = ve(S, (e => 1 - Math.abs(Math.sign(e)))), C = he(w.x * k.x, w.y * k.y);
                we(s, C), we(c, C);
                const T = it(g);
                if (l) {
                    let e = T.width, t = T.height;
                    0 === k.y ? t = e / l : e = t * l, T.width = e, T.height = t, 0 === k.y ? T.y = f.y - .5 * t : T.x = f.x - .5 * e
                }
                const M = ft(T, m, d), P = Ee(M), R = $e(M[0], -m, P), I = $e(M[2], -m, P), E = it([R, I]);
                let A;
                Ri(e) ? A = de(E) : Bi(e) ? A = E : a && (A = {x: E.x, y: E.y, width: E.width}), wo(e, A, lt)
            }
        }
        qo()
    };
    let No;
    const Ho = (e, t) => {
            const o = e.points.filter(((e, o) => o !== t));
            Jo(e, {points: o, selectedPoint: void 0})
        }, jo = () => {
            if (Ie.length) return Ie.find(Di)
        }, Zo = () => {
            if (Ie.length) return Ie.findIndex(Di)
        }, Xo = () => {
            const e = jo();
            if (e) return Ni(e), qo(), e
        }, Yo = () => {
            if (!jo()) return;
            const e = [...Ie];
            e.splice(Zo(), 1), Ue.set(e)
        }, qo = () => {
            Ue.set(Ie)
        }, Ko = (e, t = [], o = !0) => {
            t.filter(Boolean).forEach((t => delete e[t])), o && qo()
        }, Jo = (e, t, o = !0) => {
            e = Object.assign(e, t), o && qo()
        }, Qo = (e, t, o, i = !0) => {
            e[t] = o, i && qo()
        }, ei = (e, t = !0) => {
            Ie.forEach((t => Jo(t, e, !1))), t && qo()
        }, ti = () => [...Ie].reverse().filter(Fi), oi = () => [...Ie].reverse().find(Fi), ii = () => !!oi(),
        ni = (e, t = !0, o = !1) => {
            const i = Ie.filter((e => Ui(e) && ji(e))), n = i.findIndex((t => t === e));
            if (!1 === ((e, t = !1) => {
                if (!Gt(e)) return !1;
                Ue.set(Ie.filter((t => t !== e))), t || Rt(e)
            })(e, o)) return;
            if (si = e, i.length - 1 <= 0) return li();
            if (!t) return !0;
            const r = n - 1 < 0 ? i.length - 1 : n - 1;
            return di(i[r]), !0
        }, ri = () => {
            if (s) {
                const e = [];
                return a.forEach(((t, o) => {
                    if (!Ui(t)) return;
                    ni(t, o === a.length - 1, !0) && e.push(t)
                })), void (e.length && zt())
            }
            const e = oi();
            e && ni(e)
        };
    let si = void 0;
    const li = (e = {}) => {
            const {storePrevious: t = !0} = e;
            Object.keys(Un).forEach((e => Un[e] = {}));
            const o = ci();
            t && (si = o), ei({isSelected: !1, isEditing: !1, _prerender: !1}), o && Pt(o)
        }, ci = () => Ie.find(Fi), di = (e, t = !0, o = !1) => {
            if (Di(e)) return;
            const i = ci() || si, n = Fi(e);
            si = void 0, jt(i, e) && (o || li(), (e => {
                e.isSelected = !0
            })(e), !n && Mt(e), t && qo())
        }, ui = e => {
            Dn && Dn.confirm && e.isEditing && Dn.confirm();
            const t = {isSelected: !1, isEditing: !1, _prerender: !1};
            e.selectedPoint > -1 && (t.selectedPoint = void 0), Jo(e, t), Pt(e)
        }, hi = e => {
            Jo(e, {isSelected: !0, isEditing: !0, _prerender: "inline" === gt})
        }, pi = e => {
            Jo(e, {isSelected: !0, isEditing: !1, _prerender: !1})
        }, mi = e => {
            if (!e.length) return [];
            const t = e.filter(Gt);
            return Ue.set(Ie.filter((e => !t.includes(e)))), t
        }, gi = e => {
            const t = ai(e.text, e);
            return at(e.x, e.y, e.width ? Math.min(e.width, t.width) : t.width, e.height ? Math.min(e.height, t.height) : t.height)
        }, $i = e => {
            if (Bi(e)) return ot(e);
            if (Ri(e)) return nt(e);
            const t = gi(e);
            return t.width = Math.max(10, e.width || t.width), t
        }, fi = (e, t, o = 0, i = (() => !0)) => [...e].reverse().filter(i).map((e => ({
            shape: e,
            priority: 1
        }))).filter((e => {
            const {shape: i} = e, n = xn(yi(i), lt), r = o + .5 * (n.strokeWidth || 0);
            if (Pi(n)) return Vt(t, r, n, i.rotation);
            if (Ci(n)) {
                const o = $i(n), a = Vt(t, r, o, i.rotation);
                let s = !1;
                if (a && !Fi(i)) {
                    const a = gi(n);
                    "right" !== i.textAlign || i.flipX || (a.x = o.x + o.width - a.width), "center" === i.textAlign && (a.x = o.x + .5 * o.width - .5 * a.width), s = Vt(t, r, a, i.rotation, st(o)), s || (e.priority = -1)
                }
                return a
            }
            return Ri(n) ? ((e, t, o, i, n, r) => {
                const a = Dt(he(o.x, o.y), o.rx, o.ry, i, n, r, 12);
                return Wt(e, t, a)
            })(t, r, n, i.rotation, i.flipX, i.flipY) : Ii(n) ? Bt(t, Math.max(16, r), Si(n), ki(n)) : Ei(n) && n.pathClose ? Wt(t, r, n.points) : !!Ei(n) && (1 === n.points.length ? Pe(t, n.points[0]) < r * r : Ot(t, Math.max(16, r), n.points))
        })).sort(((e, t) => e.priority < t.priority ? 1 : e.priority > t.priority ? -1 : 0)).map((e => e.shape)),
        bi = (e, t, o, i = 0) => {
            const n = Math.abs(i), r = Ze(t, o), a = Ye(r, n), s = (({start: e, end: t}, o) => {
                if (0 === o) return [he(e.x, e.y), he(e.x, e.y), he(t.x, t.y), he(t.x, t.y)];
                const i = Math.atan2(t.y - e.y, t.x - e.x), n = Math.sin(i) * o, r = Math.cos(i) * o;
                return [he(n + e.x, -r + e.y), he(-n + e.x, r + e.y), he(-n + t.x, r + t.y), he(n + t.x, -r + t.y)]
            })(a, n);
            return e.filter((e => {
                const t = xn(yi(e), lt);
                if (Ii(t) || Ei(t)) {
                    const e = t.points ? [...t.points] : [Si(t), ki(t)];
                    return !!It(a, e)
                }
                return ((e, t) => !!e.find((e => Et(e, t))) || !!t.find((t => Et(t, e))))(s, ((e, t = 12) => {
                    if (Pi(e)) return ft(e, e.rotation, st(e));
                    if (Ci(e)) {
                        const t = $i(e);
                        return ft(t, e.rotation, st(t))
                    }
                    return Ri(e) ? Dt(he(e.x, e.y), e.rx, e.ry, e.rotation, e.flipX, e.flipY, t) : []
                })(t))
            }))
        };
    let xi = void 0, vi = void 0, wi = void 0, Li = void 0, zi = void 0, Oi = void 0, Wi = !1, Vi = !1, en = !1,
        tn = !1, on = void 0;
    const nn = e => {
        on = e.map((e => ({shape: e, shapeOrigin: yi(e), shapeOriginComputed: xn(yi(e), lt)})))
    }, rn = () => {
        clearTimeout(vi), vi = void 0, o(152, tn = !1), Mo()
    };
    let an = null;
    const sn = e => {
        const t = zo(e.rotation) && 0 !== e.rotation;
        if (Pi(e)) {
            if (e.width < 1 && e.height < 1) return;
            const o = st(e), i = St(e);
            return (e.flipX || e.flipY) && Ae(i, e.flipX, e.flipY, o.x, o.y), t ? Le(i, e.rotation, o.x, o.y) : i
        }
        if (Ri(e)) {
            if (e.rx < 1 && e.ry < 1) return;
            const o = e, i = St(nt(e));
            return (e.flipX || e.flipY) && Ae(i, e.flipX, e.flipY, o.x, o.y), t ? Le(i, e.rotation, o.x, o.y) : i
        }
        if (Ii(e)) return [Si(e), ki(e)];
        if (Ei(e)) {
            if (e.bitmap && !e.pathClose) {
                const t = it(e.points);
                t.x -= .5 * e.strokeWidth, t.y -= .5 * e.strokeWidth, t.width += e.strokeWidth, t.height += e.strokeWidth;
                return sn({...e, ...t})
            }
            return [...e.points]
        }
        if (Ci(e)) {
            if (e.width < 5 && e.height < 5) return;
            const o = $i(e);
            o.width = Math.max(10, o.width);
            const i = st(o), n = St(o);
            return (e.flipX || e.flipY) && Ae(n, e.flipX, e.flipY, i.x, i.y), t ? Le(n, e.rotation, i.x, i.y) : n
        }
        return []
    }, ln = e => {
        const t = sn(e);
        let o, i;
        return e.flipY ? (o = Ee([t[0], t[1]]), i = ye(he(t[1].x - t[2].x, t[1].y - t[2].y))) : (o = Ee([t[2], t[3]]), i = ye(he(t[2].x - t[1].x, t[2].y - t[1].y))), Ce(i, 20 / et), {
            origin: o,
            dir: i
        }
    };
    const cn = e => t => t.id === e, dn = e => {
        const t = cn(e);
        return e => e.filter((e => t => !e(t))(t))
    }, un = e => {
        const t = cn(e), o = dn(e);
        return () => He.update((e => e.some(t) ? o(e) : e))
    }, pn = e => {
        const t = dn(e);
        return (...e) => {
            He.update((o => [...t(o), ...e.filter(Boolean)]))
        }
    }, mn = un("markup-hover"), gn = pn("markup-hover");
    let $n;
    const fn = "markup-manipulator-segment-" + Ne, yn = un(fn), bn = pn(fn), vn = (e, t) => {
        const o = e[t], i = t - 1 < 0 ? e[e.length - 1] : e[t - 1], n = t + 1 < e.length ? e[t + 1] : e[0],
            r = Se(me(i), o);
        ye(r);
        const a = we(Ce(r, 10), o), s = Se(me(n), o);
        ye(s);
        return [a, o, we(Ce(s, 10), o)]
    }, wn = () => {
        o(153, $n = void 0), mn()
    }, Cn = "markup-multi-selection-segment-" + Ne, Tn = un(Cn), Mn = pn(Cn), Pn = (e, t) => {
        if (ao <= 0) return e;
        if (t) return Mo(), e;
        const o = Kt(e), i = uo(), {snapTranslation: r, snapLines: a} = Fo(Ao(o), i, ao, co, n);
        return To(a), Do(e, r), e
    }, Rn = bc(0);
    pr(e, Rn, (e => o(196, Oe = e)));
    const In = "markup-grid-line-" + Ne, En = un(In), An = pn(In), Ln = "markup-snap-line", Fn = un(Ln), zn = pn(Ln);
    let Dn;
    mo.subscribe((e => {
        "inline" === gt && r && r.isEditing && "hidden" === e && _n()
    }));
    const Bn = e => {
            o(8, Dn.innerHTML = hb(e), Dn)
        }, On = e => {
            const t = void 0 === e.value ? e.innerHTML : e.value,
                o = "text" === r.format ? ab(t).split(/<br>|<br\/>/g).join("\n").replace(/&nbsp;/g, String.fromCharCode(160)).replace(/&amp;/g, "&") : t;
            return Ti(r) && !1 !== r.disableNewline ? (e => {
                const t = e.split(/[\n\r]/g);
                return t.length > 1 ? t.map((e => e.trim())).filter((e => e.length)).join(" ") : t[0]
            })(o) : o
        }, Wn = () => {
            const e = On(Dn), t = Xi(r, e), o = !0 === t ? e : t;
            let i = H.x, n = H.y;
            if (!r.height) {
                const e = ft({...U}, r.rotation), t = ai(o, p),
                    a = ft({x: i, y: n, ...t}, r.rotation), [s, , l] = e, [c, , d] = a;
                let u = s, h = c;
                r.flipX && (u = l, h = d);
                const m = Se(me(u), h);
                i += m.x, n += m.y
            }
            Jo(r, {x: h(N.x) ? Uo(i, lt.width) : i, y: h(N.y) ? Uo(n, lt.height) : n, text: o})
        }, Vn = e => {
            const {key: t, ctrlKey: o, metaKey: i, altKey: n} = e;
            return "Enter" === t && (o || n || i)
        }, _n = () => {
            d && Xo(), Dn && Dn.confirm && Dn.confirm(), Dn && Wn(), pi(r), Tt(r)
        }, Nn = () => {
            d ? Yo() : (Jo(r, {text: N.text, x: N.x, y: N.y}), pi(r))
        }, Hn = (e, t, {flipX: o, flipY: i, rotation: n}, r = "top left") => {
            let a, s;
            const [l, c, d, u] = ft(e, n), [h, p, m, g] = ft(t, n);
            if ("top center" === r) {
                a = Ee(i ? [u, d] : [l, c]), s = Ee(i ? [g, m] : [h, p])
            } else "top right" === r && !o || "top left" === r && o ? (a = i ? d : c, s = i ? m : p) : (a = i ? u : l, s = i ? g : h);
            return Se(me(a), s)
        },
        jn = (e, t, o) => he(h(e.x) ? Uo(t.x + o.x, lt.width) : t.x + o.x, h(e.y) ? Uo(t.y + o.y, lt.height) : t.y + o.y),
        Un = {}, Gn = () => Ho(r, r.selectedPoint), Zn = () => hi(r), Xn = (e, t, o) => {
            const {width: i, height: n, ...r} = o, a = ai(t.text, r),
                s = Hn(at(o.x, o.y, e.width, e.height), at(o.x, o.y, a.width, a.height), o, "top " + t.textAlign),
                l = !1 !== o.disableNewline;
            Ko(t, ["width", "height", l && "textAlign"]), Jo(t, {...jn(t, o, s)})
        }, Yn = (e, t, o, i, n = {}) => {
            const {height: r, ...a} = o, s = Ge(ai(t.text, a), (e => Math.ceil(e))),
                l = Ve(n.width || o.width || i.width, s.height), c = n.textAlign || "left",
                d = Hn(at(o.x, o.y, e.width, e.height), at(o.x, o.y, l.width, l.height), o, "top " + c);
            Ko(t, ["height"]), Jo(t, {...jn(t, o, d), width: h(t.width) ? Uo(l.width, lt.width) : l.width, textAlign: c})
        }, qn = (e, t, o, i, n = {}) => {
            const r = Ve(n.width || i.width, n.height || i.height), a = n.textAlign || "left",
                s = Hn(at(o.x, o.y, e.width, e.height), at(o.x, o.y, r.width, r.height), o, "top " + a);
            Jo(t, {
                ...jn(t, o, s),
                width: h(t.width) ? Uo(r.width, lt.width) : r.width,
                height: h(t.width) ? Uo(r.height, lt.height) : r.height,
                textAlign: a
            })
        }, Kn = () => {
            const e = Ge(ai(r.text, p), (e => Math.ceil(e))), t = Bo(r, "height"), o = !t && Bo(r, "width"), i = r.id;
            let n = Un[i];
            if (n || (Un[i] = {}, n = Un[i]), t) {
                n.textAlign = r.textAlign, n.width = p.width, n.height = p.height;
                const t = Ve(p.width, p.height);
                Yi(r, "auto-height") ? Yn(t, r, p, e, n) : Yi(r, "auto-width") && Xn(t, r, p)
            } else if (o) {
                n.textAlign = r.textAlign, n.width = p.width;
                const t = Ve(p.width, e.height);
                Yi(r, "auto-width") ? Xn(t, r, p) : Yi(r, "fixed-size") && qn(t, r, p, e, n)
            } else {
                n.textAlign = r.textAlign || n.textAlign;
                const t = Ve(Math.ceil(e.width), Math.ceil(e.height));
                Yi(r, "fixed-size") ? qn(t, r, p, e, n) : Yi(r, "auto-height") && Yn(t, r, p, e, n)
            }
        }, Jn = e => {
            e.stopPropagation();
            const t = r.flipX || !1;
            Qo(r, "flipX", !t), Tt(r)
        }, Qn = e => {
            e.stopPropagation();
            const t = r.flipY || !1;
            Qo(r, "flipY", !t), Tt(r)
        }, er = e => {
            Qo(r, "opacity", e)
        }, or = e => {
            er(e), Tt(r)
        }, ir = e => {
            e.stopPropagation(), e.target.blur(), ri()
        }, nr = e => {
            e.stopPropagation();
            Ie.findIndex((e => e === r)) !== Ie.length - 1 && (Ue.set(Ie.filter((e => e !== r)).concat([r])), Tt(r))
        }, rr = e => {
            e.stopPropagation(), ar()
        }, ar = () => {
            const e = (s ? a : [r]).filter(Gi).map((e => {
                const t = yi(e);
                t.id = E();
                const o = he(50, -50);
                if (Bo(t, "points")) {
                    const e = Sn(t, ["points"], lt);
                    e.points.forEach((e => {
                        e.x += o.x, e.y += o.y
                    })), kn(t, e, lt)
                } else if (Ii(t)) {
                    const e = Sn(t, ["x1", "y1", "x2", "y2"], lt);
                    e.x1 += o.x, e.y1 += o.y, e.x2 += o.x, e.y2 += o.y, kn(t, e, lt)
                } else {
                    const e = Sn(t, ["x", "y"], lt);
                    e.x += 50, e.y -= 50, kn(t, e, lt)
                }
                return Ue.set([...Ie, t]), Ct(t), t
            }));
            if (e.length > 1) return li(), void e.forEach((e => {
                di(e, !0, !0)
            }));
            di(e[0])
        }, sr = bc(0, {stiffness: .2, damping: .7});
    pr(e, sr, (e => o(21, Fe = e)));
    let lr;
    const cr = (e, t) => {
        const {disableTextLayout: o = []} = t;
        return "height" in t ? o.includes("auto-height") ? e.shapeIconButtonTextLayoutAutoWidth : e.shapeIconButtonTextLayoutAutoHeight : "width" in t ? o.includes("auto-width") ? e.shapeIconButtonTextLayoutFixedSize : e.shapeIconButtonTextLayoutAutoWidth : o.includes("fixed-size") ? e.shapeIconButtonTextLayoutAutoHeight : e.shapeIconButtonTextLayoutFixedSize
    }, dr = (e, t) => {
        const {disableTextLayout: o = []} = t;
        return "height" in t ? o.includes("auto-height") ? e.shapeTitleButtonTextLayoutAutoWidth : e.shapeTitleButtonTextLayoutAutoHeight : "width" in t ? o.includes("auto-width") ? e.shapeTitleButtonTextLayoutFixedSize : e.shapeTitleButtonTextLayoutAutoWidth : o.includes("fixed-size") ? e.shapeTitleButtonTextLayoutAutoHeight : e.shapeTitleButtonTextLayoutFixedSize
    };
    let mr = !1;
    let gr = ue(), $r = void 0;
    const fr = e => {
        Ft(e), o(153, $n = e)
    }, yr = e => {
        di(Ie[e])
    };
    let br;

    function xr(e) {
        Gp(e) && e.target === br && e.preventDefault()
    }

    aa((() => {
        Fn(), En(), yn(), mn(), br.removeEventListener("touchmove", xr, !1)
    }));
    return e.$$set = e => {
        "uid" in e && o(67, Ne = e.uid), "ui" in e && o(68, He = e.ui), "disabled" in e && o(0, je = e.disabled), "shapes" in e && _e(o(1, Ue = e.shapes)), "selection" in e && o(69, Xe = e.selection), "offset" in e && o(2, qe = e.offset), "contextRotation" in e && o(70, Ke = e.contextRotation), "contextFlipX" in e && o(71, Je = e.contextFlipX), "contextFlipY" in e && o(72, Qe = e.contextFlipY), "contextZoom" in e && o(73, et = e.contextZoom), "active" in e && o(74, tt = e.active), "opacity" in e && o(75, rt = e.opacity), "parentRect" in e && o(76, lt = e.parentRect), "rootRect" in e && o(3, ct = e.rootRect), "utilRect" in e && o(4, dt = e.utilRect), "hoverColor" in e && o(77, ut = e.hoverColor), "caretColor" in e && o(78, ht = e.caretColor), "gridColor" in e && o(79, pt = e.gridColor), "snapColor" in e && o(80, mt = e.snapColor), "textInputMode" in e && o(5, gt = e.textInputMode), "oninteractionstart" in e && o(81, $t = e.oninteractionstart), "oninteractionupdate" in e && o(82, yt = e.oninteractionupdate), "oninteractionrelease" in e && o(83, bt = e.oninteractionrelease), "oninteractionend" in e && o(84, xt = e.oninteractionend), "oninteractioncancel" in e && o(85, kt = e.oninteractioncancel), "onaddshape" in e && o(86, Ct = e.onaddshape), "onupdateshape" in e && o(87, Tt = e.onupdateshape), "onselectshape" in e && o(88, Mt = e.onselectshape), "onblurshape" in e && o(89, Pt = e.onblurshape), "onremoveshape" in e && o(90, Rt = e.onremoveshape), "ontapshape" in e && o(91, At = e.ontapshape), "onhovershape" in e && o(92, Ft = e.onhovershape), "ontriggerhistorywrite" in e && o(93, zt = e.ontriggerhistorywrite), "onhovercanvas" in e && o(94, _t = e.onhovercanvas), "ontapcanvas" in e && o(95, Nt = e.ontapcanvas), "onleavecanvas" in e && o(96, Ht = e.onleavecanvas), "beforeSelectShape" in e && o(97, jt = e.beforeSelectShape), "beforeDeselectShape" in e && o(98, Ut = e.beforeDeselectShape), "beforeRemoveShape" in e && o(99, Gt = e.beforeRemoveShape), "beforeUpdateShape" in e && o(100, Zt = e.beforeUpdateShape), "willRenderShapeControls" in e && o(101, Xt = e.willRenderShapeControls), "willRenderShapeTextControls" in e && o(102, Yt = e.willRenderShapeTextControls), "willStartInteraction" in e && o(103, qt = e.willStartInteraction), "mapEditorPointToImagePoint" in e && o(104, Kt = e.mapEditorPointToImagePoint), "mapImagePointToEditorPoint" in e && o(105, Jt = e.mapImagePointToEditorPoint), "eraseRadius" in e && o(106, Qt = e.eraseRadius), "selectRadius" in e && o(107, eo = e.selectRadius), "enableButtonFlipVertical" in e && o(108, to = e.enableButtonFlipVertical), "enableTapToAddText" in e && o(109, oo = e.enableTapToAddText), "enableMultiSelect" in e && o(110, io = e.enableMultiSelect), "enableTextStyleControls" in e && o(6, no = e.enableTextStyleControls), "locale" in e && o(7, ro = e.locale), "snapThreshold" in e && o(111, ao = e.snapThreshold), "snapPointer" in e && o(112, so = e.snapPointer), "enableSnapToContext" in e && o(113, lo = e.enableSnapToContext), "gridSize" in e && o(114, co = e.gridSize)
    }, e.$$.update = () => {
        var t, i;
        if (16384 & e.$$.dirty[2] | 2097152 & e.$$.dirty[3] && o(180, n = co > 0 ? {
            x: 0,
            y: 0, ...lt
        } : void 0), 1 & e.$$.dirty[0] | 128 & e.$$.dirty[6] && o(12, r = !je && Ie && (jo() || oi())), 131072 & e.$$.dirty[3] | 128 & e.$$.dirty[6] && o(172, a = io ? Ie.filter(Fi) : []), 131072 & e.$$.dirty[5] && o(171, s = a.length > 1), 16384 & e.$$.dirty[2] | 196608 & e.$$.dirty[5] && o(192, l = s ? a.map((e => xn(yi(e), lt))) : []), 4096 & e.$$.dirty[0] && o(189, c = !!r), 4096 & e.$$.dirty[0] && o(174, d = r && Di(r)), 4096 & e.$$.dirty[0] | 524288 & e.$$.dirty[5] && o(11, u = r && !d ? r.id : void 0), 4104 & e.$$.dirty[0] | 16384 & e.$$.dirty[2] && o(15, p = ct && r && xn(yi(r), lt)), 4096 & e.$$.dirty[0] | 524288 & e.$$.dirty[5] && o(155, m = !(!r || !d)), 36864 & e.$$.dirty[0] | 8192 & e.$$.dirty[2] && o(187, g = r && rt && sn(p) || []), 65536 & e.$$.dirty[5] | 64 & e.$$.dirty[6] && o(184, $ = s ? l.map(sn) : []), 4096 & e.$$.dirty[0] | 65536 & e.$$.dirty[5] && o(191, f = !s && r && (Ji(t = r) && Qi(t) && !0 !== t.disableResize && (Bi(t) || Mi(t) || Ri(t) || Ii(t) || Ei(t) && Bo(t, "pathClose"))) && !Ai(r)), 4096 & e.$$.dirty[0] | 65536 & e.$$.dirty[5] && o(18, y = !s && r && (e => Ji(e) && !0 !== e.disableRotate && (Bi(e) || Bo(e, "text") || Ri(e)))(r) && !Ai(r)), 4096 & e.$$.dirty[0] && o(16, b = r && Ci(r) && !Mi(r) && !Ai(r) && !1 === r.disableTextScale), 4096 & e.$$.dirty[0] | 32 & e.$$.dirty[6] && o(20, x = !!f && function (e) {
            return !!e && (Ci(e) && !e.height ? [[1, 2], [3, 0]] : !Ii(e) && !Ei(e))
        }(r)), 1052672 & e.$$.dirty[0] | 32 & e.$$.dirty[6] && o(33, v = !!r && (!Array.isArray(x) && f)), 196608 & e.$$.dirty[5] && o(190, w = s ? (e => {
            const t = e.map((e => sn(xn(e, lt)))).flat(), o = it(t);
            return St(o)
        })(a) : []), 4096 & e.$$.dirty[0] | 65536 & e.$$.dirty[5] | 2 & e.$$.dirty[6] && o(17, S = r && g.length > 1 || s), 4096 & e.$$.dirty[3] | 65536 & e.$$.dirty[5] | 18 & e.$$.dirty[6] && o(185, k = s ? w.map(Jt) : g.map(Jt)), 4 & e.$$.dirty[0] | 1073741824 & e.$$.dirty[5] && o(14, C = k.map((e => he(e.x - qe.x, e.y - qe.y)))), 4096 & e.$$.dirty[0] && o(19, T = r && r.points && zo(r.selectedPoint) ? r.selectedPoint : -1), 524288 & e.$$.dirty[0] && o(164, M = T >= 0), 540672 & e.$$.dirty[0] | 512 & e.$$.dirty[5] && o(169, P = M ? C[T] : void 0), 4096 & e.$$.dirty[0] | 8 & e.$$.dirty[6] && o(32, R = c && (Mi(r) ? !Bo(r, "disableNewline") || !r.disableNewline : !1 === r.disableNewline)), 4096 & e.$$.dirty[3] | 536870912 & e.$$.dirty[4] && ($n && Jt && !Fi($n) && ji($n) ? (e => {
            const t = sn(xn(yi(e), lt));
            if (!t) return;
            const o = t.map(Jt), i = !!e.pathClose || !(!e.bitmap && (Ei(e) || Ii(e))), n = "hook" === e.selectionStyle,
                r = n ? o.map(((e, t, o) => ({
                    id: "markup-hover",
                    points: vn(o, t),
                    strokeColor: [0, 0, 0, .1],
                    strokeWidth: 2
                }))) : [{
                    id: "markup-hover",
                    points: o.map((e => he(e.x + 1, e.y + 1))),
                    strokeColor: [0, 0, 0, .1],
                    strokeWidth: 2,
                    pathClose: i
                }], a = n ? o.map(((e, t, o) => ({
                    id: "markup-hover",
                    points: vn(o, t),
                    strokeColor: ut,
                    strokeWidth: 2
                }))) : [{id: "markup-hover", points: o, strokeColor: ut, strokeWidth: 2, pathClose: i}];
            gn(...r, ...a)
        })($n) : mn()), 442368 & e.$$.dirty[0] | 8192 & e.$$.dirty[2] && o(186, I = S && y && rt && C ? (e => {
            const t = ln(e), o = Jt({x: t.origin.x + t.dir.x, y: t.origin.y + t.dir.y});
            return {origin: Jt(t.origin), position: o}
        })(p) : void 0), 4 & e.$$.dirty[0] | 1 & e.$$.dirty[6] && o(31, A = I && he(I.position.x - qe.x, I.position.y - qe.y)), 245760 & e.$$.dirty[0] | 8192 & e.$$.dirty[2] && o(188, L = S && b && rt && C ? (e => {
            const t = sn(e);
            let o = 2;
            e.flipX && e.flipY ? o = 0 : e.flipX ? o = 3 : e.flipY && (o = 1);
            const i = {...t[o]};
            return Jt({x: i.x, y: i.y})
        })(p) : void 0), 4 & e.$$.dirty[0] | 4 & e.$$.dirty[6] && o(30, F = L && he(L.x - qe.x, L.y - qe.y)), 512 & e.$$.dirty[6] && o(179, W = !!(Be || []).find((e => [91, 93, 17].includes(e)))), 524288 & e.$$.dirty[3] | 16777216 & e.$$.dirty[5] && o(181, D = !(W || !so)), 4096 & e.$$.dirty[0] | 8192 & e.$$.dirty[2] | 1073741824 & e.$$.dirty[4] | 1141374976 & e.$$.dirty[5] && r && k && rt > 0 && (r === $n && wn(), ((e, t, o) => {
            if (!ji(t)) return;
            const i = Ei(t), n = i && Bo(t, "pathClose"), r = n && (e => e.strokeWidth && ((e, t) => {
                    const o = e.strokeColor;
                    return !!o && (3 === o.length || o[3] > 0)
                })(e))(t), a = Di(t), s = Ai(t), l = "hook" === t.selectionStyle,
                c = !0 !== t.disableShowPoints, {selectionOpacity: d = 1} = t;
            if (a && i && !n) return;
            const u = [], h = [...k], p = h[h.length - 1], m = h[0], $ = (s ? .05 : .1) * e * d, f = $ > 0,
                y = (s ? .5 : 1) * e * d, b = y > 0, x = [0, 0, 0], v = [1, 1, 1], w = s ? 1 : 1.5;
            Be.includes(16) && p && o && So(p, o);
            const S = (h.length && n && a && o ? Pe(m, o) : 1 / 0) <= 256,
                C = (h.length && n && a && o ? Pe(p, o) : 1 / 0) <= 256;
            !S && o && h.push(o);
            const T = h.length > 1, M = !!t.pathClose || !(!t.bitmap && (Ei(t) || Ii(t))) || h.length > 2 && S;
            T && f && (l ? u.push(...h.map(((e, t, o) => ({
                id: fn,
                points: vn(o, t),
                strokeColor: x,
                opacity: $
            })))) : u.push({
                id: fn,
                points: h.map((e => he(e.x + 1, e.y + 1))),
                pathClose: M,
                strokeColor: x,
                strokeWidth: 2,
                opacity: $
            })), n && f && c && u.push(...h.map((e => ({
                id: fn, ...e,
                rx: 2 * w,
                ry: 2 * w,
                backgroundColor: x,
                opacity: $
            })))), I && f && u.push({
                id: fn,
                points: [he(I.origin.x + 1, I.origin.y + 1), he(I.position.x + 1, I.position.y + 1)],
                strokeColor: x,
                strokeWidth: 2,
                opacity: $
            }), T && b && (l ? u.push(...h.map(((e, t, o) => ({
                id: fn,
                points: vn(o, t),
                strokeColor: v,
                strokeWidth: w,
                opacity: y
            })))) : u.push({
                id: fn,
                points: h,
                pathClose: M,
                strokeColor: v,
                strokeWidth: w,
                backgroundColor: a && n && t.backgroundColor && t.backgroundColor[3] > 0 ? t.backgroundColor : [0, 0, 0, 0],
                opacity: y
            })), n && c && u.push(...h.map((e => ({
                id: fn, ...e,
                rx: 3 * w,
                ry: 3 * w,
                backgroundColor: [.5, .5, .5],
                strokeWidth: w,
                strokeColor: v
            })))), n && a && c && k.length >= 3 && u.push({
                ...m,
                id: fn,
                rx: w * (S ? 5 : 4),
                ry: w * (S ? 5 : 4),
                backgroundColor: S ? ut : [.5, .5, .5],
                strokeWidth: w,
                strokeColor: v
            }), n && a && r && c && !S && g.length >= 2 && u.push({
                ...p,
                id: fn,
                rx: w * (C ? 5 : 4),
                ry: w * (C ? 5 : 4),
                backgroundColor: C ? ut : [.5, .5, .5],
                strokeWidth: w,
                strokeColor: v
            }), I && b && !l && u.push({
                id: fn,
                points: [{x: I.origin.x, y: I.origin.y}, {x: I.position.x, y: I.position.y}],
                strokeColor: v,
                strokeWidth: w,
                opacity: y
            }), bn(...u)
        })(rt, r, d && Ei(r) ? Pn({...$r}, !D) : void 0)), 4096 & e.$$.dirty[0] && (r || (wn(), yn())), 4096 & e.$$.dirty[3] | 536870912 & e.$$.dirty[5]) if ($.length) {
            Tn();
            const e = $.map((e => ({
                id: Cn,
                points: e.map(Jt),
                strokeWidth: 1,
                strokeColor: [1, 1, 1, .5],
                pathClose: !0
            })));
            Mn(...e)
        } else Tn();
        536870912 & e.$$.dirty[4] && o(182, B = !!$n), 134217728 & e.$$.dirty[4] && o(183, O = !!Li), 1073741824 & e.$$.dirty[4] | 469762048 & e.$$.dirty[5] && (!$r || O || B || Pn({...$r}, !D)), 131072 & e.$$.dirty[2] | 2101248 & e.$$.dirty[3] | 33554432 & e.$$.dirty[5] | 1024 & e.$$.dirty[6] && co > 0 && n && Jt && ((e, t, o, i) => {
            const n = Jt({x: 0, y: 0}), r = Jt({x: e, y: e}), a = Jt({x: t.width, y: t.height}), s = r.x - n.x;
            if (Rn.set(s > 6 ? 1 : 0), i <= 0) return En();
            const l = Eo(s, n.x, a.x).map((e => ({
                id: In,
                opacity: i,
                points: [{x: e, y: n.y}, {x: e, y: a.y}],
                strokeWidth: 1,
                strokeColor: o
            }))), c = Eo(s, n.y, a.y).map((e => ({
                id: In,
                opacity: i,
                points: [{x: n.x, y: e}, {x: a.x, y: e}],
                strokeWidth: 1,
                strokeColor: o
            })));
            An(...c, ...l)
        })(co, n, pt, Oe), 262144 & e.$$.dirty[2] | 4096 & e.$$.dirty[3] | 100663296 & e.$$.dirty[4] | 16777216 & e.$$.dirty[5] && Jt && (W ? Fn() : ((e, t, o) => {
            if (null === e && null === t) return Fn();
            let i, n;
            null !== e && (i = {
                id: Ln,
                strokeColor: o,
                strokeWidth: 1.5,
                points: [Jt({x: e, y: 0}), Jt({x: e, y: lt.height})]
            }), null !== t && (n = {
                id: Ln,
                strokeColor: o,
                strokeWidth: 1.5,
                points: [Jt({x: 0, y: t}), Jt({x: lt.width, y: t})]
            }), zn(i, n)
        })(Po, Ro, mt)), 4096 & e.$$.dirty[2] && (e => {
            if (!e) return ei({_prerender: !1});
            const t = Ie.find((e => e.isEditing));
            t && Jo(t, {_prerender: "inline" === gt})
        })(tt), 512 & e.$$.dirty[6] && Be && Be.length && (() => {
            const [e] = Be;
            8 !== e && 46 !== e || ii() && (r.isEditing || (Ei(r) && zo(r.selectedPoint) ? setTimeout((() => Ho(r, r.selectedPoint)), 0) : setTimeout((() => ri()), 0)))
        })(), 288 & e.$$.dirty[0] && Dn && "inline" === gt && Dn.focus(), 4096 & e.$$.dirty[0] && o(178, V = r && Ci(r)), 4096 & e.$$.dirty[0] | 8388608 & e.$$.dirty[5] && o(13, _ = V && !1 !== Xi(r) && Ai(r)), 8192 & e.$$.dirty[0] && o(173, N = _ ? {...r} : void 0), 16384 & e.$$.dirty[2] | 262144 & e.$$.dirty[5] && o(175, H = N && xn({...N}, lt)), 1048576 & e.$$.dirty[5] && o(177, j = H && ai(H.text, H)), 5242880 & e.$$.dirty[5] && (U = H && at(H.x, H.y, j.width, j.height)), 12288 & e.$$.dirty[0] && o(27, G = _ ? r.text : ""), 12296 & e.$$.dirty[0] | 16384 & e.$$.dirty[2] && o(176, X = ct && r && _ && xn({
            ...yi(r),
            width: zo(r.width) ? Math.floor(r.width) : void 0,
            height: zo(r.height) ? Math.floor(r.height) : void 0
        }, lt)), 8224 & e.$$.dirty[0] | 2097152 & e.$$.dirty[5] && o(29, Y = _ && ((e, t) => {
            const {
                    textAlign: o = "left",
                    fontFamily: i = "sans-serif",
                    fontWeight: n = "normal",
                    fontStyle: r = "normal",
                    letterSpacing: a = "normal",
                    textShadowX: s = 0,
                    textShadowY: l = 0,
                    textShadowBlur: c = 0,
                    textShadowColor: d,
                    textOutlineWidth: u = 0,
                    textOutlineColor: h
                } = e, p = "!important",
                m = `caret-color:${K};text-align:${o}${p};font-family:${i}${p};font-weight:${n}${p};font-style:${r}${p};letter-spacing:${zo(a) ? a + "px" : "normal"}${p}`;
            if ("modal" === t) return m;
            const g = u ? `;-webkit-text-stroke:${2 * u}px ${Go(h)} ${p}` : "",
                $ = c || s || l ? `;text-shadow:${s}px ${l}px ${c}px ${Go(d)} ${p}` : "";
            let f = e.fontSize, y = 1, b = "";
            f > 1e3 && z() && (y = f / 1e3, b = `transform-origin:0 0;transform:scale(${y})`, f = 1e3);
            let x = e.lineHeight / y;
            const v = Go(e.color), w = .5 * Math.max(0, f - x);
            return `--font-scalar:${y};--bottom-inset:${w}px;padding:${w}px 0 0${p};color:${v}${p};font-size:${f}px${p};line-height:${x}px${p};${m};${b}${g}${$}`
        })(X, gt)), 8196 & e.$$.dirty[0] | 2304 & e.$$.dirty[2] | 2097152 & e.$$.dirty[5] && o(28, q = _ && ((e, t, o, i) => {
            let n, a;
            e.width && e.height ? (n = st(e), a = De(e)) : (a = ai(r.text, p), a.width = p.width || a.width, n = he(e.x + .5 * a.width, e.y + .5 * a.height));
            const s = Math.max(0, e.fontSize - e.lineHeight) + e.lineHeight, l = Jt(n);
            let c = l.x - t.x - .5 * a.width, d = l.y - t.y - .5 * a.height, u = e.flipX, h = e.flipY, m = e.rotation;
            Je && Qe ? (u = !u, h = !h) : Je ? (u = !u, m = -m) : Qe && (h = !h, m = -m), m += i;
            const g = o * (u ? -1 : 1), $ = o * (h ? -1 : 1);
            return `--line-height:${s}px;width:${a.width}px;height:${a.height}px;transform:translate(${c}px,${d}px) rotate(${m}rad) scale(${g}, ${$})`
        })(X, qe, et, Ke)), 65536 & e.$$.dirty[2] && (K = ht ? Go(ht) : "auto"), 8480 & e.$$.dirty[0] && _ && Dn && "inline" === gt && Bn(G), 4096 & e.$$.dirty[0] | 33 & e.$$.dirty[5] && o(160, J = r && !m ? r : J), 32 & e.$$.dirty[5] && o(162, Q = J && Zi(J)), 32 & e.$$.dirty[5] && o(157, ee = J && Yi(J)), 32 & e.$$.dirty[5] && o(159, te = J && Gi(J)), 32 & e.$$.dirty[5] && o(158, oe = J && Ui(J)), 65568 & e.$$.dirty[5] && o(161, ie = !s && J && (e => !0 !== e.disableReorder)(J)), 32 & e.$$.dirty[5] && o(156, ne = J && !1 !== Xi(J)), 32 & e.$$.dirty[5] && o(163, re = J && Bo(J, "backgroundImage") && Hi(J, "opacity")), 4128 & e.$$.dirty[0] && o(166, ae = r && "html" === r.format && "inline" === gt), 4096 & e.$$.dirty[0] | 2049 & e.$$.dirty[5] && o(170, se = r && (!m || ae)), 268435456 & e.$$.dirty[4] | 32768 & e.$$.dirty[5] | 256 & e.$$.dirty[6] && sr.set(se && !tn ? 1 : 0, {hard: !1 === ze}), 16384 & e.$$.dirty[0] | 40960 & e.$$.dirty[5] && o(168, ce = se && C.length ? (i = it(C), ve(he(i.x + .5 * i.width, i.y), Dd)) : ce), 528 & e.$$.dirty[0] | 24576 & e.$$.dirty[5] && o(167, pe = (P || ce) && lr && dt && ((e, t, o, i) => {
            const n = e.x, r = e.y, a = n + e.width;
            let s = Math.max(t.x - .5 * o.width, n), l = Math.max(t.y - o.height + i, r);
            return s + o.width > a && (s = a - o.width), he(s, l)
        })(dt, P || ce, lr, -16)), 4096 & e.$$.dirty[5] && o(26, ge = pe ? `translate(${pe.x}px, ${pe.y}px)` : void 0), 2097152 & e.$$.dirty[0] | 4096 & e.$$.dirty[5] && o(25, fe = pe ? Fe : void 0), 8192 & e.$$.dirty[0] && o(165, ke = _ ? "text" : "shape"), 6272 & e.$$.dirty[0] | 33536 & e.$$.dirty[3] | 4094 & e.$$.dirty[5] | 128 & e.$$.dirty[6] && o(24, Te = "text" === ke && Yt && ae ? lm((() => Yt([["div", "text-styles", {class: "PinturaShapeControlsGroup"}, [...[["bold", {
            label: "B",
            style: "font-weight:900;",
            title: "Bold",
            shortcut: ["CMD", "B"]
        }], ["italic", {
            label: "I",
            style: "font-family:Times New Roman;font-style:italic;",
            title: "Italic",
            shortcut: ["CMD", "I"]
        }], ["underline", {
            label: "U",
            style: "text-decoration:underline;",
            title: "Underline",
            shortcut: ["CMD", "U"]
        }], ["strikeThrough", {
            label: "S",
            style: "text-decoration:line-through;",
            title: "Strikethrough",
            shortcut: ["CMD", "S"]
        }]].map((([e, t]) => ["Button", "style-" + e, {
            onclick: () => document.execCommand(e), ...t,
            style: "font-size:1.25em;text-underline-offset:1px;text-decoration-thickness:1.5px;font-weight:400;" + t.style
        }]))]], ["div", "text-reset", {class: "PinturaShapeControlsGroup"}, [["Button", "style-reset", {
            onclick: () => document.execCommand("removeFormat"),
            style: "font-weight:400",
            title: "Remove styles",
            label: [["span", "T", {
                style: "font-size:1.25em;font-style:italic;font-family:Times New Roman;text-decoration:underline",
                textContent: "T"
            }], ["span", "x", {style: "position:relative;top:.175rem;", innerHTML: "&times;"}]]
        }]]]], u))) : "shape" === ke && Xt && u ? lm((() => Xt(M ? [["div", "epsilon", {class: "PinturaShapeControlsGroup"}, [["Button", "remove-point", {
            onclick: Gn,
            label: ro.shapeTitleButtonRemove,
            icon: ro.shapeIconButtonRemove,
            shortcut: ["Backspace"],
            hideLabel: !0
        }]]]] : [re && ["div", "alpha", {class: "PinturaShapeControlsGroup"}, [["ToggleSlider", "adjust-opacity", {
            onrelease: or,
            onchange: er,
            step: .01,
            value: Bo(r, "opacity") ? r.opacity : 1,
            label: (e, t, o) => Math.round(e / o * 100) + "%",
            min: 0,
            max: 1,
            direction: "x"
        }]]], ["div", "beta", {class: "PinturaShapeControlsGroup"}, [Q && ["Button", "flip-horizontal", {
            onclick: Jn,
            label: ro.shapeTitleButtonFlipHorizontal,
            icon: ro.shapeIconButtonFlipHorizontal,
            hideLabel: !0
        }], Q && to && ["Button", "flip-vertical", {
            onclick: Qn,
            label: ro.shapeTitleButtonFlipVertical,
            icon: ro.shapeIconButtonFlipVertical,
            hideLabel: !0
        }], ie && ["Button", "to-front", {
            onclick: nr,
            label: ro.shapeTitleButtonMoveToFront,
            icon: ro.shapeIconButtonMoveToFront,
            hideLabel: !0,
            disabled: Ie[Ie.length - 1] === J
        }], te && ["Button", "duplicate", {
            onclick: rr,
            label: ro.shapeTitleButtonDuplicate,
            icon: ro.shapeIconButtonDuplicate,
            shortcut: ["CMD", "D"],
            hideLabel: !0
        }], oe && ["Button", "remove", {
            onclick: ir,
            label: ro.shapeTitleButtonRemove,
            icon: ro.shapeIconButtonRemove,
            shortcut: ["Backspace"],
            hideLabel: !0
        }]].filter(Boolean)], ne && ee && ["div", "gamma", {class: "PinturaShapeControlsGroup"}, [["Button", "text-layout", {
            onclick: Kn,
            label: iu(dr, ro, r),
            icon: iu(cr, ro, r),
            hideLabel: !0
        }]]], ne && ["div", "delta", {class: "PinturaShapeControlsGroup"}, [["Button", "edit-text", {
            label: ro.shapeLabelInputText,
            onclick: Zn
        }]]]].filter(Boolean), u))) : []), 128 & e.$$.dirty[0] | 128 & e.$$.dirty[6] && o(23, Me = Ie.filter(ji).filter((e => e.id)).filter((e => !Di(e))).map((e => ({
            id: e.id,
            color: Ci(e) ? e.color : Ii(e) ? e.strokeColor : e.backgroundColor,
            name: e.name || ro["shapeLabelTool" + as(hn(e))]
        })))), 1024 & e.$$.dirty[0] && br && br.addEventListener("touchmove", xr, !1)
    }, [je, Ue, qe, ct, dt, gt, no, ro, Dn, lr, br, u, r, _, C, p, b, S, y, T, x, Fe, mr, Me, Te, fe, ge, G, q, Y, F, A, R, v, po, ko, e => {
        const {origin: t} = e.detail, i = io && Be.includes(16);
        on = void 0, o(151, Li = void 0), zi = void 0, Oi = void 0, Wi = !1, wi = void 0, Vi = !1, en = !1, Mo(), clearTimeout(vi), vi = setTimeout((() => o(152, tn = !0)), 250);
        const n = jo();
        if (!n || Ei(n) && Bo(n, "pathClose") || Xo(), xi = Kt(me(t)), n && Ei(n) && Bo(n, "pathClose")) return $t(e);
        const l = fi(Ie, xi, eo, (e => ji(e))), c = l.length && l.shift();
        if (r && Ai(r)) if (c !== r) _n(); else {
            const e = Bo(r, "height"), t = !e && Bo(r, "width");
            if (e || t) {
                const e = yi(r), t = yi(e);
                xn(t, lt);
                const o = Ge(ai(e.text, t), (e => Math.ceil(e))), i = Ve(t.width, t.height || o.height);
                Xn(i, e, t);
                const n = fi([{...e, strokeWidth: "5%"}], xi, 0);
                en = 0 === n.length
            }
        }
        if (r && oo && (Vi = !0), !c && r && Ai(r) && ui(r), !qt(t)) return;
        if (c && Fi(c)) return Wi = !0, o(151, Li = c), s ? (i && ui(c), void nn(a)) : (zi = yi(Li), void (Oi = xn(yi(Li), lt)));
        wi = c || void 0;
        if (!$t(e) && c) {
            if (di(c, !0, i), o(151, Li = c), s) return nn(a);
            zi = yi(Li), Oi = xn(yi(Li), lt)
        }
    }, e => {
        rn(), kt(e)
    }, e => {
        const {translation: t, ctrlKey: o, metaKey: i, shiftKey: r, position: s} = e.detail;
        if (Li) {
            if (!Qi(Li)) return;
            if (Ai(Li)) {
                if (!en) return;
                _n()
            }
            if (r) {
                let e = Math.abs(t.x), o = Math.abs(t.y);
                "x" === an && (o -= 64), "y" === an && (e -= 64), e > o ? (t.y = 0, an = "x") : o > e && (t.x = 0, an = "y")
            } else an = null;
            const e = o || i;
            if (on) {
                if (!a.every(Qi)) return;
                return void on.forEach((({shape: e, shapeOriginComputed: o}) => {
                    Oo(e, o, t, {...ho(0, co, n, e)})
                }))
            }
            return Oo(Li, Oi, t, {...ho(e ? 0 : ao, co, n, Li)})
        }
        yt(e)
    }, e => {
        if (rn(), Li) {
            if (!s) if (e.detail.isTap && Ei(Li) && Ki(Li)) {
                const {position: t} = e.detail, o = Kt(me(t));
                ((e, t) => {
                    const o = e.points, i = [];
                    for (let e = 0; e < o.length - 1; e++) i.push([o[e], o[e + 1]]);
                    i.push([o[o.length - 1], o[0]]);
                    const n = i.findIndex((([e, o]) => Bt(t, 6, e, o)));
                    let r;
                    const a = [];
                    for (let e = 0; e < i.length; e++) a.push(i[e][0]), e === n && (r = e + 1, a.push(t));
                    Jo(e, {points: a, selectedPoint: r})
                })(Li, o)
            } else e.detail.isTap && Wi && Ci(Li) && !1 !== Xi(Li) && hi(Li)
        } else bt(e)
    }, e => {
        const t = wi && e.detail.isTap, i = io && Be.includes(16);
        if (e.detail.isTap && setTimeout((() => {
            Nt({target: Li || wi, position: xi}, 0)
        })), Li) return At(Li), n = Li, r = zi, JSON.stringify(n) !== JSON.stringify(r) && Tt(Li), void o(151, Li = void 0);
        var n, r;
        let a = !0;
        if (!i) {
            const e = ci();
            a = !e || Ut(e, wi || void 0), a && li({storePrevious: !1})
        }
        xt(e), a && t && di(wi, !0, i)
    }, Rn, e => {
        o(152, tn = !0), o(151, Li = r), Oi = p
    }, e => {
        if (!Li) return void o(152, tn = !1);
        const {translation: t, indexes: i, shiftKey: r, ctrlKey: a, metaKey: s, isNudge: l} = e.detail;
        _o(Li, Oi, i, t, {shiftKey: !l && r, ...ho(a || s ? 0 : ao, co, n, Li)}), qi(Li) && Pe(t) > 16 && Jo(Li, {selectedPoint: void 0})
    }, e => {
        if (!Li) return void o(152, tn = !1);
        di(Li);
        const {isTap: t, translation: i, indexes: n} = e.detail;
        t && (qi(Li) && Jo(Li, {selectedPoint: Li.selectedPoint === n[0] ? void 0 : n[0]}), At(Li)), o(151, Li = void 0), o(152, tn = !1), Tt(r)
    }, e => {
        No = ln(p).origin, o(152, tn = !0), o(151, Li = r), Oi = p
    }, e => {
        if (!Li) return void o(152, tn = !1);
        const {translation: t, shiftKey: i} = e.detail;
        ((e, t, o, i) => {
            const n = $i(xn(yi(e), lt)), r = st(n), a = Io(No, o);
            let s = be(a, r) + Math.PI / 2;
            if (i.shiftKey) {
                const e = Math.PI / 16;
                s = e * Math.round(s / e) - Ke % e
            }
            wo(e, {rotation: s}, lt), qo()
        })(Li, 0, t, {shiftKey: i})
    }, () => {
        Li ? (di(Li), o(151, Li = void 0), o(152, tn = !1), Tt(r)) : o(152, tn = !1)
    }, e => {
        o(152, tn = !0), o(151, Li = r), Oi = p
    }, e => {
        if (!Li) return void o(152, tn = !1);
        const {translation: t, ctrlKey: i, metaKey: r} = e.detail;
        ((e, t, o, i) => {
            const n = ot(t), r = ai(t.text, t);
            n.width || (n.width = r.width), n.height || (n.height = r.height);
            let a = 2;
            e.flipX && e.flipY ? a = 0 : e.flipX ? a = 3 : e.flipY && (a = 1), _o(e, t, [a], o, {
                ...i,
                aspectRatio: n.width / n.height,
                beforeResizeShape: e => {
                    const o = e.width / n.width;
                    e.fontSize = t.fontSize * o, t.width || delete e.width, t.height || delete e.height
                }
            })
        })(Li, Oi, t, {...ho(i || r ? 0 : ao, co, n, Li)})
    }, () => {
        Li ? (di(Li), o(151, Li = void 0), o(152, tn = !1), Tt(r)) : o(152, tn = !1)
    }, e => {
        const {key: t} = e, o = /escape/i.test(t);
        if (ii()) return o ? (e.preventDefault(), e.stopPropagation(), ui(r)) : void (te && "d" === t && (e.metaKey || e.ctrlKey) && (e.preventDefault(), e.stopPropagation(), ar()))
    }, e => {
        const t = Xi(r, e);
        return !0 === t ? e : t
    }, Wn, e => {
        const {target: t, key: o} = e, i = t.value || t.innerText, n = t.selectionStart || 0,
            a = t.selectionEnd || i.length, s = i.substring(0, n) + o + i.substring(a);
        if (Xi(r, s) !== s) return e.preventDefault()
    }, e => Ti(r) && /enter/i.test(e.code) && !1 !== r.disableNewline ? e.preventDefault() : /arrow/i.test(e.code) ? e.stopPropagation() : /escape/i.test(e.key) ? Nn() : void 0, Vn, e => {
        if (Vn(e)) return _n()
    }, _n, Nn, sr, e => {
        const t = ti();
        t && (t.find(Ai) || t.find((e => !Qi(e))) || t.forEach((t => {
            o(151, Li = t), Oi = xn(yi(Li), lt), Oo(Li, Oi, e.detail)
        })))
    }, e => {
        o(22, mr = !0)
    }, ({relatedTarget: e}) => {
        e && e.classList.contains("shape-selector__button") || o(22, mr = !1)
    }, e => {
        if ("touch" === e.pointerType || "PinturaShapeEditor" !== e.target.className) return void Ht();
        (tn || vi) && fr(void 0);
        const t = nb(e, ct);
        o(154, $r = me(t));
        const i = ve(Kt(t), (e => Math.round(e)));
        if (xe(i, gr)) return;
        if (gr = me(i), _t(tn, t, i), tn || vi) return;
        if (m) return;
        const [n] = fi(Ie, i, 0, ji);
        n && Di(n) || fr(n)
    }, e => {
        "touch" !== e.pointerType && Ht()
    }, yr, Ne, He, Xe, Ke, Je, Qe, et, tt, rt, lt, ut, ht, pt, mt, $t, yt, bt, xt, kt, Ct, Tt, Mt, Pt, Rt, At, Ft, zt, _t, Nt, Ht, jt, Ut, Gt, Zt, Xt, Yt, qt, Kt, Jt, Qt, eo, to, oo, io, ao, so, lo, co, go, $o, fo, yo, bo, xo, vo, (e, t = {}) => {
        let o, i, r, a = [], s = Ri(e), l = Ci(e), c = "relative" === t.position;
        const d = t.interpolateInput, u = uo(), p = e => {
            if (!ao) return e;
            const t = Kt(e), {snapTranslation: o, snapLines: i} = Fo(Ao(t), u, ao, co, n);
            return Do(e, o), To(i), e
        }, m = !!ci(), g = t.isSelection ? Xe : Ue, $ = "step" === t.inputMode;
        if (Ei(e)) {
            if ($) {
                let t = !1;
                const n = (e, o) => {
                    const i = $o(g), n = e && he(pb(e.x, lt.width), pb(e.y, lt.height)), r = n && Jt(n);
                    Be.includes(16) && r && So(r, o);
                    const a = Kt(o), s = i.points.length ? i.points[0] : a,
                        l = he(pb(s.x, lt.width), pb(s.y, lt.height)), d = Jt(l), u = Pe(d, o);
                    if (!t && 1 === i.points.length && u < 36) return yo(g);
                    if (i.points.length > 2 && u <= 256) {
                        i.pathClose = !0, ji(i) && di(i);
                        const e = bo(g);
                        return void Ct(e)
                    }
                    const h = i.strokeWidth && i.strokeColor && (void 0 === i.strokeColor[3] || i.strokeColor[3] > 0),
                        p = Pe(r, o);
                    if (h && i.points.length > 1 && p < 256) {
                        i.pathClose = !1, i.backgroundColor = [0, 0, 0, 0], ji(i) && di(i);
                        const e = bo(g);
                        Ct(e)
                    } else if (!(i.points.length > 0 && p < 100)) return c ? mb(a, lt) : a
                };
                return {
                    start: e => {
                        const a = $o(g), {origin: s} = e.detail;
                        if (i = 4, o = p(me(s)), r = me(o), a) {
                            const e = a.points[a.points.length - 1], t = n(e, o);
                            return t && (a.points = [...a.points, t]), void xo({points: a.points}, g)
                        }
                        t = !0
                    }, update: e => {
                        if (!t) return;
                        const i = $o(g);
                        if (!i) return;
                        const r = i.points[0], a = n(r, he(o.x + e.detail.translation.x, o.y + e.detail.translation.y));
                        a && (i.points[1] = a, xo({points: i.points}, g))
                    }, release: e => e.detail.preventInertia(), cancel: () => {
                        yo(g)
                    }, end: i => {
                        if (!t) return;
                        const n = Kt(o), r = c ? mb(n, lt) : n, {isTap: a} = i.detail;
                        if (a) {
                            if (fi(Ie, n, 0, ji).length) return yo(g)
                        }
                        fo({...e, points: [r]}, g)
                    }
                }
            }
            return {
                start: t => {
                    const {origin: n} = t.detail;
                    i = 4, o = me(n), r = me(o), a.push({...r});
                    const s = Kt(o), l = c ? mb(s, lt) : s;
                    fo({...e, points: [l]}, g)
                }, update: e => {
                    const t = $o(g);
                    if (!t) return;
                    const {translation: n} = e.detail, s = he(o.x + n.x, o.y + n.y), l = Re(r, s);
                    if (le(l, 5) <= i) return;
                    const u = [], h = be(s, r), p = i - l, m = {x: r.x + p * Math.cos(h), y: r.y + p * Math.sin(h)};
                    if (a.push({...m}), d && t.points.length > 1) {
                        const e = a.length, t = Math.ceil(l / 10);
                        let o = l / 30;
                        const i = a[e - 3], n = a[e - 2], r = a[e - 1];
                        a[e - 4] || (o *= .1), u.push(...Lt(i, n, r, t, o).slice(1, -1)), a.splice(e - 1, 0, ...u)
                    }
                    u.push(m), r.x = m.x, r.y = m.y, xo({
                        points: t.points.concat(u.map((e => {
                            const t = Kt(e);
                            return c ? mb(t, lt) : t
                        })))
                    }, g)
                }, release: e => e.detail.preventInertia(), cancel: () => {
                    yo(g)
                }, end: e => {
                    const t = $o(g);
                    if (!t) return;
                    if (e.detail.isTap) {
                        let e = !1;
                        if (t.bitmap ? (wi && (e = !0), m && (e = !0)) : e = !0, e) return yo(g)
                    }
                    const o = bo(g);
                    Ct(o)
                }
            }
        }
        return s || l || Pi(e) ? {
            start: t => {
                const {origin: i} = t.detail;
                o = p(me(i));
                const n = Kt(o), r = c ? mb(n, lt) : n, a = -1 * Co(Ke, Je, Qe), l = {...e, rotation: a, ...r};
                l.flipX = Je, l.flipY = Qe, delete l.position, l.opacity = 0;
                (s ? ["rx", "ry"] : ["width", "height"]).forEach((e => {
                    l[e] = c ? "0%" : 0
                })), fo(l, g)
            }, update: e => {
                const t = $o(g);
                if (!t) return;
                t.opacity = 1;
                let {aspectRatio: i} = t, {translation: n, shiftKey: r, ctrlKey: a} = e.detail;
                !i && r && (i = 1);
                const l = p(he(o.x + n.x, o.y + n.y)), c = Kt(o), d = Kt(l);
                if (i) {
                    const e = it([c, d]), t = vt(e, i), o = d.x < c.x ? -1 : 1, n = d.y < c.y ? -1 : 1;
                    d.x = c.x + t.width * o, d.y = c.y + t.height * n
                }
                const u = {x: c.x + .5 * (d.x - c.x), y: c.y + .5 * (d.y - c.y)}, h = Co(Ke, Je, Qe);
                $e(c, h, u), $e(d, h, u);
                const m = Math.min(c.x, d.x), $ = Math.min(c.y, d.y);
                let f = Math.max(c.x, d.x) - m, y = Math.max(c.y, d.y) - $, b = {};
                s ? (a ? (b.x = c.x, b.y = c.y) : (b.x = m + .5 * f, b.y = $ + .5 * y), b.rx = .5 * f, b.ry = .5 * y) : (a ? (b.x = c.x - .5 * f, b.y = c.y - .5 * y) : (b.x = m, b.y = $), b.width = f, b.height = y), xo(b, g, ((e, t) => wo(e, t, lt)))
            }, release: e => {
                e.detail.preventInertia()
            }, cancel: () => {
                yo(g)
            }, end: e => {
                const t = $o(g);
                if (t) {
                    if (e.detail.isTap) {
                        if (Ci(t) && oo && Vi) return yo(g);
                        if (!Ci(t) || !oo || wi) return yo(g);
                        delete t.width, delete t.height, !1 !== t.disableNewline && delete t.textAlign;
                        const e = xn({...t}, lt), i = ai(t.text, e), n = Kt({x: o.x, y: o.y - .5 * i.height}),
                            r = Kt({x: o.x + i.width, y: o.y + .5 * i.height}),
                            a = {x: n.x + .5 * (r.x - n.x), y: n.y + .5 * (r.y - n.y)}, s = Co(Ke, Je, Qe);
                        $e(n, s, a), $e(r, s, a);
                        let l = Math.min(n.x, r.x), c = Math.min(n.y, r.y);
                        l < 0 && (l = 0), c < 0 && (c = 0), l + i.width > lt.width && (l = lt.width - i.width), c + i.height > lt.height && (c = lt.height - i.height), t.x = h(t.x) ? Uo(l, lt.width) : l, t.y = h(t.y) ? Uo(c, lt.height) : c
                    }
                    if (t.opacity = 1, Ci(t)) Ct(t); else {
                        const e = bo(g);
                        Ct(e)
                    }
                    ji(t) && di(t), Ci(t) && hi(t)
                }
            }
        } : Ii(e) ? {
            start: t => {
                const {origin: i} = t.detail, n = Kt(p(i)), r = ve(n, Dd);
                o = me(i), fo({
                    ...e,
                    x1: c ? Uo(r.x, lt.width) : r.x,
                    y1: c ? Uo(r.y, lt.height) : r.y,
                    x2: c ? Uo(r.x, lt.width) : r.x,
                    y2: c ? Uo(r.y, lt.height) : r.y,
                    opacity: 0
                }, g)
            }, update: e => {
                if (!$o(g)) return;
                const {translation: t} = e.detail, i = p(we(me(o), t));
                if (Be.includes(16)) {
                    const e = Re(o, i), t = be(o, i), n = Math.PI / 4, r = n * Math.round(t / n);
                    i.x = o.x + e * Math.cos(r), i.y = o.y + e * Math.sin(r)
                }
                const n = Kt(i);
                xo({x2: c ? Uo(n.x, lt.width) : n.x, y2: c ? Uo(n.y, lt.height) : n.y, opacity: 1}, g)
            }, release: e => e.detail.preventInertia(), cancel: () => {
                yo(g)
            }, end: e => {
                const t = $o(g);
                if (!t) return;
                if (e.detail.isTap) return yo(g);
                t.opacity = 1;
                const o = bo(g);
                Ct(o), ji(t) && di(o)
            }
        } : void 0
    }, () => {
        let e, t;
        const o = Qt * Qt, i = (e, t, i = !1) => {
            const n = Pe(e, t);
            if (!i && n < 2) return !1;
            const r = Ie.filter((e => !e.disableErase));
            let a;
            a = n < o ? fi(Ie, Kt(t), Qt) : bi(r, Kt(e), Kt(t), Qt);
            return mi(a).forEach(Rt), !0
        };
        return {
            start: o => {
                e = he(Math.round(o.detail.origin.x), Math.round(o.detail.origin.y)), i(e, e, !0), t = e
            }, update: o => {
                const {translation: n} = o.detail, r = he(Math.round(e.x + n.x), Math.round(e.y + n.y));
                i(t, r) && (t = me(r))
            }, release: e => e.detail.preventInertia(), cancel: () => {
                yo(collection)
            }, end: () => {
            }
        }
    }, jo, Zo, e => {
        if (!jo()) return _i(e), vo(e)
    }, Xo, Yo, (e = {}) => ({id: E(), ...e}), qo, Ko, Jo, Qo, (e, t, o = !0) => {
        Ie.forEach((o => Qo(o, e, t, !1))), o && qo()
    }, ei, ti, oi, ii, li, di, ui, hi, pi, mi, gi, $i, fi, bi, Po, Ro, Li, tn, $n, $r, m, ne, ee, oe, te, J, ie, Q, re, M, ke, ae, pe, ce, P, se, s, a, N, d, H, X, j, V, W, n, D, B, O, $, k, I, g, L, c, w, f, l, Ie, ze, Be, Oe, function (t) {
        da.call(this, e, t)
    }, e => yr(e), function (e) {
        ha[e ? "unshift" : "push"]((() => {
            Dn = e, o(8, Dn)
        }))
    }, function () {
        G = this.value, o(27, G), o(13, _), o(12, r), o(178, V), o(0, je), o(193, Ie)
    }, e => {
        const {key: t} = e;
        if ("Enter" === t) {
            if (Vn(e)) return !0;
            if (!1 === r.disableNewline) return !1
        }
        return !0
    }, function (e) {
        ha[e ? "unshift" : "push"]((() => {
            Dn = e, o(8, Dn)
        }))
    }, () => {
        br && br.focus()
    }, e => o(9, lr = e.detail), function (e) {
        ha[e ? "unshift" : "push"]((() => {
            br = e, o(10, br)
        }))
    }, e => nb(e, ct)]
}

class Tb extends Ga {
    constructor(e) {
        super(), Ua(this, e, Cb, Sb, lr, {
            uid: 67,
            ui: 68,
            disabled: 0,
            shapes: 1,
            selection: 69,
            offset: 2,
            contextRotation: 70,
            contextFlipX: 71,
            contextFlipY: 72,
            contextZoom: 73,
            active: 74,
            opacity: 75,
            parentRect: 76,
            rootRect: 3,
            utilRect: 4,
            hoverColor: 77,
            caretColor: 78,
            gridColor: 79,
            snapColor: 80,
            textInputMode: 5,
            oninteractionstart: 81,
            oninteractionupdate: 82,
            oninteractionrelease: 83,
            oninteractionend: 84,
            oninteractioncancel: 85,
            onaddshape: 86,
            onupdateshape: 87,
            onselectshape: 88,
            onblurshape: 89,
            onremoveshape: 90,
            ontapshape: 91,
            onhovershape: 92,
            ontriggerhistorywrite: 93,
            onhovercanvas: 94,
            ontapcanvas: 95,
            onleavecanvas: 96,
            beforeSelectShape: 97,
            beforeDeselectShape: 98,
            beforeRemoveShape: 99,
            beforeUpdateShape: 100,
            willRenderShapeControls: 101,
            willRenderShapeTextControls: 102,
            willStartInteraction: 103,
            mapEditorPointToImagePoint: 104,
            mapImagePointToEditorPoint: 105,
            eraseRadius: 106,
            selectRadius: 107,
            enableButtonFlipVertical: 108,
            enableTapToAddText: 109,
            enableMultiSelect: 110,
            enableTextStyleControls: 6,
            locale: 7,
            snapThreshold: 111,
            snapPointer: 112,
            enableSnapToContext: 113,
            gridSize: 114,
            syncShapeCollection: 115,
            getShapeDraft: 116,
            addShapeDraft: 117,
            discardShapeDraft: 118,
            confirmShapeDraft: 119,
            updateShapeDraft: 120,
            addShape: 121,
            createShape: 122,
            eraseShape: 123,
            getMarkupItemDraft: 124,
            getMarkupItemDraftIndex: 125,
            addMarkupItemDraft: 126,
            confirmMarkupItemDraft: 127,
            discardMarkupItemDraft: 128,
            createMarkupItem: 129,
            syncShapes: 130,
            removeMarkupShapeProps: 131,
            updateMarkupShape: 132,
            updateMarkupShapeProperty: 133,
            updateMarkupItemsShapeProperty: 134,
            updateMarkupShapeItems: 135,
            getActiveMarkupItems: 136,
            getActiveMarkupItem: 137,
            hasActiveMarkupItem: 138,
            blurShapes: 139,
            selectShape: 140,
            deselectMarkupItem: 141,
            editMarkupItem: 142,
            finishEditMarkupItem: 143,
            removeMarkupItems: 144,
            getTextShapeRect: 145,
            getMarkupShapeRect: 146,
            getShapesNearPosition: 147,
            getShapesBetweenPoints: 148
        }, null, [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1])
    }

    get syncShapeCollection() {
        return this.$$.ctx[115]
    }

    get getShapeDraft() {
        return this.$$.ctx[116]
    }

    get addShapeDraft() {
        return this.$$.ctx[117]
    }

    get discardShapeDraft() {
        return this.$$.ctx[118]
    }

    get confirmShapeDraft() {
        return this.$$.ctx[119]
    }

    get updateShapeDraft() {
        return this.$$.ctx[120]
    }

    get addShape() {
        return this.$$.ctx[121]
    }

    get createShape() {
        return this.$$.ctx[122]
    }

    get eraseShape() {
        return this.$$.ctx[123]
    }

    get getMarkupItemDraft() {
        return this.$$.ctx[124]
    }

    get getMarkupItemDraftIndex() {
        return this.$$.ctx[125]
    }

    get addMarkupItemDraft() {
        return this.$$.ctx[126]
    }

    get confirmMarkupItemDraft() {
        return this.$$.ctx[127]
    }

    get discardMarkupItemDraft() {
        return this.$$.ctx[128]
    }

    get createMarkupItem() {
        return this.$$.ctx[129]
    }

    get syncShapes() {
        return this.$$.ctx[130]
    }

    get removeMarkupShapeProps() {
        return this.$$.ctx[131]
    }

    get updateMarkupShape() {
        return this.$$.ctx[132]
    }

    get updateMarkupShapeProperty() {
        return this.$$.ctx[133]
    }

    get updateMarkupItemsShapeProperty() {
        return this.$$.ctx[134]
    }

    get updateMarkupShapeItems() {
        return this.$$.ctx[135]
    }

    get getActiveMarkupItems() {
        return this.$$.ctx[136]
    }

    get getActiveMarkupItem() {
        return this.$$.ctx[137]
    }

    get hasActiveMarkupItem() {
        return this.$$.ctx[138]
    }

    get blurShapes() {
        return this.$$.ctx[139]
    }

    get selectShape() {
        return this.$$.ctx[140]
    }

    get deselectMarkupItem() {
        return this.$$.ctx[141]
    }

    get editMarkupItem() {
        return this.$$.ctx[142]
    }

    get finishEditMarkupItem() {
        return this.$$.ctx[143]
    }

    get removeMarkupItems() {
        return this.$$.ctx[144]
    }

    get getTextShapeRect() {
        return this.$$.ctx[145]
    }

    get getMarkupShapeRect() {
        return this.$$.ctx[146]
    }

    get getShapesNearPosition() {
        return this.$$.ctx[147]
    }

    get getShapesBetweenPoints() {
        return this.$$.ctx[148]
    }
}

function Mb(e) {
    let t, o, i;
    return o = new pp({props: {items: e[2]}}), {
        c() {
            t = Fr("ul"), Na(o.$$.fragment), Nr(t, "class", "PinturaShapeStyleList")
        }, m(e, n) {
            Ar(e, t, n), Ha(o, t, null), i = !0
        }, p(e, t) {
            const i = {};
            4 & t && (i.items = e[2]), o.$set(i)
        }, i(e) {
            i || (Ea(o.$$.fragment, e), i = !0)
        }, o(e) {
            Aa(o.$$.fragment, e), i = !1
        }, d(e) {
            e && Lr(t), ja(o)
        }
    }
}

function Pb(e) {
    let t, o;
    return t = new Ep({
        props: {
            class: "PinturaShapeStyles",
            elasticity: e[0],
            $$slots: {default: [Rb]},
            $$scope: {ctx: e}
        }
    }), {
        c() {
            Na(t.$$.fragment)
        }, m(e, i) {
            Ha(t, e, i), o = !0
        }, p(e, o) {
            const i = {};
            1 & o && (i.elasticity = e[0]), 524292 & o && (i.$$scope = {dirty: o, ctx: e}), t.$set(i)
        }, i(e) {
            o || (Ea(t.$$.fragment, e), o = !0)
        }, o(e) {
            Aa(t.$$.fragment, e), o = !1
        }, d(e) {
            ja(t, e)
        }
    }
}

function Rb(e) {
    let t, o, i;
    return o = new pp({props: {items: e[2]}}), {
        c() {
            t = Fr("ul"), Na(o.$$.fragment), Nr(t, "class", "PinturaShapeStyleList")
        }, m(e, n) {
            Ar(e, t, n), Ha(o, t, null), i = !0
        }, p(e, t) {
            const i = {};
            4 & t && (i.items = e[2]), o.$set(i)
        }, i(e) {
            i || (Ea(o.$$.fragment, e), i = !0)
        }, o(e) {
            Aa(o.$$.fragment, e), i = !1
        }, d(e) {
            e && Lr(t), ja(o)
        }
    }
}

function Ib(e) {
    let t, o, i, n;
    const r = [Pb, Mb], a = [];

    function s(e, t) {
        return e[1] ? 0 : 1
    }

    return o = s(e), i = a[o] = r[o](e), {
        c() {
            t = Fr("div"), i.c(), Zr(t, "opacity", e[5]), Zr(t, "pointer-events", e[4]), Zr(t, "visibility", e[3])
        }, m(e, i) {
            Ar(e, t, i), a[o].m(t, null), n = !0
        }, p(e, [n]) {
            let l = o;
            o = s(e), o === l ? a[o].p(e, n) : (Ra(), Aa(a[l], 1, 1, (() => {
                a[l] = null
            })), Ia(), i = a[o], i ? i.p(e, n) : (i = a[o] = r[o](e), i.c()), Ea(i, 1), i.m(t, null)), 32 & n && Zr(t, "opacity", e[5]), 16 & n && Zr(t, "pointer-events", e[4]), 8 & n && Zr(t, "visibility", e[3])
        }, i(e) {
            n || (Ea(i), n = !0)
        }, o(e) {
            Aa(i), n = !1
        }, d(e) {
            e && Lr(t), a[o].d()
        }
    }
}

function Eb(e, t, o) {
    let i, n, r, a, s, l, c,
        d, {isActive: u = !1} = t, {controls: h = []} = t, {locale: p} = t, {scrollElasticity: m} = t, {scrollEnable: g = !0} = t, {hideTitles: $ = !1} = t, {willRenderControls: f = Z} = t;
    const y = ca("redrawTrigger");
    pr(e, y, (e => o(16, l = e)));
    const b = ca("env");
    pr(e, b, (e => o(15, s = e)));
    const x = ca("isAnimated");
    pr(e, x, (e => o(18, d = e)));
    const v = bc(0, {stiffness: .25, damping: .9});
    return pr(e, v, (e => o(17, c = e))), e.$$set = e => {
        "isActive" in e && o(10, u = e.isActive), "controls" in e && o(11, h = e.controls), "locale" in e && o(12, p = e.locale), "scrollElasticity" in e && o(0, m = e.scrollElasticity), "scrollEnable" in e && o(1, g = e.scrollEnable), "hideTitles" in e && o(13, $ = e.hideTitles), "willRenderControls" in e && o(14, f = e.willRenderControls)
    }, e.$$.update = () => {
        263168 & e.$$.dirty && v.set(u ? 1 : 0, {hard: !1 === d}), 131072 & e.$$.dirty && o(5, i = c), 1024 & e.$$.dirty && o(4, n = u ? "auto" : "none"), 131072 & e.$$.dirty && o(3, r = c <= 0 ? "hidden" : "visible"), 129024 & e.$$.dirty && o(2, a = l && f(h.map((e => ["ShapeStyle", e.id, {
            title: e.componentProps.title,
            locale: p,
            hideTitle: $,
            items: [[e.component, e.id, e.componentProps]]
        }])), s, (() => y.set({}))))
    }, [m, g, a, r, n, i, y, b, x, v, u, h, p, $, f, s, l, c, d]
}

class Ab extends Ga {
    constructor(e) {
        super(), Ua(this, e, Eb, Ib, lr, {
            isActive: 10,
            controls: 11,
            locale: 12,
            scrollElasticity: 0,
            scrollEnable: 1,
            hideTitles: 13,
            willRenderControls: 14
        })
    }
}

function Lb(e, t, o) {
    const i = e.slice();
    return i[15] = t[o].key, i[6] = t[o].controls, i[16] = t[o].isActive, i
}

function Fb(e, t) {
    let o, i, n;
    return i = new Ab({
        props: {
            isActive: t[16],
            controls: t[6],
            locale: t[1],
            scrollElasticity: t[2],
            scrollEnable: t[3],
            hideTitles: t[4],
            willRenderControls: t[5]
        }
    }), {
        key: e, first: null, c() {
            o = Or(), Na(i.$$.fragment), this.first = o
        }, m(e, t) {
            Ar(e, o, t), Ha(i, e, t), n = !0
        }, p(e, o) {
            t = e;
            const n = {};
            128 & o && (n.isActive = t[16]), 128 & o && (n.controls = t[6]), 2 & o && (n.locale = t[1]), 4 & o && (n.scrollElasticity = t[2]), 8 & o && (n.scrollEnable = t[3]), 16 & o && (n.hideTitles = t[4]), 32 & o && (n.willRenderControls = t[5]), i.$set(n)
        }, i(e) {
            n || (Ea(i.$$.fragment, e), n = !0)
        }, o(e) {
            Aa(i.$$.fragment, e), n = !1
        }, d(e) {
            e && Lr(o), ja(i, e)
        }
    }
}

function zb(e) {
    let t, o, i, n = [], r = new Map, a = e[7];
    const s = e => e[15];
    for (let t = 0; t < a.length; t += 1) {
        let o = Lb(e, a, t), i = s(o);
        r.set(i, n[t] = Fb(i, o))
    }
    return {
        c() {
            t = Fr("div");
            for (let e = 0; e < n.length; e += 1) n[e].c();
            Nr(t, "class", o = Zc(["PinturaShapeStyleEditor", !e[3] && "PinturaShapeStyleEditorOverflow", e[0]]))
        }, m(e, o) {
            Ar(e, t, o);
            for (let e = 0; e < n.length; e += 1) n[e].m(t, null);
            i = !0
        }, p(e, [l]) {
            190 & l && (a = e[7], Ra(), n = Oa(n, l, s, 1, e, a, r, t, Ba, Fb, null, Lb), Ia()), (!i || 9 & l && o !== (o = Zc(["PinturaShapeStyleEditor", !e[3] && "PinturaShapeStyleEditorOverflow", e[0]]))) && Nr(t, "class", o)
        }, i(e) {
            if (!i) {
                for (let e = 0; e < a.length; e += 1) Ea(n[e]);
                i = !0
            }
        }, o(e) {
            for (let e = 0; e < n.length; e += 1) Aa(n[e]);
            i = !1
        }, d(e) {
            e && Lr(t);
            for (let e = 0; e < n.length; e += 1) n[e].d()
        }
    }
}

function Db(e, t, o) {
    let i, n,
        r, {class: a} = t, {controls: s = {}} = t, {shapeProps: l} = t, {onchange: c} = t, {locale: d} = t, {scrollElasticity: u} = t, {scrollEnable: p = !0} = t, {hideTitles: m = !1} = t, {willRenderControls: g} = t;
    const $ = [];
    return e.$$set = e => {
        "class" in e && o(0, a = e.class), "controls" in e && o(6, s = e.controls), "shapeProps" in e && o(8, l = e.shapeProps), "onchange" in e && o(9, c = e.onchange), "locale" in e && o(1, d = e.locale), "scrollElasticity" in e && o(2, u = e.scrollElasticity), "scrollEnable" in e && o(3, p = e.scrollEnable), "hideTitles" in e && o(4, m = e.hideTitles), "willRenderControls" in e && o(5, g = e.willRenderControls)
    }, e.$$.update = () => {
        64 & e.$$.dirty && o(11, i = Object.keys(s).filter((e => s[e]))), 2304 & e.$$.dirty && o(10, n = l && Object.keys(l).length && i && Hi(l) ? (e => i.filter((t => t.split("_").every((t => Bo(e, t) && Hi(e, t))))).map((t => {
            const o = (e.settings && e.settings[t] || {}).control || t, i = t.split("_");
            let n = i.length > 1 ? i.map((t => e[t])) : e[t];
            if (M(s[o])) {
                const {title: i, component: r} = s[o](n, (e => {
                    c({[t]: e})
                }), {selectedShapeId: e.id});
                return {id: o, component: pp, componentProps: {title: i, items: r}}
            }
            let [r, a] = s[o];
            if (h(r) && s[r]) {
                const e = {...a};
                [r, a] = s[r], a = {...a, ...e}
            }
            const l = M(a.options) ? a.options(e) : a.options;
            return "RadioGroup" === r && (a.selectedIndex = -1), a.formatValue && (n = a.formatValue(n)), {
                id: o,
                component: r,
                componentProps: {
                    ...a,
                    options: l,
                    locale: d,
                    value: n,
                    optionLabelClass: "PinturaButtonLabel",
                    onchange: o => {
                        const n = k(o) && !Oo(o) ? o.value : o;
                        a.onchange && a.onchange(n, e);
                        const r = i.length > 1 ? i.reduce(((e, t, o) => ({
                            ...e,
                            [t]: Array.isArray(n) ? n[o] : n
                        })), {}) : {[t]: n};
                        c(r)
                    }
                }
            }
        })).filter(Boolean))(l) : []), 1280 & e.$$.dirty && o(7, r = ((e, t) => {
            let o = $.find((t => t.key === e));
            return o || (o = {
                key: e,
                controls: t
            }, $.push(o)), $.forEach((e => e.isActive = !1)), o.controls = t, o.isActive = !0, $
        })(l && Object.keys(l).length ? Object.keys(l).join("_") : "none", n || []))
    }, [a, d, u, p, m, g, s, r, l, c, n, i]
}

class Bb extends Ga {
    constructor(e) {
        super(), Ua(this, e, Db, zb, lr, {
            class: 0,
            controls: 6,
            shapeProps: 8,
            onchange: 9,
            locale: 1,
            scrollElasticity: 2,
            scrollEnable: 3,
            hideTitles: 4,
            willRenderControls: 5
        })
    }
}

var Ob = e => /<svg /.test(e);

function Wb(e) {
    let t, o;
    return t = new pp({props: {items: e[10]}}), {
        c() {
            Na(t.$$.fragment)
        }, m(e, i) {
            Ha(t, e, i), o = !0
        }, p(e, o) {
            const i = {};
            1024 & o && (i.items = e[10]), t.$set(i)
        }, i(e) {
            o || (Ea(t.$$.fragment, e), o = !0)
        }, o(e) {
            Aa(t.$$.fragment, e), o = !1
        }, d(e) {
            ja(t, e)
        }
    }
}

function Vb(e) {
    let t, o, i, n;
    const r = [Nb, _b], a = [];

    function s(e, t) {
        return e[8] ? 0 : 1
    }

    return t = s(e), o = a[t] = r[t](e), {
        c() {
            o.c(), i = Or()
        }, m(e, o) {
            a[t].m(e, o), Ar(e, i, o), n = !0
        }, p(e, n) {
            let l = t;
            t = s(e), t === l ? a[t].p(e, n) : (Ra(), Aa(a[l], 1, 1, (() => {
                a[l] = null
            })), Ia(), o = a[t], o ? o.p(e, n) : (o = a[t] = r[t](e), o.c()), Ea(o, 1), o.m(i.parentNode, i))
        }, i(e) {
            n || (Ea(o), n = !0)
        }, o(e) {
            Aa(o), n = !1
        }, d(e) {
            a[t].d(e), e && Lr(i)
        }
    }
}

function _b(e) {
    let t, o, i, n, r = e[10] && Hb(e);
    return i = new Ep({
        props: {
            scrollAutoCancel: e[9],
            elasticity: e[0],
            $$slots: {default: [jb]},
            $$scope: {ctx: e}
        }
    }), {
        c() {
            t = Fr("div"), r && r.c(), o = Br(), Na(i.$$.fragment), Nr(t, "class", "PinturaShapePresetsFlat")
        }, m(e, a) {
            Ar(e, t, a), r && r.m(t, null), Rr(t, o), Ha(i, t, null), n = !0
        }, p(e, n) {
            e[10] ? r ? (r.p(e, n), 1024 & n && Ea(r, 1)) : (r = Hb(e), r.c(), Ea(r, 1), r.m(t, o)) : r && (Ra(), Aa(r, 1, 1, (() => {
                r = null
            })), Ia());
            const a = {};
            512 & n && (a.scrollAutoCancel = e[9]), 1 & n && (a.elasticity = e[0]), 536871070 & n && (a.$$scope = {
                dirty: n,
                ctx: e
            }), i.$set(a)
        }, i(e) {
            n || (Ea(r), Ea(i.$$.fragment, e), n = !0)
        }, o(e) {
            Aa(r), Aa(i.$$.fragment, e), n = !1
        }, d(e) {
            e && Lr(t), r && r.d(), ja(i)
        }
    }
}

function Nb(e) {
    let t, o, i, n, r;
    o = new Ep({
        props: {
            elasticity: e[0],
            class: "PinturaShapePresetsGroups",
            $$slots: {default: [qb]},
            $$scope: {ctx: e}
        }
    });
    const a = [{class: "PinturaControlPanels"}, {panelClass: "PinturaControlPanel"}, {panels: e[11]}, e[12]];
    let s = {
        $$slots: {
            default: [Jb, ({panel: e, panelIsActive: t}) => ({26: e, 27: t}), ({
                                                                                   panel: e,
                                                                                   panelIsActive: t
                                                                               }) => (e ? 67108864 : 0) | (t ? 134217728 : 0)]
        }, $$scope: {ctx: e}
    };
    for (let e = 0; e < a.length; e += 1) s = ir(s, a[e]);
    return n = new md({props: s}), {
        c() {
            t = Fr("div"), Na(o.$$.fragment), i = Br(), Na(n.$$.fragment), Nr(t, "class", "PinturaShapePresetsGrouped")
        }, m(e, a) {
            Ar(e, t, a), Ha(o, t, null), Rr(t, i), Ha(n, t, null), r = !0
        }, p(e, t) {
            const i = {};
            1 & t && (i.elasticity = e[0]), 536876128 & t && (i.$$scope = {dirty: t, ctx: e}), o.$set(i);
            const r = 6144 & t ? Wa(a, [a[0], a[1], 2048 & t && {panels: e[11]}, 4096 & t && Va(e[12])]) : {};
            738206239 & t && (r.$$scope = {dirty: t, ctx: e}), n.$set(r)
        }, i(e) {
            r || (Ea(o.$$.fragment, e), Ea(n.$$.fragment, e), r = !0)
        }, o(e) {
            Aa(o.$$.fragment, e), Aa(n.$$.fragment, e), r = !1
        }, d(e) {
            e && Lr(t), ja(o), ja(n)
        }
    }
}

function Hb(e) {
    let t, o;
    return t = new pp({props: {items: e[10]}}), {
        c() {
            Na(t.$$.fragment)
        }, m(e, i) {
            Ha(t, e, i), o = !0
        }, p(e, o) {
            const i = {};
            1024 & o && (i.items = e[10]), t.$set(i)
        }, i(e) {
            o || (Ea(t.$$.fragment, e), o = !0)
        }, o(e) {
            Aa(t.$$.fragment, e), o = !1
        }, d(e) {
            ja(t, e)
        }
    }
}

function jb(e) {
    let t, o;
    return t = new Ld({
        props: {
            items: e[7],
            onclickitem: e[1],
            ongrabitem: e[2],
            ondragitem: e[3],
            ondropitem: e[4]
        }
    }), {
        c() {
            Na(t.$$.fragment)
        }, m(e, i) {
            Ha(t, e, i), o = !0
        }, p(e, o) {
            const i = {};
            128 & o && (i.items = e[7]), 2 & o && (i.onclickitem = e[1]), 4 & o && (i.ongrabitem = e[2]), 8 & o && (i.ondragitem = e[3]), 16 & o && (i.ondropitem = e[4]), t.$set(i)
        }, i(e) {
            o || (Ea(t.$$.fragment, e), o = !0)
        }, o(e) {
            Aa(t.$$.fragment, e), o = !1
        }, d(e) {
            ja(t, e)
        }
    }
}

function Ub(e) {
    let t, o;
    return t = new pp({props: {items: e[10]}}), {
        c() {
            Na(t.$$.fragment)
        }, m(e, i) {
            Ha(t, e, i), o = !0
        }, p(e, o) {
            const i = {};
            1024 & o && (i.items = e[10]), t.$set(i)
        }, i(e) {
            o || (Ea(t.$$.fragment, e), o = !0)
        }, o(e) {
            Aa(t.$$.fragment, e), o = !1
        }, d(e) {
            ja(t, e)
        }
    }
}

function Gb(e) {
    let t, o;
    return t = new wd({props: {$$slots: {default: [Zb]}, $$scope: {ctx: e}}}), {
        c() {
            Na(t.$$.fragment)
        }, m(e, i) {
            Ha(t, e, i), o = !0
        }, p(e, o) {
            const i = {};
            805306368 & o && (i.$$scope = {dirty: o, ctx: e}), t.$set(i)
        }, i(e) {
            o || (Ea(t.$$.fragment, e), o = !0)
        }, o(e) {
            Aa(t.$$.fragment, e), o = !1
        }, d(e) {
            ja(t, e)
        }
    }
}

function Zb(e) {
    let t, o = e[28].icon + "";
    return {
        c() {
            t = zr("g")
        }, m(e, i) {
            Ar(e, t, i), t.innerHTML = o
        }, p(e, i) {
            268435456 & i && o !== (o = e[28].icon + "") && (t.innerHTML = o)
        }, d(e) {
            e && Lr(t)
        }
    }
}

function Xb(e) {
    let t, o, i = e[28].label + "";
    return {
        c() {
            t = Fr("span"), o = Dr(i)
        }, m(e, i) {
            Ar(e, t, i), Rr(t, o)
        }, p(e, t) {
            268435456 & t && i !== (i = e[28].label + "") && Ur(o, i)
        }, d(e) {
            e && Lr(t)
        }
    }
}

function Yb(e) {
    let t, o, i, n = e[28].icon && Gb(e), r = !e[28].hideLabel && Xb(e);
    return {
        c() {
            n && n.c(), t = Br(), r && r.c(), o = Or()
        }, m(e, a) {
            n && n.m(e, a), Ar(e, t, a), r && r.m(e, a), Ar(e, o, a), i = !0
        }, p(e, i) {
            e[28].icon ? n ? (n.p(e, i), 268435456 & i && Ea(n, 1)) : (n = Gb(e), n.c(), Ea(n, 1), n.m(t.parentNode, t)) : n && (Ra(), Aa(n, 1, 1, (() => {
                n = null
            })), Ia()), e[28].hideLabel ? r && (r.d(1), r = null) : r ? r.p(e, i) : (r = Xb(e), r.c(), r.m(o.parentNode, o))
        }, i(e) {
            i || (Ea(n), i = !0)
        }, o(e) {
            Aa(n), i = !1
        }, d(e) {
            n && n.d(e), e && Lr(t), r && r.d(e), e && Lr(o)
        }
    }
}

function qb(e) {
    let t, o, i, n = e[10] && Ub(e);
    const r = [{class: "PinturaControlList"}, {tabs: e[5]}, e[12], {layout: "compact"}];
    let a = {$$slots: {default: [Yb, ({tab: e}) => ({28: e}), ({tab: e}) => e ? 268435456 : 0]}, $$scope: {ctx: e}};
    for (let e = 0; e < r.length; e += 1) a = ir(a, r[e]);
    return o = new td({props: a}), o.$on("select", e[18]), {
        c() {
            n && n.c(), t = Br(), Na(o.$$.fragment)
        }, m(e, r) {
            n && n.m(e, r), Ar(e, t, r), Ha(o, e, r), i = !0
        }, p(e, i) {
            e[10] ? n ? (n.p(e, i), 1024 & i && Ea(n, 1)) : (n = Ub(e), n.c(), Ea(n, 1), n.m(t.parentNode, t)) : n && (Ra(), Aa(n, 1, 1, (() => {
                n = null
            })), Ia());
            const a = 4128 & i ? Wa(r, [r[0], 32 & i && {tabs: e[5]}, 4096 & i && Va(e[12]), r[3]]) : {};
            805306368 & i && (a.$$scope = {dirty: i, ctx: e}), o.$set(a)
        }, i(e) {
            i || (Ea(n), Ea(o.$$.fragment, e), i = !0)
        }, o(e) {
            Aa(n), Aa(o.$$.fragment, e), i = !1
        }, d(e) {
            n && n.d(e), e && Lr(t), ja(o, e)
        }
    }
}

function Kb(e) {
    let t, o;
    return t = new Ld({
        props: {
            items: e[13][e[26]].items,
            disabled: e[13][e[26]].disabled,
            onclickitem: e[1],
            ongrabitem: e[2],
            ondragitem: e[3],
            ondropitem: e[4]
        }
    }), {
        c() {
            Na(t.$$.fragment)
        }, m(e, i) {
            Ha(t, e, i), o = !0
        }, p(e, o) {
            const i = {};
            67117056 & o && (i.items = e[13][e[26]].items), 67117056 & o && (i.disabled = e[13][e[26]].disabled), 2 & o && (i.onclickitem = e[1]), 4 & o && (i.ongrabitem = e[2]), 8 & o && (i.ondragitem = e[3]), 16 & o && (i.ondropitem = e[4]), t.$set(i)
        }, i(e) {
            o || (Ea(t.$$.fragment, e), o = !0)
        }, o(e) {
            Aa(t.$$.fragment, e), o = !1
        }, d(e) {
            ja(t, e)
        }
    }
}

function Jb(e) {
    let t, o;
    return t = new Ep({
        props: {
            scroll: e[27] ? {scrollOffset: 0, animate: !1} : void 0,
            scrollAutoCancel: e[9],
            elasticity: e[0],
            $$slots: {default: [Kb]},
            $$scope: {ctx: e}
        }
    }), {
        c() {
            Na(t.$$.fragment)
        }, m(e, i) {
            Ha(t, e, i), o = !0
        }, p(e, o) {
            const i = {};
            134217728 & o && (i.scroll = e[27] ? {
                scrollOffset: 0,
                animate: !1
            } : void 0), 512 & o && (i.scrollAutoCancel = e[9]), 1 & o && (i.elasticity = e[0]), 603987998 & o && (i.$$scope = {
                dirty: o,
                ctx: e
            }), t.$set(i)
        }, i(e) {
            o || (Ea(t.$$.fragment, e), o = !0)
        }, o(e) {
            Aa(t.$$.fragment, e), o = !1
        }, d(e) {
            ja(t, e)
        }
    }
}

function Qb(e) {
    let t, o, i, n;
    const r = [Vb, Wb], a = [];

    function s(e, t) {
        return e[9] ? 0 : e[10] ? 1 : -1
    }

    return ~(o = s(e)) && (i = a[o] = r[o](e)), {
        c() {
            t = Fr("div"), i && i.c(), Nr(t, "class", "PinturaShapePresetsPalette")
        }, m(e, i) {
            Ar(e, t, i), ~o && a[o].m(t, null), n = !0
        }, p(e, [n]) {
            let l = o;
            o = s(e), o === l ? ~o && a[o].p(e, n) : (i && (Ra(), Aa(a[l], 1, 1, (() => {
                a[l] = null
            })), Ia()), ~o ? (i = a[o], i ? i.p(e, n) : (i = a[o] = r[o](e), i.c()), Ea(i, 1), i.m(t, null)) : i = null)
        }, i(e) {
            n || (Ea(i), n = !0)
        }, o(e) {
            Aa(i), n = !1
        }, d(e) {
            e && Lr(t), ~o && a[o].d()
        }
    }
}

function ex(e, t, o) {
    let n, r, a, s, l, c, d, u,
        p, {locale: m} = t, {presets: g} = t, {scrollElasticity: $} = t, {enableSelectImage: f = !0} = t, {willRenderPresetToolbar: y = Z} = t, {onaddpreset: b = i} = t, {ongrabpreset: x} = t, {ondragpreset: v} = t, {ondroppreset: w} = t;
    const S = "presets-" + E(), k = (e, t = "") => Ob(e) ? e : Do(e) ? Ho(e, t) : `<img src="${e}" alt="${t}"/>`,
        C = e => N(Ut(e)), T = ["src", "alt", "thumb", "shape", "id", "mount", "disabled"],
        M = e => e.map((e => (e => Oo(e) && h(e[0]) && Oo(e[1]))(e) ? {
            ...e[2],
            id: `${S}-${e[0].toLowerCase()}`,
            label: e[0],
            items: M(e[1])
        } : (e => {
            let t, o, i, n, r, a, s, l = e;
            return h(e) ? Do(e) ? (t = e, r = e, n = k(t, r)) : (t = e, r = C(t), n = k(t, r)) : (t = e.src, r = e.alt || (h(t) ? C(t) : h(e.thumb) ? C(e.thumb) : void 0), n = k(e.thumb || t, r), o = e.shape, a = e.mount, s = e.disabled, i = Object.keys(e).reduce(((t, o) => (T.includes(o) || (t[o] = e[o]), t)), {})), {
                id: l,
                src: t,
                thumb: n,
                shape: o,
                shapeProps: i,
                alt: r,
                title: r,
                mount: a,
                disabled: s
            }
        })(e)));
    return e.$$set = e => {
        "locale" in e && o(14, m = e.locale), "presets" in e && o(15, g = e.presets), "scrollElasticity" in e && o(0, $ = e.scrollElasticity), "enableSelectImage" in e && o(16, f = e.enableSelectImage), "willRenderPresetToolbar" in e && o(17, y = e.willRenderPresetToolbar), "onaddpreset" in e && o(1, b = e.onaddpreset), "ongrabpreset" in e && o(2, x = e.ongrabpreset), "ondragpreset" in e && o(3, v = e.ondragpreset), "ondroppreset" in e && o(4, w = e.ondroppreset)
    }, e.$$.update = () => {
        32768 & e.$$.dirty && o(7, n = M(g)), 128 & e.$$.dirty && o(9, r = n.length), 640 & e.$$.dirty && o(8, a = r && n.some((e => !!e.items))), 384 & e.$$.dirty && o(5, s = a && n), 384 & e.$$.dirty && o(13, l = a && n.reduce(((e, t) => (e[t.id] = t, e)), {})), 96 & e.$$.dirty && o(6, c = c || s && (s.find((e => !e.disabled)) || {}).id), 64 & e.$$.dirty && o(12, d = {
            name: S,
            selected: c
        }), 32 & e.$$.dirty && o(11, u = s && s.map((e => e.id))), 212994 & e.$$.dirty && o(10, p = m && y([f && ["Button", "browse", {
            label: m.shapeLabelButtonSelectSticker,
            icon: m.shapeIconButtonSelectSticker,
            onclick: () => {
                sm().then((e => {
                    e && b(e)
                }))
            }
        }]]))
    }, [$, b, x, v, w, s, c, n, a, r, p, u, d, l, m, g, f, y, ({detail: e}) => o(6, c = e)]
}

class tx extends Ga {
    constructor(e) {
        super(), Ua(this, e, ex, Qb, lr, {
            locale: 14,
            presets: 15,
            scrollElasticity: 0,
            enableSelectImage: 16,
            willRenderPresetToolbar: 17,
            onaddpreset: 1,
            ongrabpreset: 2,
            ondragpreset: 3,
            ondroppreset: 4
        })
    }
}

function ox(e) {
    let t, o, i, n;
    return t = new pp({props: {items: e[30]}}), i = new Bb({
        props: {
            locale: e[4],
            shapeProps: e[49],
            onchange: e[85],
            controls: e[9],
            scrollEnable: !1,
            hideTitles: !0,
            willRenderControls: e[165]
        }
    }), {
        c() {
            Na(t.$$.fragment), o = Br(), Na(i.$$.fragment)
        }, m(e, r) {
            Ha(t, e, r), Ar(e, o, r), Ha(i, e, r), n = !0
        }, p(e, o) {
            const n = {};
            1073741824 & o[0] && (n.items = e[30]), t.$set(n);
            const r = {};
            16 & o[0] && (r.locale = e[4]), 262144 & o[1] && (r.shapeProps = e[49]), 512 & o[0] && (r.controls = e[9]), i.$set(r)
        }, i(e) {
            n || (Ea(t.$$.fragment, e), Ea(i.$$.fragment, e), n = !0)
        }, o(e) {
            Aa(t.$$.fragment, e), Aa(i.$$.fragment, e), n = !1
        }, d(e) {
            ja(t, e), e && Lr(o), ja(i, e)
        }
    }
}

function ix(e) {
    let t, o, i;
    return o = new Cf({props: {$$slots: {default: [ox]}, $$scope: {ctx: e}}}), {
        c() {
            t = Fr("div"), Na(o.$$.fragment), Nr(t, "slot", "header")
        }, m(e, n) {
            Ar(e, t, n), Ha(o, t, null), i = !0
        }, p(e, t) {
            const i = {};
            1073742352 & t[0] | 262144 & t[1] | 134217728 & t[6] && (i.$$scope = {dirty: t, ctx: e}), o.$set(i)
        }, i(e) {
            i || (Ea(o.$$.fragment, e), i = !0)
        }, o(e) {
            Aa(o.$$.fragment, e), i = !1
        }, d(e) {
            e && Lr(t), ja(o)
        }
    }
}

function nx(e) {
    let t, o;
    const i = [{locale: e[4]}, {ui: e[69]}, {shapes: e[5]}, {selection: e[58]}, {uid: e[20]}, {parentRect: e[37]}, {rootRect: e[55]}, {utilRect: e[39]}, {offset: e[50]}, {disabled: e[38]}, {contextRotation: e[23]}, {contextFlipX: e[24]}, {contextFlipY: e[25]}, {contextZoom: e[36] ? e[36].scale : void 0}, {active: e[35]}, {opacity: e[56]}, {hoverColor: e[57]}, {caretColor: e[57]}, {snapColor: e[57]}, {gridColor: [1, 1, 1, .125]}, {eraseRadius: e[47]}, {selectRadius: e[6]}, {enableButtonFlipVertical: e[10]}, {enableMultiSelect: e[14]}, {mapEditorPointToImagePoint: e[21]}, {mapImagePointToEditorPoint: e[22]}, {enableTapToAddText: e[13]}, {textInputMode: e[8]}, {snapThreshold: e[16]}, {snapPointer: !e[48]}, {enableSnapToContext: e[17]}, {gridSize: e[15]}, {willStartInteraction: e[95]}, {oninteractionstart: e[79]}, {oninteractionupdate: e[80]}, {oninteractionrelease: e[81]}, {oninteractionend: e[83]}, {oninteractioncancel: e[82]}, {onleavecanvas: e[87]}, {onhovercanvas: e[86]}, {onhovershape: e[89]}, {ontapcanvas: e[88]}, {onaddshape: e[156]}, {onselectshape: e[157]}, {onblurshape: e[158]}, {ontapshape: e[159]}, {onupdateshape: e[160]}, {onremoveshape: e[161]}, {ontriggerhistorywrite: e[162]}, e[42]];
    let n = {};
    for (let e = 0; e < i.length; e += 1) n = ir(n, i[e]);
    return t = new Tb({props: n}), e[163](t), {
        c() {
            Na(t.$$.fragment)
        }, m(e, i) {
            Ha(t, e, i), o = !0
        }, p(e, o) {
            const n = 66315632 & o[0] | 252381681 & o[1] | 255721600 & o[2] | 12 & o[3] ? Wa(i, [16 & o[0] && {locale: e[4]}, 128 & o[2] && {ui: e[69]}, 32 & o[0] && {shapes: e[5]}, 134217728 & o[1] && {selection: e[58]}, 1048576 & o[0] && {uid: e[20]}, 64 & o[1] && {parentRect: e[37]}, 16777216 & o[1] && {rootRect: e[55]}, 256 & o[1] && {utilRect: e[39]}, 524288 & o[1] && {offset: e[50]}, 128 & o[1] && {disabled: e[38]}, 8388608 & o[0] && {contextRotation: e[23]}, 16777216 & o[0] && {contextFlipX: e[24]}, 33554432 & o[0] && {contextFlipY: e[25]}, 32 & o[1] && {contextZoom: e[36] ? e[36].scale : void 0}, 16 & o[1] && {active: e[35]}, 33554432 & o[1] && {opacity: e[56]}, 67108864 & o[1] && {hoverColor: e[57]}, 67108864 & o[1] && {caretColor: e[57]}, 67108864 & o[1] && {snapColor: e[57]}, i[19], 65536 & o[1] && {eraseRadius: e[47]}, 64 & o[0] && {selectRadius: e[6]}, 1024 & o[0] && {enableButtonFlipVertical: e[10]}, 16384 & o[0] && {enableMultiSelect: e[14]}, 2097152 & o[0] && {mapEditorPointToImagePoint: e[21]}, 4194304 & o[0] && {mapImagePointToEditorPoint: e[22]}, 8192 & o[0] && {enableTapToAddText: e[13]}, 256 & o[0] && {textInputMode: e[8]}, 65536 & o[0] && {snapThreshold: e[16]}, 131072 & o[1] && {snapPointer: !e[48]}, 131072 & o[0] && {enableSnapToContext: e[17]}, 32768 & o[0] && {gridSize: e[15]}, 4 & o[3] && {willStartInteraction: e[95]}, 131072 & o[2] && {oninteractionstart: e[79]}, 262144 & o[2] && {oninteractionupdate: e[80]}, 524288 & o[2] && {oninteractionrelease: e[81]}, 2097152 & o[2] && {oninteractionend: e[83]}, 1048576 & o[2] && {oninteractioncancel: e[82]}, 33554432 & o[2] && {onleavecanvas: e[87]}, 16777216 & o[2] && {onhovercanvas: e[86]}, 134217728 & o[2] && {onhovershape: e[89]}, 67108864 & o[2] && {ontapcanvas: e[88]}, 1 & o[1] | 8 & o[3] && {onaddshape: e[156]}, 1 & o[1] && {onselectshape: e[157]}, 1 & o[1] && {onblurshape: e[158]}, 1 & o[1] && {ontapshape: e[159]}, 1 & o[1] | 8 & o[3] && {onupdateshape: e[160]}, 1 & o[1] | 8 & o[3] && {onremoveshape: e[161]}, 8 & o[3] && {ontriggerhistorywrite: e[162]}, 2048 & o[1] && Va(e[42])]) : {};
            t.$set(n)
        }, i(e) {
            o || (Ea(t.$$.fragment, e), o = !0)
        }, o(e) {
            Aa(t.$$.fragment, e), o = !1
        }, d(o) {
            e[163](null), ja(t, o)
        }
    }
}

function rx(e) {
    let t, o, n, r, a = e[51] && nx(e);
    return {
        c() {
            t = Fr("div"), a && a.c(), Nr(t, "slot", "main"), Zr(t, "cursor", e[46])
        }, m(s, l) {
            Ar(s, t, l), a && a.m(t, null), e[164](t), o = !0, n || (r = [Wr(t, "keydown", e[84]), wr(Wc.call(null, t)), Wr(t, "dropfiles", (function () {
                sr(e[12] ? e[94] : i) && (e[12] ? e[94] : i).apply(this, arguments)
            })), wr(zc.call(null, t)), Wr(t, "measure", e[152])], n = !0)
        }, p(o, i) {
            (e = o)[51] ? a ? (a.p(e, i), 1048576 & i[1] && Ea(a, 1)) : (a = nx(e), a.c(), Ea(a, 1), a.m(t, null)) : a && (Ra(), Aa(a, 1, 1, (() => {
                a = null
            })), Ia()), 32768 & i[1] && Zr(t, "cursor", e[46])
        }, i(e) {
            o || (Ea(a), o = !0)
        }, o(e) {
            Aa(a), o = !1
        }, d(o) {
            o && Lr(t), a && a.d(), e[164](null), n = !1, ar(r)
        }
    }
}

function ax(e) {
    let t, o;
    return t = new tx({
        props: {
            locale: e[4],
            presets: e[19],
            enableSelectImage: e[11],
            willRenderPresetToolbar: e[43],
            onaddpreset: e[93],
            ongrabpreset: e[90],
            ondragpreset: e[91],
            ondroppreset: e[92],
            scrollElasticity: e[44]
        }
    }), {
        c() {
            Na(t.$$.fragment)
        }, m(e, i) {
            Ha(t, e, i), o = !0
        }, p(e, o) {
            const i = {};
            16 & o[0] && (i.locale = e[4]), 524288 & o[0] && (i.presets = e[19]), 2048 & o[0] && (i.enableSelectImage = e[11]), 4096 & o[1] && (i.willRenderPresetToolbar = e[43]), 8192 & o[1] && (i.scrollElasticity = e[44]), t.$set(i)
        }, i(e) {
            o || (Ea(t.$$.fragment, e), o = !0)
        }, o(e) {
            Aa(t.$$.fragment, e), o = !1
        }, d(e) {
            ja(t, e)
        }
    }
}

function sx(e) {
    let t, o, i, n = "stack" === e[7] && lx(e), r = (e[53] && e[34] || "row" === e[7]) && ux(e);
    return {
        c() {
            n && n.c(), t = Br(), r && r.c(), o = Or()
        }, m(e, a) {
            n && n.m(e, a), Ar(e, t, a), r && r.m(e, a), Ar(e, o, a), i = !0
        }, p(e, i) {
            "stack" === e[7] ? n ? (n.p(e, i), 128 & i[0] && Ea(n, 1)) : (n = lx(e), n.c(), Ea(n, 1), n.m(t.parentNode, t)) : n && (Ra(), Aa(n, 1, 1, (() => {
                n = null
            })), Ia()), e[53] && e[34] || "row" === e[7] ? r ? (r.p(e, i), 128 & i[0] | 4194312 & i[1] && Ea(r, 1)) : (r = ux(e), r.c(), Ea(r, 1), r.m(o.parentNode, o)) : r && (Ra(), Aa(r, 1, 1, (() => {
                r = null
            })), Ia())
        }, i(e) {
            i || (Ea(n), Ea(r), i = !0)
        }, o(e) {
            Aa(n), Aa(r), i = !1
        }, d(e) {
            n && n.d(e), e && Lr(t), r && r.d(e), e && Lr(o)
        }
    }
}

function lx(e) {
    let t, o, i, n;
    const r = [dx, cx], a = [];

    function s(e, t) {
        return e[45] ? 0 : 1
    }

    return o = s(e), i = a[o] = r[o](e), {
        c() {
            t = Fr("div"), i.c(), Nr(t, "class", "PinturaControlPanels")
        }, m(e, i) {
            Ar(e, t, i), a[o].m(t, null), n = !0
        }, p(e, n) {
            let l = o;
            o = s(e), o === l ? a[o].p(e, n) : (Ra(), Aa(a[l], 1, 1, (() => {
                a[l] = null
            })), Ia(), i = a[o], i ? i.p(e, n) : (i = a[o] = r[o](e), i.c()), Ea(i, 1), i.m(t, null))
        }, i(e) {
            n || (Ea(i), n = !0)
        }, o(e) {
            Aa(i), n = !1
        }, d(e) {
            e && Lr(t), a[o].d()
        }
    }
}

function cx(e) {
    let t, o, i;
    return o = new Bb({
        props: {
            locale: e[4],
            shapeProps: e[49],
            onchange: e[85],
            controls: e[9],
            scrollElasticity: e[44],
            willRenderControls: e[18]
        }
    }), {
        c() {
            t = Fr("div"), Na(o.$$.fragment), Nr(t, "class", "PinturaControlPanel")
        }, m(e, n) {
            Ar(e, t, n), Ha(o, t, null), i = !0
        }, p(e, t) {
            const i = {};
            16 & t[0] && (i.locale = e[4]), 262144 & t[1] && (i.shapeProps = e[49]), 512 & t[0] && (i.controls = e[9]), 8192 & t[1] && (i.scrollElasticity = e[44]), 262144 & t[0] && (i.willRenderControls = e[18]), o.$set(i)
        }, i(e) {
            i || (Ea(o.$$.fragment, e), i = !0)
        }, o(e) {
            Aa(o.$$.fragment, e), i = !1
        }, d(e) {
            e && Lr(t), ja(o)
        }
    }
}

function dx(e) {
    let t, o, i;
    return o = new tx({
        props: {
            locale: e[4],
            presets: e[19],
            enableSelectImage: e[11],
            willRenderPresetToolbar: e[43],
            onaddpreset: e[93],
            ongrabpreset: e[90],
            ondragpreset: e[91],
            ondroppreset: e[92],
            scrollElasticity: e[44]
        }
    }), {
        c() {
            t = Fr("div"), Na(o.$$.fragment), Nr(t, "class", "PinturaControlPanel")
        }, m(e, n) {
            Ar(e, t, n), Ha(o, t, null), i = !0
        }, p(e, t) {
            const i = {};
            16 & t[0] && (i.locale = e[4]), 524288 & t[0] && (i.presets = e[19]), 2048 & t[0] && (i.enableSelectImage = e[11]), 4096 & t[1] && (i.willRenderPresetToolbar = e[43]), 8192 & t[1] && (i.scrollElasticity = e[44]), o.$set(i)
        }, i(e) {
            i || (Ea(o.$$.fragment, e), i = !0)
        }, o(e) {
            Aa(o.$$.fragment, e), i = !1
        }, d(e) {
            e && Lr(t), ja(o)
        }
    }
}

function ux(e) {
    let t, o;
    return t = new Ep({
        props: {
            class: "PinturaControlListScroller",
            elasticity: e[44],
            $$slots: {default: [yx]},
            $$scope: {ctx: e}
        }
    }), {
        c() {
            Na(t.$$.fragment)
        }, m(e, i) {
            Ha(t, e, i), o = !0
        }, p(e, o) {
            const i = {};
            8192 & o[1] && (i.elasticity = e[44]), 262801 & o[0] | 262154 & o[1] | 134217728 & o[6] && (i.$$scope = {
                dirty: o,
                ctx: e
            }), t.$set(i)
        }, i(e) {
            o || (Ea(t.$$.fragment, e), o = !0)
        }, o(e) {
            Aa(t.$$.fragment, e), o = !1
        }, d(e) {
            ja(t, e)
        }
    }
}

function hx(e) {
    let t, o;
    return t = new Eu({
        props: {
            locale: e[4],
            class: "PinturaControlList",
            optionClass: "PinturaControlListOption",
            layout: "row",
            options: e[32],
            selectedIndex: e[32].findIndex(e[153]),
            onchange: e[78],
            $$slots: {option: [$x, ({option: e}) => ({212: e}), ({option: e}) => [0, 0, 0, 0, 0, 0, e ? 67108864 : 0]]},
            $$scope: {ctx: e}
        }
    }), {
        c() {
            Na(t.$$.fragment)
        }, m(e, i) {
            Ha(t, e, i), o = !0
        }, p(e, o) {
            const i = {};
            16 & o[0] && (i.locale = e[4]), 2 & o[1] && (i.options = e[32]), 1 & o[0] | 2 & o[1] && (i.selectedIndex = e[32].findIndex(e[153])), 16 & o[0] | 201326592 & o[6] && (i.$$scope = {
                dirty: o,
                ctx: e
            }), t.$set(i)
        }, i(e) {
            o || (Ea(t.$$.fragment, e), o = !0)
        }, o(e) {
            Aa(t.$$.fragment, e), o = !1
        }, d(e) {
            ja(t, e)
        }
    }
}

function px(e) {
    let t, o;
    return t = new wd({props: {$$slots: {default: [mx]}, $$scope: {ctx: e}}}), {
        c() {
            Na(t.$$.fragment)
        }, m(e, i) {
            Ha(t, e, i), o = !0
        }, p(e, o) {
            const i = {};
            16 & o[0] | 201326592 & o[6] && (i.$$scope = {dirty: o, ctx: e}), t.$set(i)
        }, i(e) {
            o || (Ea(t.$$.fragment, e), o = !0)
        }, o(e) {
            Aa(t.$$.fragment, e), o = !1
        }, d(e) {
            ja(t, e)
        }
    }
}

function mx(e) {
    let t, o = (M(e[212].icon) ? e[212].icon(e[4]) : e[212].icon) + "";
    return {
        c() {
            t = zr("g")
        }, m(e, i) {
            Ar(e, t, i), t.innerHTML = o
        }, p(e, i) {
            16 & i[0] | 67108864 & i[6] && o !== (o = (M(e[212].icon) ? e[212].icon(e[4]) : e[212].icon) + "") && (t.innerHTML = o)
        }, d(e) {
            e && Lr(t)
        }
    }
}

function gx(e) {
    let t, o, i = (M(e[212].label) ? e[212].label(e[4]) : e[212].label) + "";
    return {
        c() {
            t = Fr("span"), o = Dr(i)
        }, m(e, i) {
            Ar(e, t, i), Rr(t, o)
        }, p(e, t) {
            16 & t[0] | 67108864 & t[6] && i !== (i = (M(e[212].label) ? e[212].label(e[4]) : e[212].label) + "") && Ur(o, i)
        }, d(e) {
            e && Lr(t)
        }
    }
}

function $x(e) {
    let t, o, i, n = e[212].icon && px(e), r = !e[212].hideLabel && gx(e);
    return {
        c() {
            t = Fr("div"), n && n.c(), o = Br(), r && r.c(), Nr(t, "slot", "option")
        }, m(e, a) {
            Ar(e, t, a), n && n.m(t, null), Rr(t, o), r && r.m(t, null), i = !0
        }, p(e, i) {
            e[212].icon ? n ? (n.p(e, i), 67108864 & i[6] && Ea(n, 1)) : (n = px(e), n.c(), Ea(n, 1), n.m(t, o)) : n && (Ra(), Aa(n, 1, 1, (() => {
                n = null
            })), Ia()), e[212].hideLabel ? r && (r.d(1), r = null) : r ? r.p(e, i) : (r = gx(e), r.c(), r.m(t, null))
        }, i(e) {
            i || (Ea(n), i = !0)
        }, o(e) {
            Aa(n), i = !1
        }, d(e) {
            e && Lr(t), n && n.d(), r && r.d()
        }
    }
}

function fx(e) {
    let t, o;
    return t = new Bb({
        props: {
            locale: e[4],
            shapeProps: e[49],
            onchange: e[85],
            controls: e[9],
            scrollEnable: !1,
            hideTitles: !0,
            willRenderControls: e[154]
        }
    }), {
        c() {
            Na(t.$$.fragment)
        }, m(e, i) {
            Ha(t, e, i), o = !0
        }, p(e, o) {
            const i = {};
            16 & o[0] && (i.locale = e[4]), 262144 & o[1] && (i.shapeProps = e[49]), 512 & o[0] && (i.controls = e[9]), 262144 & o[0] && (i.willRenderControls = e[154]), t.$set(i)
        }, i(e) {
            o || (Ea(t.$$.fragment, e), o = !0)
        }, o(e) {
            Aa(t.$$.fragment, e), o = !1
        }, d(e) {
            ja(t, e)
        }
    }
}

function yx(e) {
    let t, o, i, n = e[34] && hx(e), r = "row" === e[7] && fx(e);
    return {
        c() {
            n && n.c(), t = Br(), r && r.c(), o = Or()
        }, m(e, a) {
            n && n.m(e, a), Ar(e, t, a), r && r.m(e, a), Ar(e, o, a), i = !0
        }, p(e, i) {
            e[34] ? n ? (n.p(e, i), 8 & i[1] && Ea(n, 1)) : (n = hx(e), n.c(), Ea(n, 1), n.m(t.parentNode, t)) : n && (Ra(), Aa(n, 1, 1, (() => {
                n = null
            })), Ia()), "row" === e[7] ? r ? (r.p(e, i), 128 & i[0] && Ea(r, 1)) : (r = fx(e), r.c(), Ea(r, 1), r.m(o.parentNode, o)) : r && (Ra(), Aa(r, 1, 1, (() => {
                r = null
            })), Ia())
        }, i(e) {
            i || (Ea(n), Ea(r), i = !0)
        }, o(e) {
            Aa(n), Aa(r), i = !1
        }, d(e) {
            n && n.d(e), e && Lr(t), r && r.d(e), e && Lr(o)
        }
    }
}

function bx(e) {
    let t, o;
    return t = new Ep({
        props: {
            class: "PinturaControlListScroller",
            elasticity: e[44],
            $$slots: {default: [Sx]},
            $$scope: {ctx: e}
        }
    }), {
        c() {
            Na(t.$$.fragment)
        }, m(e, i) {
            Ha(t, e, i), o = !0
        }, p(e, o) {
            const i = {};
            8192 & o[1] && (i.elasticity = e[44]), 134217744 & o[0] | 8388608 & o[1] | 134217728 & o[6] && (i.$$scope = {
                dirty: o,
                ctx: e
            }), t.$set(i)
        }, i(e) {
            o || (Ea(t.$$.fragment, e), o = !0)
        }, o(e) {
            Aa(t.$$.fragment, e), o = !1
        }, d(e) {
            ja(t, e)
        }
    }
}

function xx(e) {
    let t, o;
    return t = new wd({props: {$$slots: {default: [vx]}, $$scope: {ctx: e}}}), {
        c() {
            Na(t.$$.fragment)
        }, m(e, i) {
            Ha(t, e, i), o = !0
        }, p(e, o) {
            const i = {};
            16 & o[0] | 201326592 & o[6] && (i.$$scope = {dirty: o, ctx: e}), t.$set(i)
        }, i(e) {
            o || (Ea(t.$$.fragment, e), o = !0)
        }, o(e) {
            Aa(t.$$.fragment, e), o = !1
        }, d(e) {
            ja(t, e)
        }
    }
}

function vx(e) {
    let t, o = (M(e[212].icon) ? e[212].icon(e[4]) : e[212].icon) + "";
    return {
        c() {
            t = zr("g")
        }, m(e, i) {
            Ar(e, t, i), t.innerHTML = o
        }, p(e, i) {
            16 & i[0] | 67108864 & i[6] && o !== (o = (M(e[212].icon) ? e[212].icon(e[4]) : e[212].icon) + "") && (t.innerHTML = o)
        }, d(e) {
            e && Lr(t)
        }
    }
}

function wx(e) {
    let t, o, i, n, r, a = (M(e[212].label) ? e[212].label(e[4]) : e[212].label) + "", s = e[212].icon && xx(e);
    return {
        c() {
            t = Fr("div"), s && s.c(), o = Br(), i = Fr("span"), n = Dr(a), Nr(t, "slot", "option")
        }, m(e, a) {
            Ar(e, t, a), s && s.m(t, null), Rr(t, o), Rr(t, i), Rr(i, n), r = !0
        }, p(e, i) {
            e[212].icon ? s ? (s.p(e, i), 67108864 & i[6] && Ea(s, 1)) : (s = xx(e), s.c(), Ea(s, 1), s.m(t, o)) : s && (Ra(), Aa(s, 1, 1, (() => {
                s = null
            })), Ia()), (!r || 16 & i[0] | 67108864 & i[6]) && a !== (a = (M(e[212].label) ? e[212].label(e[4]) : e[212].label) + "") && Ur(n, a)
        }, i(e) {
            r || (Ea(s), r = !0)
        }, o(e) {
            Aa(s), r = !1
        }, d(e) {
            e && Lr(t), s && s.d()
        }
    }
}

function Sx(e) {
    let t, o;
    return t = new Eu({
        props: {
            locale: e[4],
            class: "PinturaControlList",
            optionClass: "PinturaControlListOption",
            layout: "row",
            options: e[54],
            selectedIndex: e[54].findIndex(e[155]),
            onchange: e[77],
            $$slots: {option: [wx, ({option: e}) => ({212: e}), ({option: e}) => [0, 0, 0, 0, 0, 0, e ? 67108864 : 0]]},
            $$scope: {ctx: e}
        }
    }), {
        c() {
            Na(t.$$.fragment)
        }, m(e, i) {
            Ha(t, e, i), o = !0
        }, p(e, o) {
            const i = {};
            16 & o[0] && (i.locale = e[4]), 8388608 & o[1] && (i.options = e[54]), 134217728 & o[0] | 8388608 & o[1] && (i.selectedIndex = e[54].findIndex(e[155])), 16 & o[0] | 201326592 & o[6] && (i.$$scope = {
                dirty: o,
                ctx: e
            }), t.$set(i)
        }, i(e) {
            o || (Ea(t.$$.fragment, e), o = !0)
        }, o(e) {
            Aa(t.$$.fragment, e), o = !1
        }, d(e) {
            ja(t, e)
        }
    }
}

function kx(e) {
    let t, o, i, n, r;
    const a = [sx, ax], s = [];

    function l(e, t) {
        return e[52] ? 0 : e[45] ? 1 : -1
    }

    ~(o = l(e)) && (i = s[o] = a[o](e));
    let c = e[33] && bx(e);
    return {
        c() {
            t = Fr("div"), i && i.c(), n = Br(), c && c.c(), Nr(t, "slot", "footer"), Zr(t, "transform", e[40])
        }, m(e, i) {
            Ar(e, t, i), ~o && s[o].m(t, null), Rr(t, n), c && c.m(t, null), r = !0
        }, p(e, r) {
            let d = o;
            o = l(e), o === d ? ~o && s[o].p(e, r) : (i && (Ra(), Aa(s[d], 1, 1, (() => {
                s[d] = null
            })), Ia()), ~o ? (i = s[o], i ? i.p(e, r) : (i = s[o] = a[o](e), i.c()), Ea(i, 1), i.m(t, n)) : i = null), e[33] ? c ? (c.p(e, r), 4 & r[1] && Ea(c, 1)) : (c = bx(e), c.c(), Ea(c, 1), c.m(t, null)) : c && (Ra(), Aa(c, 1, 1, (() => {
                c = null
            })), Ia()), 512 & r[1] && Zr(t, "transform", e[40])
        }, i(e) {
            r || (Ea(i), Ea(c), r = !0)
        }, o(e) {
            Aa(i), Aa(c), r = !1
        }, d(e) {
            e && Lr(t), ~o && s[o].d(), c && c.d()
        }
    }
}

function Cx(e) {
    let t, o;
    return t = new Wf({
        props: {
            hasHeader: e[41],
            $$slots: {footer: [kx], main: [rx], header: [ix]},
            $$scope: {ctx: e}
        }
    }), t.$on("measure", e[166]), {
        c() {
            Na(t.$$.fragment)
        }, m(e, i) {
            Ha(t, e, i), o = !0
        }, p(e, o) {
            const i = {};
            1024 & o[1] && (i.hasHeader = e[41]), 2080374769 & o[0] | 134216703 & o[1] | 134217728 & o[6] && (i.$$scope = {
                dirty: o,
                ctx: e
            }), t.$set(i)
        }, i(e) {
            o || (Ea(t.$$.fragment, e), o = !0)
        }, o(e) {
            Aa(t.$$.fragment, e), o = !1
        }, d(e) {
            ja(t, e)
        }
    }
}

function Tx(e, t, o) {
    let i, n, r, a, s, l, c, d, u, p, m, g, $, f, y, b, x, v, w, S, k, C, T, M, P, R, I, E, A, L, F, z, D, B, O, W, V,
        _, N, H, j, U, G, X, Y, q, K, J, Q, ee, te, oe, ie, ne, re, ae, se, le, ce, de, ue, pe, me, ge, $e, fe, ye, be,
        xe = tr, ve = () => (xe(), xe = ur(Ae, (e => o(35, Y = e))), Ae), we = tr,
        Se = () => (we(), we = ur(Be, (e => o(145, Q = e))), Be), ke = tr,
        Ce = () => (ke(), ke = ur(ft, (e => o(37, ae = e))), ft), Te = tr,
        Me = () => (Te(), Te = ur(Fe, (e => o(151, ge = e))), Fe), Pe = tr,
        Ie = () => (Pe(), Pe = ur(Le, (e => o(56, ye = e))), Le);
    e.$$.on_destroy.push((() => xe())), e.$$.on_destroy.push((() => we())), e.$$.on_destroy.push((() => ke())), e.$$.on_destroy.push((() => Te())), e.$$.on_destroy.push((() => Pe()));
    let {isActive: Ae} = t;
    ve();
    let {isActiveFraction: Le} = t;
    Ie();
    let {isVisible: Fe} = t;
    Me();
    let {stores: ze} = t, {locale: De = {}} = t, {shapes: Be} = t;
    Se();
    let {toolbar: Oe = []} = t, {toolShapes: We = {}} = t, {toolActive: Ve} = t, {toolSelectRadius: _e} = t, {toolRetainStyles: Ne = !1} = t, {toolbarLayout: He = "stack"} = t, {textInputMode: je} = t, {shapeControls: Ue = {}} = t, {enableButtonFlipVertical: Ge = !1} = t, {enablePresetSelectImage: Ze = !0} = t, {enablePresetDropImage: Xe = !0} = t, {enableSelectToolToAddShape: Ye = !1} = t, {enableAutoSelectMoveTool: qe = ["line", "arrow", "path", "rectangle", "ellipse", "text"]} = t, {enableTapToAddText: Ke = !1} = t, {enableMoveTool: Je = !1} = t, {enableViewTool: Qe = !1} = t, {enableToolShareStyles: et = !0} = t, {enableMultiSelect: tt = !1} = t, {gridSize: ot = 0} = t, {snapThreshold: it = 0} = t, {enableSnapToContext: nt = !0} = t, {willRenderHeaderTools: rt = Z} = t, {willRenderPresetToolbar: at} = t, {willRenderShapeStyleControls: lt} = t, {willStartInteraction: ct} = t, {shapePresets: dt = []} = t, {utilKey: ut} = t, {mapScreenPointToImagePoint: ht} = t, {mapImagePointToScreenPoint: pt} = t, {imageRotation: mt = 0} = t, {imageFlipX: gt = !1} = t, {imageFlipY: $t = !1} = t, {parentRect: ft} = t;
    Ce();
    let {hooks: yt = {}} = t;
    const xt = ca("selection");
    pr(e, xt, (e => o(150, ue = e)));
    const vt = ca("isAnimated");
    pr(e, vt, (e => o(142, q = e)));
    const wt = ca("elasticityMultiplier");
    pr(e, wt, (e => o(146, ee = e)));
    const St = ca("ui");
    pr(e, St, (e => o(177, pe = e)));
    const kt = ca("keysPressed");
    let Ct;
    pr(e, kt, (e => o(149, de = e)));
    const {
        env: Tt,
        history: Mt,
        rootRect: Pt,
        rootColorSecondary: Rt,
        enablePanInput: It,
        enablePanInputStatus: Et,
        enableZoomInput: At,
        stageRect: Lt,
        utilRectPadded: Ft,
        scrollElasticity: zt,
        imageOverlayMarkup: Dt,
        imagePreviewModifiers: Bt,
        imageCropRect: Ot,
        stageScalar: Wt,
        imageSelectionRect: Vt,
        imageTransformsInterpolated: _t,
        imageSelectionPan: Nt,
        imageSize: Ht,
        allowPan: jt,
        allowZoom: Ut,
        allowZoomControls: Gt,
        allowPlayPause: Zt
    } = ze;
    pr(e, Tt, (e => o(143, K = e))), pr(e, Pt, (e => o(55, fe = e))), pr(e, Rt, (e => o(57, be = e))), pr(e, Et, (e => o(38, le = e))), pr(e, Lt, (e => o(147, te = e))), pr(e, Ft, (e => o(39, me = e))), pr(e, Bt, (e => o(178, $e = e))), pr(e, Ot, (e => o(176, se = e))), pr(e, Wt, (e => o(174, ne = e))), pr(e, Vt, (e => o(175, re = e))), pr(e, _t, (e => o(36, oe = e))), pr(e, Nt, (e => o(173, ie = e))), pr(e, Ht, (e => o(148, ce = e)));
    let Xt = 0, Yt = {};
    const qt = e => {
        const [t, o] = Ct[e];
        let i, n, r = "relative" === o.position;
        const a = r ? "0%" : 0, s = r ? "0%" : 0;
        Pi(t) || Ci(t) ? (n = r ? "20%" : .2 * ae.width, i = yi(t), an(i), sn(i), i.x = a, i.y = s, kn(i, {
            width: n,
            height: n
        }, ae)) : Ri(t) ? (n = r ? "10%" : .1 * ae.width, i = yi(t), i.x = a, i.y = s, kn(i, {
            rx: n,
            ry: n
        }, ae)) : Ii(t) && (n = r ? "10%" : .1 * ae.width, i = yi(t), i.x1 = a, i.y1 = s, i.x2 = a, i.y2 = s), i && Promise.resolve().then((() => {
            po(uo(i, void 0, n))
        }))
    }, Kt = e => ht(nb(e, fe));
    let Jt, Qt = {};
    let eo;
    let to;
    const oo = e => {
        if (!(Ei(e) && Bo(e, "pathClose"))) return;
        const t = [...e.strokeColor];
        t[3] = 1, Jt.updateMarkupShape(e, {
            pathClose: !1,
            strokeColor: t
        }, !1), Jt.removeMarkupShapeProps(e, ["backgroundColor"], !1), Jt.confirmMarkupItemDraft(), Jt.selectShape(e), V("addshape", e), Mt.write()
    }, io = e => {
        const t = yi(e);
        return Object.assign(t, pe[ut] ? pe[ut][Ve] : {}), un(t), t
    };
    let no;
    const ro = (e, t) => {
        const o = {};
        return Object.entries(e).forEach((([e, i]) => {
            Bo(t, e) && (o[e] = i)
        })), o
    }, ao = (e, t) => {
        if (zo(e)) return e;
        if (e.endsWith("%")) {
            return parseFloat(e) / 100 * t.width
        }
    };
    let so = void 0, lo = void 0, co = void 0;
    const uo = (e, t, o) => {
        let i = !1;
        t || (i = !0, t = W ? ht(st(te)) : st(se)), t.x -= ae.x || 0, t.y -= ae.y || 0, (gt || $t) && (e.flipX = gt, e.flipY = $t);
        const n = Jt.getShapesNearPosition(Q, t);
        if (i && n.length) {
            const e = .1 * Math.min(se.width, se.height);
            t.x += Math.round(-e + Math.random() * e * 2), t.y += Math.round(-e + Math.random() * e * 2)
        }
        if (0 !== mt && (e.rotation = gt && $t ? -mt : gt || $t ? mt : -mt), Bo(e, "width") && Bo(e, "height")) {
            const {width: o, height: i} = Sn(e, ["width", "height"], ae);
            kn(e, {x: t.x - .5 * o, y: t.y - .5 * i}, ae)
        } else if (Ri(e)) kn(e, {x: t.x, y: t.y}, ae); else if (Ii(e)) {
            const {x1: i, y1: n, x2: r, y2: a} = Sn(e, ["x1", "y1", "x2", "y2"], ae), s = Re(he(i, n), he(r, a)),
                l = h(o) ? pn(o, ae.width) : s;
            kn(e, {x1: t.x - l, y1: t.y + l, x2: t.x + l, y2: t.y - l}, ae)
        } else if (Ei(e)) {
            const {points: o} = Sn(e, ["points"], ae), i = Ee(o);
            kn(e, {points: o.map((e => ({x: e.x + t.x - i.x, y: e.y + t.y - i.y})))}, ae)
        }
        return e
    }, ho = (e, t) => {
        const o = uo(wi(e, se), t);
        return e.shape && (Bo(e.shape, "x") && (o.x = e.shape.x), Bo(e.shape, "y") && (o.y = e.shape.y)), po(o)
    }, po = e => {
        const {beforeAddShape: t = (() => !0)} = yt;
        if (t(e)) return Jt.addShape(e), Jt.selectShape(e), V("addshape", e), Mt.write(), e
    };
    let mo = !1;
    const go = () => {
        Mt.write()
    };
    let $o;
    const fo = ca("redrawTrigger");
    pr(e, fo, (e => o(144, J = e)));
    const yo = [], bo = bc(q ? 20 : 0);
    pr(e, bo, (e => o(141, X = e)));
    return e.$$set = e => {
        "isActive" in e && ve(o(1, Ae = e.isActive)), "isActiveFraction" in e && Ie(o(2, Le = e.isActiveFraction)), "isVisible" in e && Me(o(3, Fe = e.isVisible)), "stores" in e && o(100, ze = e.stores), "locale" in e && o(4, De = e.locale), "shapes" in e && Se(o(5, Be = e.shapes)), "toolbar" in e && o(101, Oe = e.toolbar), "toolShapes" in e && o(102, We = e.toolShapes), "toolActive" in e && o(0, Ve = e.toolActive), "toolSelectRadius" in e && o(6, _e = e.toolSelectRadius), "toolRetainStyles" in e && o(103, Ne = e.toolRetainStyles), "toolbarLayout" in e && o(7, He = e.toolbarLayout), "textInputMode" in e && o(8, je = e.textInputMode), "shapeControls" in e && o(9, Ue = e.shapeControls), "enableButtonFlipVertical" in e && o(10, Ge = e.enableButtonFlipVertical), "enablePresetSelectImage" in e && o(11, Ze = e.enablePresetSelectImage), "enablePresetDropImage" in e && o(12, Xe = e.enablePresetDropImage), "enableSelectToolToAddShape" in e && o(104, Ye = e.enableSelectToolToAddShape), "enableAutoSelectMoveTool" in e && o(105, qe = e.enableAutoSelectMoveTool), "enableTapToAddText" in e && o(13, Ke = e.enableTapToAddText), "enableMoveTool" in e && o(106, Je = e.enableMoveTool), "enableViewTool" in e && o(107, Qe = e.enableViewTool), "enableToolShareStyles" in e && o(108, et = e.enableToolShareStyles), "enableMultiSelect" in e && o(14, tt = e.enableMultiSelect), "gridSize" in e && o(15, ot = e.gridSize), "snapThreshold" in e && o(16, it = e.snapThreshold), "enableSnapToContext" in e && o(17, nt = e.enableSnapToContext), "willRenderHeaderTools" in e && o(109, rt = e.willRenderHeaderTools), "willRenderPresetToolbar" in e && o(110, at = e.willRenderPresetToolbar), "willRenderShapeStyleControls" in e && o(18, lt = e.willRenderShapeStyleControls), "willStartInteraction" in e && o(111, ct = e.willStartInteraction), "shapePresets" in e && o(19, dt = e.shapePresets), "utilKey" in e && o(20, ut = e.utilKey), "mapScreenPointToImagePoint" in e && o(21, ht = e.mapScreenPointToImagePoint), "mapImagePointToScreenPoint" in e && o(22, pt = e.mapImagePointToScreenPoint), "imageRotation" in e && o(23, mt = e.imageRotation), "imageFlipX" in e && o(24, gt = e.imageFlipX), "imageFlipY" in e && o(25, $t = e.imageFlipY), "parentRect" in e && Ce(o(26, ft = e.parentRect)), "hooks" in e && o(112, yt = e.hooks)
    }, e.$$.update = () => {
        var t, ie, ne, re;
        if (33554432 & e.$$.dirty[4] && o(124, i = de.includes(18)), 1049088 & e.$$.dirty[3] && (Ct && We === Ct || o(113, Ct = We)), 16 & e.$$.dirty[1] && jt.set(Y), 16 & e.$$.dirty[1] && Ut.set(Y), 16 & e.$$.dirty[1] && Gt.set(Y), 256 & e.$$.dirty[3] && o(33, n = Array.isArray(Oe) && Oe.length > 1 && Array.isArray(Oe[0][1])), 4 & e.$$.dirty[1] | 256 & e.$$.dirty[3] && o(54, r = n ? Oe.map(((e, t) => [t, e[0]])) : []), 134217728 & e.$$.dirty[0] | 4 & e.$$.dirty[1] | 256 & e.$$.dirty[3] && o(140, a = n ? Oe[Xt][1] : Oe), 524288 & e.$$.dirty[0] | 155648 & e.$$.dirty[3] | 65536 & e.$$.dirty[4] && o(32, s = ((e, {
            willRenderPresetToolbar: t,
            shapePresets: o,
            enableViewTool: i,
            enableMoveTool: r
        }) => {
            let a = 0 !== o.length || t ? e : e.filter((e => "preset" !== e[0]));
            return n && (a = [["move", e => e.shapeLabelToolMove, {icon: e => e.shapeIconToolMove}], ["view", e => e.shapeLabelToolView, {icon: e => e.shapeIconToolView}], ...a]), a = r ? a : a.filter((e => "move" !== e[0])), i ? a : a.filter((e => "view" !== e[0]))
        })(a, {
            willRenderPresetToolbar: at,
            shapePresets: dt,
            enableMoveTool: Je,
            enableViewTool: Qe
        })), 2 & e.$$.dirty[1] && o(138, d = !!s.length), 1 & e.$$.dirty[0] | 2 & e.$$.dirty[1] | 16384 & e.$$.dirty[4] && d && void 0 === Ve && o(0, Ve = s[0][0]), 134217729 & e.$$.dirty[0] | 4 & e.$$.dirty[1] | 2097152 & e.$$.dirty[3] | 65536 & e.$$.dirty[4] && n && o(114, Yt = {
            ...Yt,
            [Xt]: a.map((([e]) => e)).includes(Ve) ? Ve : Yt[Xt] || a[0][0]
        }), 512 & e.$$.dirty[0] && o(137, l = !!Object.keys(Ue).length), 2 & e.$$.dirty[1] && o(34, c = s.length > 1), 12 & e.$$.dirty[1] && o(53, u = c || n), 1 & e.$$.dirty[0] && o(139, p = void 0 !== Ve), 57344 & e.$$.dirty[4] && o(52, m = (!p || d) && l), 536870912 & e.$$.dirty[0] && o(31, V = $o && (t = $o, (e, o) => {
            t.dispatchEvent(Yp(e, o))
        })), 1 & e.$$.dirty[0] | 17 & e.$$.dirty[1] && Y && V && V("selectcontrol", Ve), 16 & e.$$.dirty[1] && (Y ? vr(Bt, $e[ut] = {maskMarkupOpacity: .85}, $e) : delete $e[ut]), 1 & e.$$.dirty[0] | 1048576 & e.$$.dirty[3] && o(136, g = Ve && Ct[Ve] ? Ct[Ve][1] : void 0), 4096 & e.$$.dirty[4] && o(125, $ = g && g.isSelection ? "selection" : "shapes"), 3 & e.$$.dirty[4] && (e => {
            if (!Jt) return;
            const t = Jt.getShapeDraft(xt);
            t && (e && (eo = t.drawMode), Jt.updateShapeDraft({drawMode: e ? "subtract" : eo}, xt))
        })("selection" === $ && i), 268435457 & e.$$.dirty[0] && Ve && Jt) {
            const e = Jt.getMarkupItemDraft();
            e && oo(e)
        }
        if (1 & e.$$.dirty[0] && Ve && Jt && "move" !== Ve && Jt.blurShapes(), 16 & e.$$.dirty[1] | 134217728 & e.$$.dirty[4] && o(51, f = ge && Y), 256 & e.$$.dirty[1] | 8388608 & e.$$.dirty[4] && o(50, y = me && he(te.x - me.x, te.y - me.y)), 512 & e.$$.dirty[0] && o(135, b = Object.keys(Ue)), 16384 & e.$$.dirty[0] | 16 & e.$$.dirty[1] | 2097152 & e.$$.dirty[4] && o(122, x = tt ? Y && Q.filter(Fi) : []), 536870912 & e.$$.dirty[3] && o(123, v = x.length > 1), 16 & e.$$.dirty[1] | 2097152 & e.$$.dirty[4] && o(119, w = Y && Q.filter(Fi)[0]), 16 & e.$$.dirty[1] | 2097152 & e.$$.dirty[4] && o(130, S = Y && Q.find((e => zi(e)))), 16 & e.$$.dirty[1] | 2097152 & e.$$.dirty[4] && o(133, k = Y && Q.find((e => Di(e)))), 1 & e.$$.dirty[0] | 16 & e.$$.dirty[1] | 1048576 & e.$$.dirty[3] && o(127, C = Y && Ct[Ve] ? io(Ct[Ve][0]) : {}), 1048576 & e.$$.dirty[3] && Ct && o(115, Qt = {}), 1 & e.$$.dirty[0] | 4227072 & e.$$.dirty[3] | 2056 & e.$$.dirty[4] && o(126, T = C && Object.keys(C).reduce(((e, t) => {
            const o = "disableStyle" === t, i = "settings" === t, n = !!b.find((e => e.split("_").includes(t)));
            if (!o && !i && !n) return e;
            if (void 0 === C[t]) return e;
            if (!0 === C.disableStyle) return e;
            if (C.disableStyle && C.disableStyle.includes(t)) return e;
            if ("strokeWidth" === t && Object.keys(Qt).includes("strokeWidth") && void 0 === Qt[t] && Bo(C, "points")) return e[t] = C[t], e;
            const {share: r = !0} = C.settings && C.settings[t] || {}, a = et && r ? Qt : Qt[Ve] || {};
            return e[t] = Bo(a, t) ? a[t] : C[t], e
        }), {})), 1048577 & e.$$.dirty[0] | 1024 & e.$$.dirty[3] | 4 & e.$$.dirty[4] && (Ne ? ((e, t, o) => {
            const i = pe[e], n = i ? i[t] : {};
            St.set({...pe, [e]: {...i, [t]: {...n, ...o}}})
        })(ut, Ve, T) : (ie = ut, St.set({[ie]: {}}))), 16 & e.$$.dirty[1] | 67108864 & e.$$.dirty[3] | 67108868 & e.$$.dirty[4] && o(134, M = ue && Y ? w || T : void 0), 1610612736 & e.$$.dirty[3] | 1536 & e.$$.dirty[4] && o(49, P = v ? function (e) {
            const t = {};
            return e.forEach((e => {
                Object.entries(e).filter((([e]) => !e.startsWith("_"))).forEach((([e, o]) => {
                    Bo(t, e) ? "disableStyle" === e && Oo(o) && t[e].push(...o) : t[e] = o
                }))
            })), t
        }(x) : M || k), 1 & e.$$.dirty[0] | 8 & e.$$.dirty[4] && o(48, R = Bo(C, "eraseRadius") || Bo(C, "points") && !Bo(C, "pathClose") || "move" === Ve || "view" === Ve), 64 & e.$$.dirty[1] | 8 & e.$$.dirty[4] && o(47, I = C && void 0 !== C.eraseRadius ? ao(C.eraseRadius, ae) : void 0), 16 & e.$$.dirty[1] | 33554432 & e.$$.dirty[4] && o(131, E = Y && de.includes(32)), 1 & e.$$.dirty[0] | 16 & e.$$.dirty[1] && o(132, A = Y && "view" === Ve), 384 & e.$$.dirty[4] && o(129, L = A || E), 96 & e.$$.dirty[4] && o(128, F = !!L && (!!S || Wd(document.activeElement))), 16 & e.$$.dirty[1] | 48 & e.$$.dirty[4] && It.set(!Y || L && !F), 16 & e.$$.dirty[1] | 16 & e.$$.dirty[4] && At.set(!Y || !F), 64 & e.$$.dirty[1] | 12 & e.$$.dirty[4] && o(120, z = C.cursorStyle ? (({
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    cursorStyle: e,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    cursorSize: t
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                }, o, i) => {
            let n;
            const r = o[t];
            if (void 0 === r ? n = ao(t, i) : zo(r) ? n = r : h(r) && (n = fn(t, o[t], i), "strokeWidth" === t && (n *= .5)), !(n <= 0 || void 0 === n)) return {
                size: n,
                style: e
            }
        })(C, {...C, ...T}, ae) : void 0), 33554432 & e.$$.dirty[3] | 16777216 & e.$$.dirty[4] && o(121, D = co && (re = ce, (ne = co).x >= 0 && ne.y >= 0 && ne.x <= re.width && ne.y <= re.height)), 1048576 & e.$$.dirty[0] | 160 & e.$$.dirty[1] | 427819008 & e.$$.dirty[3] | 3 & e.$$.dirty[4]) if (D && !so && z && !le) {
            const e = z.size * oe.scale,
                t = {id: "cursor-" + ut, x: lo.x, y: lo.y, strokeWidth: .5, strokeColor: [0, 0, 0]};
            "ellipse" === z.style && (t.rx = e, t.ry = e);
            const o = {strokeWidth: 2.5, strokeColor: [1, 1, 1], opacity: .75}, n = [{...t, ...o}, t];
            if ("selection" === $ && i) {
                const t = e, i = lo.x + t, r = lo.y + t + 4, a = {
                    id: "cursor-" + ut,
                    strokeWidth: .75,
                    strokeColor: [0, 0, 0],
                    points: [{x: i, y: r}, {x: i + 4, y: r}]
                };
                n.push({...a, ...o, strokeWidth: 2, points: [{x: i - .5, y: r}, {x: i + 4.5, y: r}]}, a)
            }
            (e => {
                Dt.update((t => [...t.filter((e => e.id !== "cursor-" + ut)), ...e]))
            })(n)
        } else Dt.update((e => e.filter((e => e.id !== "cursor-" + ut))));
        1 & e.$$.dirty[0] | 128 & e.$$.dirty[1] | 478150656 & e.$$.dirty[3] && o(46, B = D ? ((e, t, o, i, n, r) => {
            if (i) return n ? "grabbing" : "grab";
            if (e && !t) return "none";
            if (!t) return "move" === r ? "default" : "crosshair";
            let a = t || o;
            return Fi(a) ? zi(a) ? "modal" === je ? "default" : "text" : !Qi(a) || v && !x.every(Qi) ? "default" : "move" : "default"
        })(z, so, w, le, false, Ve) : "default"), 526337 & e.$$.dirty[0] | 131072 & e.$$.dirty[3] && o(45, O = "preset" === Ve && (dt.length > 0 || Ze || at)), 64 & e.$$.dirty[1] && (W = !Bo(ae, "x") && !Bo(ae, "y")), 4194304 & e.$$.dirty[4] && o(44, _ = ee * zt), 131072 & e.$$.dirty[3] | 1572864 & e.$$.dirty[4] && o(43, N = J && at ? e => lm((() => at(e, ho, {...K}, (() => fo.set({}))))) : Z), 524288 & e.$$.dirty[3] && o(42, H = Object.keys(yt).reduce(((e, t) => ("beforeAddShape" === t || void 0 === yt[t] || (e[t] = yt[t]), e)), {})), 16 & e.$$.dirty[1] && (e => {
            Q && Be.update((t => t.map((t => (t._prerender = !!e && zi(t), t)))))
        })(Y), 65536 & e.$$.dirty[3] | 1572864 & e.$$.dirty[4] && o(30, j = J && rt([], K, (() => fo.set({})))), 1073742336 & e.$$.dirty[0] && o(41, U = !!j.length || !!Object.keys(Ue).some((e => yo.includes(e)))), 16 & e.$$.dirty[1] | 262144 & e.$$.dirty[4] && q && bo.set(Y ? 0 : 20), e.$$.dirty[4], 131072 & e.$$.dirty[4] && o(40, G = X ? `translateY(${X}px)` : "none")
    }, Zt.set(!1), [Ve, Ae, Le, Fe, De, Be, _e, He, je, Ue, Ge, Ze, Xe, Ke, tt, ot, it, nt, lt, dt, ut, ht, pt, mt, gt, $t, ft, Xt, Jt, $o, j, V, s, n, c, Y, oe, ae, le, me, G, U, H, N, _, O, B, I, R, P, y, f, m, u, r, fe, ye, be, xt, vt, wt, St, kt, Tt, Pt, Rt, Et, Lt, Ft, Dt, Bt, Ot, Wt, Vt, _t, Nt, Ht, ({index: e}, t) => {
        o(27, Xt = e), o(0, Ve = Yt[e])
    }, ({value: e}, t) => {
        o(0, Ve = e), (Ye || /enter/i.test(t.key)) && qt(e)
    }, e => {
        if ("eraser" === Ve) to = Jt.eraseShape(); else if (Ve && Ct[Ve]) {
            const [e, t = {}] = Ct[Ve], o = yi(e);
            an(o), sn(o);
            const {drawMode: n} = M;
            "selection" === $ && "new" === n && xt.set([]);
            let r = {};
            "selection" === $ && (V("selectiondown", [...ue]), i && (eo = o.drawMode, r.drawMode = "subtract")), to = Jt.createShape({...o, ...T, ...r}, t)
        } else to = void 0;
        return !!to && (to.start(e), !0)
    }, e => !!to && (to.update(e), !0), e => !!to && (to.release(e), !0), e => !!to && (to.cancel(e), to = void 0, !0), e => {
        if (!to) return !1;
        if (to.end(e), to = void 0, "selection" === $) {
            if (e.detail.isTap) {
                const [e] = Ct[Ve];
                e.bitmap || xt.set([])
            }
            V("selectionup", [...ue])
        }
        const t = Jt.getMarkupItemDraft(), i = Je && (!0 === qe || Array.isArray(qe) && qe.includes(Ve));
        return t && !t.isEditing || !i || o(0, Ve = "move"), !0
    }, e => {
        const {key: t} = e, o = Jt.getMarkupItemDraft();
        /escape/i.test(t) && o && (e.preventDefault(), e.stopPropagation(), Jt.discardMarkupItemDraft(), to = void 0), /enter/i.test(t) && o && (e.preventDefault(), e.stopPropagation(), oo(o), to = void 0)
    }, function (e) {
        Object.keys(e).forEach((t => {
            const {retain: i = !0, share: n = !0} = C.settings && C.settings[t] || {};
            i && (et && n ? o(115, Qt[t] = e[t], Qt) : (Qt[Ve] || o(115, Qt[Ve] = {}, Qt), o(115, Qt[Ve][t] = e[t], Qt)))
        })), V("selectstyle", e), w && (v ? x.forEach((t => {
            Jt.updateMarkupShape(t, ro(e, t))
        })) : Jt.updateMarkupShape(w, e), clearTimeout(no), no = setTimeout((() => {
            go()
        }), 200))
    }, (e, t, i) => {
        o(117, lo = t), o(118, co = i)
    }, () => {
        o(118, co = void 0), o(117, lo = void 0)
    }, e => {
        V("markuptap", e)
    }, e => o(116, so = e), () => {
        mo = !1
    }, (e, t) => {
        if (mo) return;
        const {beforeAddShape: o = (() => !0)} = yt, i = Kt(t), n = Jt.getMarkupItemDraft(),
            r = bt(se, {x: i.x + (ae.x || 0), y: i.y + (ae.y || 0)});
        if (n && !r && Jt.discardMarkupItemDraft(), r) {
            if (!n) {
                const n = wi(e, se), r = uo(n, i);
                return o(r) ? (_i(r), void Jt.addShape(r)) : (mo = !0, void t.preventDefault())
            }
            Pi(n) && (i.x -= .5 * n.width, i.y -= .5 * n.height), e.shape && (Bo(e.shape, "x") && (i.x = e.shape.x), Bo(e.shape, "y") && (i.y = e.shape.y)), Jt.updateMarkupShape(n, i)
        }
    }, (e, t) => {
        if (mo) return;
        const o = Kt(t);
        if (!bt(se, {x: o.x + (ae.x || 0), y: o.y + (ae.y || 0)})) return void Jt.discardMarkupItemDraft();
        const i = Jt.confirmMarkupItemDraft();
        Jt.selectShape(i), V("addshape", i), Mt.write()
    }, e => ho(e), e => {
        return t = e.detail.resources, o = Kt(e.detail.event), t.forEach((e => ho(e, o)));
        var t, o
    }, e => {
        if (!ct) return !0;
        const t = rectClone(re);
        return rectScale(t, 1 / ne), rectTranslate(t, ie), rectScale(t, oe.scale), ct(e, {
            ...t,
            x: t.x + te.x,
            y: t.y + te.y
        })
    }, go, fo, yo, bo, ze, Oe, We, Ne, Ye, qe, Je, Qe, et, rt, at, ct, yt, Ct, Yt, Qt, so, lo, co, w, z, D, x, v, i, $, T, C, F, L, S, E, A, k, M, b, g, l, d, p, a, X, q, K, J, Q, ee, te, ce, de, ue, ge, function (t) {
        da.call(this, e, t)
    }, e => e[0] === Ve, (e, t, o) => {
        const i = e.filter((([, e]) => !yo.includes(e)));
        return lt ? lt(i, t, o) : i
    }, e => e[0] === Xt, e => {
        Promise.resolve().then((() => {
            V("addshape", e), go()
        }))
    }, e => {
        V("selectshape", e)
    }, e => {
        Promise.resolve().then((() => {
            V("blurshape", e)
        }))
    }, e => {
        V("tapshape", e)
    }, e => {
        V("updateshape", e), go()
    }, e => {
        V("removeshape", e), go()
    }, () => {
        go()
    }, function (e) {
        ha[e ? "unshift" : "push"]((() => {
            Jt = e, o(28, Jt)
        }))
    }, function (e) {
        ha[e ? "unshift" : "push"]((() => {
            $o = e, o(29, $o)
        }))
    }, e => e.filter((([, e]) => yo.includes(e))), function (t) {
        da.call(this, e, t)
    }]
}

class Mx extends Ga {
    constructor(e) {
        super(), Ua(this, e, Tx, Cx, lr, {
            isActive: 1,
            isActiveFraction: 2,
            isVisible: 3,
            stores: 100,
            locale: 4,
            shapes: 5,
            toolbar: 101,
            toolShapes: 102,
            toolActive: 0,
            toolSelectRadius: 6,
            toolRetainStyles: 103,
            toolbarLayout: 7,
            textInputMode: 8,
            shapeControls: 9,
            enableButtonFlipVertical: 10,
            enablePresetSelectImage: 11,
            enablePresetDropImage: 12,
            enableSelectToolToAddShape: 104,
            enableAutoSelectMoveTool: 105,
            enableTapToAddText: 13,
            enableMoveTool: 106,
            enableViewTool: 107,
            enableToolShareStyles: 108,
            enableMultiSelect: 14,
            gridSize: 15,
            snapThreshold: 16,
            enableSnapToContext: 17,
            willRenderHeaderTools: 109,
            willRenderPresetToolbar: 110,
            willRenderShapeStyleControls: 18,
            willStartInteraction: 111,
            shapePresets: 19,
            utilKey: 20,
            mapScreenPointToImagePoint: 21,
            mapImagePointToScreenPoint: 22,
            imageRotation: 23,
            imageFlipX: 24,
            imageFlipY: 25,
            parentRect: 26,
            hooks: 112
        }, null, [-1, -1, -1, -1, -1, -1, -1])
    }

    get isActive() {
        return this.$$.ctx[1]
    }

    set isActive(e) {
        this.$$set({isActive: e}), ka()
    }

    get isActiveFraction() {
        return this.$$.ctx[2]
    }

    set isActiveFraction(e) {
        this.$$set({isActiveFraction: e}), ka()
    }

    get isVisible() {
        return this.$$.ctx[3]
    }

    set isVisible(e) {
        this.$$set({isVisible: e}), ka()
    }

    get stores() {
        return this.$$.ctx[100]
    }

    set stores(e) {
        this.$$set({stores: e}), ka()
    }

    get locale() {
        return this.$$.ctx[4]
    }

    set locale(e) {
        this.$$set({locale: e}), ka()
    }

    get shapes() {
        return this.$$.ctx[5]
    }

    set shapes(e) {
        this.$$set({shapes: e}), ka()
    }

    get toolbar() {
        return this.$$.ctx[101]
    }

    set toolbar(e) {
        this.$$set({toolbar: e}), ka()
    }

    get toolShapes() {
        return this.$$.ctx[102]
    }

    set toolShapes(e) {
        this.$$set({toolShapes: e}), ka()
    }

    get toolActive() {
        return this.$$.ctx[0]
    }

    set toolActive(e) {
        this.$$set({toolActive: e}), ka()
    }

    get toolSelectRadius() {
        return this.$$.ctx[6]
    }

    set toolSelectRadius(e) {
        this.$$set({toolSelectRadius: e}), ka()
    }

    get toolRetainStyles() {
        return this.$$.ctx[103]
    }

    set toolRetainStyles(e) {
        this.$$set({toolRetainStyles: e}), ka()
    }

    get toolbarLayout() {
        return this.$$.ctx[7]
    }

    set toolbarLayout(e) {
        this.$$set({toolbarLayout: e}), ka()
    }

    get textInputMode() {
        return this.$$.ctx[8]
    }

    set textInputMode(e) {
        this.$$set({textInputMode: e}), ka()
    }

    get shapeControls() {
        return this.$$.ctx[9]
    }

    set shapeControls(e) {
        this.$$set({shapeControls: e}), ka()
    }

    get enableButtonFlipVertical() {
        return this.$$.ctx[10]
    }

    set enableButtonFlipVertical(e) {
        this.$$set({enableButtonFlipVertical: e}), ka()
    }

    get enablePresetSelectImage() {
        return this.$$.ctx[11]
    }

    set enablePresetSelectImage(e) {
        this.$$set({enablePresetSelectImage: e}), ka()
    }

    get enablePresetDropImage() {
        return this.$$.ctx[12]
    }

    set enablePresetDropImage(e) {
        this.$$set({enablePresetDropImage: e}), ka()
    }

    get enableSelectToolToAddShape() {
        return this.$$.ctx[104]
    }

    set enableSelectToolToAddShape(e) {
        this.$$set({enableSelectToolToAddShape: e}), ka()
    }

    get enableAutoSelectMoveTool() {
        return this.$$.ctx[105]
    }

    set enableAutoSelectMoveTool(e) {
        this.$$set({enableAutoSelectMoveTool: e}), ka()
    }

    get enableTapToAddText() {
        return this.$$.ctx[13]
    }

    set enableTapToAddText(e) {
        this.$$set({enableTapToAddText: e}), ka()
    }

    get enableMoveTool() {
        return this.$$.ctx[106]
    }

    set enableMoveTool(e) {
        this.$$set({enableMoveTool: e}), ka()
    }

    get enableViewTool() {
        return this.$$.ctx[107]
    }

    set enableViewTool(e) {
        this.$$set({enableViewTool: e}), ka()
    }

    get enableToolShareStyles() {
        return this.$$.ctx[108]
    }

    set enableToolShareStyles(e) {
        this.$$set({enableToolShareStyles: e}), ka()
    }

    get enableMultiSelect() {
        return this.$$.ctx[14]
    }

    set enableMultiSelect(e) {
        this.$$set({enableMultiSelect: e}), ka()
    }

    get gridSize() {
        return this.$$.ctx[15]
    }

    set gridSize(e) {
        this.$$set({gridSize: e}), ka()
    }

    get snapThreshold() {
        return this.$$.ctx[16]
    }

    set snapThreshold(e) {
        this.$$set({snapThreshold: e}), ka()
    }

    get enableSnapToContext() {
        return this.$$.ctx[17]
    }

    set enableSnapToContext(e) {
        this.$$set({enableSnapToContext: e}), ka()
    }

    get willRenderHeaderTools() {
        return this.$$.ctx[109]
    }

    set willRenderHeaderTools(e) {
        this.$$set({willRenderHeaderTools: e}), ka()
    }

    get willRenderPresetToolbar() {
        return this.$$.ctx[110]
    }

    set willRenderPresetToolbar(e) {
        this.$$set({willRenderPresetToolbar: e}), ka()
    }

    get willRenderShapeStyleControls() {
        return this.$$.ctx[18]
    }

    set willRenderShapeStyleControls(e) {
        this.$$set({willRenderShapeStyleControls: e}), ka()
    }

    get willStartInteraction() {
        return this.$$.ctx[111]
    }

    set willStartInteraction(e) {
        this.$$set({willStartInteraction: e}), ka()
    }

    get shapePresets() {
        return this.$$.ctx[19]
    }

    set shapePresets(e) {
        this.$$set({shapePresets: e}), ka()
    }

    get utilKey() {
        return this.$$.ctx[20]
    }

    set utilKey(e) {
        this.$$set({utilKey: e}), ka()
    }

    get mapScreenPointToImagePoint() {
        return this.$$.ctx[21]
    }

    set mapScreenPointToImagePoint(e) {
        this.$$set({mapScreenPointToImagePoint: e}), ka()
    }

    get mapImagePointToScreenPoint() {
        return this.$$.ctx[22]
    }

    set mapImagePointToScreenPoint(e) {
        this.$$set({mapImagePointToScreenPoint: e}), ka()
    }

    get imageRotation() {
        return this.$$.ctx[23]
    }

    set imageRotation(e) {
        this.$$set({imageRotation: e}), ka()
    }

    get imageFlipX() {
        return this.$$.ctx[24]
    }

    set imageFlipX(e) {
        this.$$set({imageFlipX: e}), ka()
    }

    get imageFlipY() {
        return this.$$.ctx[25]
    }

    set imageFlipY(e) {
        this.$$set({imageFlipY: e}), ka()
    }

    get parentRect() {
        return this.$$.ctx[26]
    }

    set parentRect(e) {
        this.$$set({parentRect: e}), ka()
    }

    get hooks() {
        return this.$$.ctx[112]
    }

    set hooks(e) {
        this.$$set({hooks: e}), ka()
    }
}

var Px = (e, t, o, i, n, r, a, s, l) => {
    const c = me(e), d = .5 * o.width, u = .5 * o.height, h = .5 * t.width, p = .5 * t.height, m = n.x + i.x,
        g = n.y + i.y;
    s && (c.x = o.width - c.x), l && (c.y = o.height - c.y);
    const $ = Math.cos(r), f = Math.sin(r);
    c.x -= d, c.y -= u;
    const y = c.x * $ - c.y * f, b = c.x * f + c.y * $;
    c.x = d + y, c.y = u + b, c.x *= a, c.y *= a, c.x += h, c.y += p, c.x += m, c.y += g, c.x -= d * a, c.y -= u * a;
    const x = (n.x - m) * a, v = (n.y - g) * a, w = x * $ - v * f, S = x * f + v * $;
    return c.x += w, c.y += S, c
}, Rx = (e, t, o, i, n, r, a, s, l) => {
    const c = me(e), d = He(o), u = He(t), h = he(n.x + i.x, n.y + i.y), p = Math.cos(r), m = Math.sin(r);
    c.x -= u.x, c.y -= u.y;
    const g = (n.x - h.x) * a, $ = (n.y - h.y) * a, f = g * p - $ * m, y = g * m + $ * p;
    c.x -= f, c.y -= y, c.x -= h.x, c.y -= h.y, c.x /= a, c.y /= a;
    const b = c.x * p + c.y * m, x = c.x * m - c.y * p;
    return c.x = b, c.y = -x, c.x += d.x, c.y += d.y, s && (c.x = o.width - c.x), l && (c.y = o.height - c.y), c
}, Ix = e => "boolean" == typeof e;

function Ex(e) {
    let t, o, i;

    function n(t) {
        e[60](t)
    }

    let r = {
        utilKey: e[1],
        stores: e[5],
        locale: e[6],
        isActive: e[2],
        isActiveFraction: e[3],
        isVisible: e[4],
        mapScreenPointToImagePoint: e[46],
        mapImagePointToScreenPoint: e[45],
        imageRotation: e[47],
        imageFlipX: e[44],
        imageFlipY: e[43],
        shapes: e[49],
        toolbar: e[21] || e[7],
        toolShapes: e[22] || e[8],
        toolRetainStyles: e[9],
        enableSelectToolToAddShape: e[31],
        enableTapToAddText: e[32],
        enableViewTool: e[30],
        enableMoveTool: e[34],
        enableAutoSelectMoveTool: e[33],
        enableMultiSelect: e[35],
        snapThreshold: e[16],
        gridSize: zo(e[18]) ? e[18] : e[15],
        enableSnapToContext: Ix(e[19]) ? e[19] : e[17],
        enableToolShareStyles: e[13],
        shapeControls: e[23] || e[10],
        shapePresets: e[27],
        enableButtonFlipVertical: e[24],
        parentRect: e[50],
        enablePresetDropImage: e[26],
        enablePresetSelectImage: e[25],
        toolSelectRadius: e[11],
        textInputMode: e[12],
        willStartInteraction: e[14],
        willRenderPresetToolbar: e[28] || e[20],
        willRenderShapeStyleControls: e[29],
        hooks: {
            willRenderShapeControls: e[36],
            willRenderShapeTextControls: e[37],
            beforeAddShape: e[38],
            beforeRemoveShape: e[39],
            beforeDeselectShape: e[40],
            beforeSelectShape: e[41],
            beforeUpdateShape: e[42]
        }
    };
    return void 0 !== e[0] && (r.toolActive = e[0]), t = new Mx({props: r}), ha.push((() => _a(t, "toolActive", n))), t.$on("measure", e[61]), {
        c() {
            Na(t.$$.fragment)
        }, m(e, o) {
            Ha(t, e, o), i = !0
        }, p(e, i) {
            const n = {};
            32 & i[0] && (n.stores = e[5]), 64 & i[0] && (n.locale = e[6]), 4 & i[0] && (n.isActive = e[2]), 8 & i[0] && (n.isActiveFraction = e[3]), 16 & i[0] && (n.isVisible = e[4]), 32768 & i[1] && (n.mapScreenPointToImagePoint = e[46]), 16384 & i[1] && (n.mapImagePointToScreenPoint = e[45]), 65536 & i[1] && (n.imageRotation = e[47]), 8192 & i[1] && (n.imageFlipX = e[44]), 4096 & i[1] && (n.imageFlipY = e[43]), 2097280 & i[0] && (n.toolbar = e[21] || e[7]), 4194560 & i[0] && (n.toolShapes = e[22] || e[8]), 512 & i[0] && (n.toolRetainStyles = e[9]), 1 & i[1] && (n.enableSelectToolToAddShape = e[31]), 2 & i[1] && (n.enableTapToAddText = e[32]), 1073741824 & i[0] && (n.enableViewTool = e[30]), 8 & i[1] && (n.enableMoveTool = e[34]), 4 & i[1] && (n.enableAutoSelectMoveTool = e[33]), 16 & i[1] && (n.enableMultiSelect = e[35]), 65536 & i[0] && (n.snapThreshold = e[16]), 294912 & i[0] && (n.gridSize = zo(e[18]) ? e[18] : e[15]), 655360 & i[0] && (n.enableSnapToContext = Ix(e[19]) ? e[19] : e[17]), 8192 & i[0] && (n.enableToolShareStyles = e[13]), 8389632 & i[0] && (n.shapeControls = e[23] || e[10]), 134217728 & i[0] && (n.shapePresets = e[27]), 16777216 & i[0] && (n.enableButtonFlipVertical = e[24]), 67108864 & i[0] && (n.enablePresetDropImage = e[26]), 33554432 & i[0] && (n.enablePresetSelectImage = e[25]), 2048 & i[0] && (n.toolSelectRadius = e[11]), 4096 & i[0] && (n.textInputMode = e[12]), 16384 & i[0] && (n.willStartInteraction = e[14]), 269484032 & i[0] && (n.willRenderPresetToolbar = e[28] || e[20]), 536870912 & i[0] && (n.willRenderShapeStyleControls = e[29]), 4064 & i[1] && (n.hooks = {
                willRenderShapeControls: e[36],
                willRenderShapeTextControls: e[37],
                beforeAddShape: e[38],
                beforeRemoveShape: e[39],
                beforeDeselectShape: e[40],
                beforeSelectShape: e[41],
                beforeUpdateShape: e[42]
            }), !o && 1 & i[0] && (o = !0, n.toolActive = e[0], xa((() => o = !1))), t.$set(n)
        }, i(e) {
            i || (Ea(t.$$.fragment, e), i = !0)
        }, o(e) {
            Aa(t.$$.fragment, e), i = !1
        }, d(e) {
            ja(t, e)
        }
    }
}

function Ax(e, t, o) {
    let i, n, r, a, s, l, c, d, u;
    let {isActive: h} = t, {isActiveFraction: p} = t, {isVisible: m} = t, {stores: g} = t, {locale: $ = {}} = t, {markupEditorToolbar: f} = t, {markupEditorToolStyles: y} = t, {markupEditorToolRetainStyles: b} = t, {markupEditorShapeStyleControls: x} = t, {markupEditorToolSelectRadius: v} = t, {markupEditorTextInputMode: w} = t, {markupEditorToolShareStyles: S} = t, {markupEditorWillStartInteraction: k} = t, {markupEditorGridSize: C = 0} = t, {markupEditorSnapThreshold: T = 0} = t, {markupEditorSnapToContext: M = !1} = t, {annotateGridSize: P} = t, {annotateSnapToContext: R} = t, {willRenderShapePresetToolbar: I} = t, {annotateTools: E} = t, {annotateToolShapes: A} = t, {annotateShapeControls: L} = t, {annotateActiveTool: F} = t, {annotateEnableButtonFlipVertical: z = !1} = t, {annotateEnableSelectImagePreset: D = !1} = t, {annotateEnableDropImagePreset: B = !0} = t, {annotatePresets: O = []} = t, {annotateWillRenderShapePresetToolbar: W} = t, {annotateWillRenderShapeStyleControls: V} = t, {enableViewTool: _} = t, {enableSelectToolToAddShape: N} = t, {enableTapToAddText: H} = t, {enableAutoSelectMoveTool: j} = t, {enableMoveTool: U} = t, {enableMultiSelect: G} = t, {willRenderShapeControls: Z} = t, {willRenderShapeTextControls: X} = t, {beforeAddShape: Y} = t, {beforeRemoveShape: q} = t, {beforeDeselectShape: K} = t, {beforeSelectShape: J} = t, {beforeUpdateShape: Q} = t;
    const {
        rootRect: ee,
        imageAnnotation: te,
        imageSize: oe,
        imageRotation: ie,
        imageFlipX: ne,
        imageFlipY: re,
        imageTransforms: ae,
        imageTransformsInterpolated: se
    } = g;
    return pr(e, ee, (e => o(59, d = e))), pr(e, oe, (e => o(58, c = e))), pr(e, ie, (e => o(47, u = e))), pr(e, ne, (e => o(44, a = e))), pr(e, re, (e => o(43, r = e))), pr(e, ae, (e => o(57, l = e))), pr(e, se, (e => o(56, s = e))), e.$$set = e => {
        "isActive" in e && o(2, h = e.isActive), "isActiveFraction" in e && o(3, p = e.isActiveFraction), "isVisible" in e && o(4, m = e.isVisible), "stores" in e && o(5, g = e.stores), "locale" in e && o(6, $ = e.locale), "markupEditorToolbar" in e && o(7, f = e.markupEditorToolbar), "markupEditorToolStyles" in e && o(8, y = e.markupEditorToolStyles), "markupEditorToolRetainStyles" in e && o(9, b = e.markupEditorToolRetainStyles), "markupEditorShapeStyleControls" in e && o(10, x = e.markupEditorShapeStyleControls), "markupEditorToolSelectRadius" in e && o(11, v = e.markupEditorToolSelectRadius), "markupEditorTextInputMode" in e && o(12, w = e.markupEditorTextInputMode), "markupEditorToolShareStyles" in e && o(13, S = e.markupEditorToolShareStyles), "markupEditorWillStartInteraction" in e && o(14, k = e.markupEditorWillStartInteraction), "markupEditorGridSize" in e && o(15, C = e.markupEditorGridSize), "markupEditorSnapThreshold" in e && o(16, T = e.markupEditorSnapThreshold), "markupEditorSnapToContext" in e && o(17, M = e.markupEditorSnapToContext), "annotateGridSize" in e && o(18, P = e.annotateGridSize), "annotateSnapToContext" in e && o(19, R = e.annotateSnapToContext), "willRenderShapePresetToolbar" in e && o(20, I = e.willRenderShapePresetToolbar), "annotateTools" in e && o(21, E = e.annotateTools), "annotateToolShapes" in e && o(22, A = e.annotateToolShapes), "annotateShapeControls" in e && o(23, L = e.annotateShapeControls), "annotateActiveTool" in e && o(0, F = e.annotateActiveTool), "annotateEnableButtonFlipVertical" in e && o(24, z = e.annotateEnableButtonFlipVertical), "annotateEnableSelectImagePreset" in e && o(25, D = e.annotateEnableSelectImagePreset), "annotateEnableDropImagePreset" in e && o(26, B = e.annotateEnableDropImagePreset), "annotatePresets" in e && o(27, O = e.annotatePresets), "annotateWillRenderShapePresetToolbar" in e && o(28, W = e.annotateWillRenderShapePresetToolbar), "annotateWillRenderShapeStyleControls" in e && o(29, V = e.annotateWillRenderShapeStyleControls), "enableViewTool" in e && o(30, _ = e.enableViewTool), "enableSelectToolToAddShape" in e && o(31, N = e.enableSelectToolToAddShape), "enableTapToAddText" in e && o(32, H = e.enableTapToAddText), "enableAutoSelectMoveTool" in e && o(33, j = e.enableAutoSelectMoveTool), "enableMoveTool" in e && o(34, U = e.enableMoveTool), "enableMultiSelect" in e && o(35, G = e.enableMultiSelect), "willRenderShapeControls" in e && o(36, Z = e.willRenderShapeControls), "willRenderShapeTextControls" in e && o(37, X = e.willRenderShapeTextControls), "beforeAddShape" in e && o(38, Y = e.beforeAddShape), "beforeRemoveShape" in e && o(39, q = e.beforeRemoveShape), "beforeDeselectShape" in e && o(40, K = e.beforeDeselectShape), "beforeSelectShape" in e && o(41, J = e.beforeSelectShape), "beforeUpdateShape" in e && o(42, Q = e.beforeUpdateShape)
    }, e.$$.update = () => {
        503328768 & e.$$.dirty[1] && o(46, i = e => Rx(e, d, c, s.origin, s.translation, l.rotation.z, s.scale, a, r)), 503328768 & e.$$.dirty[1] && o(45, n = e => Px(e, d, c, s.origin, s.translation, l.rotation.z, s.scale, a, r))
    }, [F, "annotate", h, p, m, g, $, f, y, b, x, v, w, S, k, C, T, M, P, R, I, E, A, L, z, D, B, O, W, V, _, N, H, j, U, G, Z, X, Y, q, K, J, Q, r, a, n, i, u, ee, te, oe, ie, ne, re, ae, se, s, l, c, d, function (e) {
        F = e, o(0, F)
    }, function (t) {
        da.call(this, e, t)
    }]
}

var Lx = {
    util: ["annotate", class extends Ga {
        constructor(e) {
            super(), Ua(this, e, Ax, Ex, lr, {
                name: 1,
                isActive: 2,
                isActiveFraction: 3,
                isVisible: 4,
                stores: 5,
                locale: 6,
                markupEditorToolbar: 7,
                markupEditorToolStyles: 8,
                markupEditorToolRetainStyles: 9,
                markupEditorShapeStyleControls: 10,
                markupEditorToolSelectRadius: 11,
                markupEditorTextInputMode: 12,
                markupEditorToolShareStyles: 13,
                markupEditorWillStartInteraction: 14,
                markupEditorGridSize: 15,
                markupEditorSnapThreshold: 16,
                markupEditorSnapToContext: 17,
                annotateGridSize: 18,
                annotateSnapToContext: 19,
                willRenderShapePresetToolbar: 20,
                annotateTools: 21,
                annotateToolShapes: 22,
                annotateShapeControls: 23,
                annotateActiveTool: 0,
                annotateEnableButtonFlipVertical: 24,
                annotateEnableSelectImagePreset: 25,
                annotateEnableDropImagePreset: 26,
                annotatePresets: 27,
                annotateWillRenderShapePresetToolbar: 28,
                annotateWillRenderShapeStyleControls: 29,
                enableViewTool: 30,
                enableSelectToolToAddShape: 31,
                enableTapToAddText: 32,
                enableAutoSelectMoveTool: 33,
                enableMoveTool: 34,
                enableMultiSelect: 35,
                willRenderShapeControls: 36,
                willRenderShapeTextControls: 37,
                beforeAddShape: 38,
                beforeRemoveShape: 39,
                beforeDeselectShape: 40,
                beforeSelectShape: 41,
                beforeUpdateShape: 42
            }, null, [-1, -1])
        }

        get name() {
            return this.$$.ctx[1]
        }

        get isActive() {
            return this.$$.ctx[2]
        }

        set isActive(e) {
            this.$$set({isActive: e}), ka()
        }

        get isActiveFraction() {
            return this.$$.ctx[3]
        }

        set isActiveFraction(e) {
            this.$$set({isActiveFraction: e}), ka()
        }

        get isVisible() {
            return this.$$.ctx[4]
        }

        set isVisible(e) {
            this.$$set({isVisible: e}), ka()
        }

        get stores() {
            return this.$$.ctx[5]
        }

        set stores(e) {
            this.$$set({stores: e}), ka()
        }

        get locale() {
            return this.$$.ctx[6]
        }

        set locale(e) {
            this.$$set({locale: e}), ka()
        }

        get markupEditorToolbar() {
            return this.$$.ctx[7]
        }

        set markupEditorToolbar(e) {
            this.$$set({markupEditorToolbar: e}), ka()
        }

        get markupEditorToolStyles() {
            return this.$$.ctx[8]
        }

        set markupEditorToolStyles(e) {
            this.$$set({markupEditorToolStyles: e}), ka()
        }

        get markupEditorToolRetainStyles() {
            return this.$$.ctx[9]
        }

        set markupEditorToolRetainStyles(e) {
            this.$$set({markupEditorToolRetainStyles: e}), ka()
        }

        get markupEditorShapeStyleControls() {
            return this.$$.ctx[10]
        }

        set markupEditorShapeStyleControls(e) {
            this.$$set({markupEditorShapeStyleControls: e}), ka()
        }

        get markupEditorToolSelectRadius() {
            return this.$$.ctx[11]
        }

        set markupEditorToolSelectRadius(e) {
            this.$$set({markupEditorToolSelectRadius: e}), ka()
        }

        get markupEditorTextInputMode() {
            return this.$$.ctx[12]
        }

        set markupEditorTextInputMode(e) {
            this.$$set({markupEditorTextInputMode: e}), ka()
        }

        get markupEditorToolShareStyles() {
            return this.$$.ctx[13]
        }

        set markupEditorToolShareStyles(e) {
            this.$$set({markupEditorToolShareStyles: e}), ka()
        }

        get markupEditorWillStartInteraction() {
            return this.$$.ctx[14]
        }

        set markupEditorWillStartInteraction(e) {
            this.$$set({markupEditorWillStartInteraction: e}), ka()
        }

        get markupEditorGridSize() {
            return this.$$.ctx[15]
        }

        set markupEditorGridSize(e) {
            this.$$set({markupEditorGridSize: e}), ka()
        }

        get markupEditorSnapThreshold() {
            return this.$$.ctx[16]
        }

        set markupEditorSnapThreshold(e) {
            this.$$set({markupEditorSnapThreshold: e}), ka()
        }

        get markupEditorSnapToContext() {
            return this.$$.ctx[17]
        }

        set markupEditorSnapToContext(e) {
            this.$$set({markupEditorSnapToContext: e}), ka()
        }

        get annotateGridSize() {
            return this.$$.ctx[18]
        }

        set annotateGridSize(e) {
            this.$$set({annotateGridSize: e}), ka()
        }

        get annotateSnapToContext() {
            return this.$$.ctx[19]
        }

        set annotateSnapToContext(e) {
            this.$$set({annotateSnapToContext: e}), ka()
        }

        get willRenderShapePresetToolbar() {
            return this.$$.ctx[20]
        }

        set willRenderShapePresetToolbar(e) {
            this.$$set({willRenderShapePresetToolbar: e}), ka()
        }

        get annotateTools() {
            return this.$$.ctx[21]
        }

        set annotateTools(e) {
            this.$$set({annotateTools: e}), ka()
        }

        get annotateToolShapes() {
            return this.$$.ctx[22]
        }

        set annotateToolShapes(e) {
            this.$$set({annotateToolShapes: e}), ka()
        }

        get annotateShapeControls() {
            return this.$$.ctx[23]
        }

        set annotateShapeControls(e) {
            this.$$set({annotateShapeControls: e}), ka()
        }

        get annotateActiveTool() {
            return this.$$.ctx[0]
        }

        set annotateActiveTool(e) {
            this.$$set({annotateActiveTool: e}), ka()
        }

        get annotateEnableButtonFlipVertical() {
            return this.$$.ctx[24]
        }

        set annotateEnableButtonFlipVertical(e) {
            this.$$set({annotateEnableButtonFlipVertical: e}), ka()
        }

        get annotateEnableSelectImagePreset() {
            return this.$$.ctx[25]
        }

        set annotateEnableSelectImagePreset(e) {
            this.$$set({annotateEnableSelectImagePreset: e}), ka()
        }

        get annotateEnableDropImagePreset() {
            return this.$$.ctx[26]
        }

        set annotateEnableDropImagePreset(e) {
            this.$$set({annotateEnableDropImagePreset: e}), ka()
        }

        get annotatePresets() {
            return this.$$.ctx[27]
        }

        set annotatePresets(e) {
            this.$$set({annotatePresets: e}), ka()
        }

        get annotateWillRenderShapePresetToolbar() {
            return this.$$.ctx[28]
        }

        set annotateWillRenderShapePresetToolbar(e) {
            this.$$set({annotateWillRenderShapePresetToolbar: e}), ka()
        }

        get annotateWillRenderShapeStyleControls() {
            return this.$$.ctx[29]
        }

        set annotateWillRenderShapeStyleControls(e) {
            this.$$set({annotateWillRenderShapeStyleControls: e}), ka()
        }

        get enableViewTool() {
            return this.$$.ctx[30]
        }

        set enableViewTool(e) {
            this.$$set({enableViewTool: e}), ka()
        }

        get enableSelectToolToAddShape() {
            return this.$$.ctx[31]
        }

        set enableSelectToolToAddShape(e) {
            this.$$set({enableSelectToolToAddShape: e}), ka()
        }

        get enableTapToAddText() {
            return this.$$.ctx[32]
        }

        set enableTapToAddText(e) {
            this.$$set({enableTapToAddText: e}), ka()
        }

        get enableAutoSelectMoveTool() {
            return this.$$.ctx[33]
        }

        set enableAutoSelectMoveTool(e) {
            this.$$set({enableAutoSelectMoveTool: e}), ka()
        }

        get enableMoveTool() {
            return this.$$.ctx[34]
        }

        set enableMoveTool(e) {
            this.$$set({enableMoveTool: e}), ka()
        }

        get enableMultiSelect() {
            return this.$$.ctx[35]
        }

        set enableMultiSelect(e) {
            this.$$set({enableMultiSelect: e}), ka()
        }

        get willRenderShapeControls() {
            return this.$$.ctx[36]
        }

        set willRenderShapeControls(e) {
            this.$$set({willRenderShapeControls: e}), ka()
        }

        get willRenderShapeTextControls() {
            return this.$$.ctx[37]
        }

        set willRenderShapeTextControls(e) {
            this.$$set({willRenderShapeTextControls: e}), ka()
        }

        get beforeAddShape() {
            return this.$$.ctx[38]
        }

        set beforeAddShape(e) {
            this.$$set({beforeAddShape: e}), ka()
        }

        get beforeRemoveShape() {
            return this.$$.ctx[39]
        }

        set beforeRemoveShape(e) {
            this.$$set({beforeRemoveShape: e}), ka()
        }

        get beforeDeselectShape() {
            return this.$$.ctx[40]
        }

        set beforeDeselectShape(e) {
            this.$$set({beforeDeselectShape: e}), ka()
        }

        get beforeSelectShape() {
            return this.$$.ctx[41]
        }

        set beforeSelectShape(e) {
            this.$$set({beforeSelectShape: e}), ka()
        }

        get beforeUpdateShape() {
            return this.$$.ctx[42]
        }

        set beforeUpdateShape(e) {
            this.$$set({beforeUpdateShape: e}), ka()
        }
    }]
};

function Fx(e) {
    let t, o, i;

    function n(t) {
        e[52](t)
    }

    let r = {
        utilKey: e[1],
        stores: e[5],
        locale: e[6],
        isActive: e[2],
        isActiveFraction: e[3],
        isVisible: e[4],
        mapScreenPointToImagePoint: e[44],
        mapImagePointToScreenPoint: e[43],
        shapes: e[46],
        toolbar: e[20] || e[7],
        toolShapes: e[21] || e[8],
        toolRetainStyles: e[9],
        shapeControls: e[22] || e[10],
        shapePresets: e[26],
        enableSelectToolToAddShape: e[29],
        enableTapToAddText: e[30],
        enableViewTool: e[31],
        enableMoveTool: e[32],
        enableAutoSelectMoveTool: e[33],
        enableMultiSelect: e[34],
        snapThreshold: e[16],
        gridSize: zo(e[18]) ? e[18] : e[15],
        enableSnapToContext: Ix(e[19]) ? e[19] : e[17],
        enableToolShareStyles: e[13],
        enablePresetSelectImage: e[24],
        enablePresetDropImage: e[25],
        enableButtonFlipVertical: e[23],
        parentRect: e[45],
        toolSelectRadius: e[11],
        textInputMode: e[12],
        willStartInteraction: e[42],
        willRenderPresetToolbar: e[27] || e[14],
        willRenderShapeStyleControls: e[28],
        hooks: {
            willRenderShapeControls: e[35],
            willRenderShapeTextControls: e[36],
            beforeAddShape: e[37],
            beforeRemoveShape: e[38],
            beforeDeselectShape: e[39],
            beforeSelectShape: e[40],
            beforeUpdateShape: e[41]
        }
    };
    return void 0 !== e[0] && (r.toolActive = e[0]), t = new Mx({props: r}), ha.push((() => _a(t, "toolActive", n))), t.$on("measure", e[53]), {
        c() {
            Na(t.$$.fragment)
        }, m(e, o) {
            Ha(t, e, o), i = !0
        }, p(e, i) {
            const n = {};
            32 & i[0] && (n.stores = e[5]), 64 & i[0] && (n.locale = e[6]), 4 & i[0] && (n.isActive = e[2]), 8 & i[0] && (n.isActiveFraction = e[3]), 16 & i[0] && (n.isVisible = e[4]), 8192 & i[1] && (n.mapScreenPointToImagePoint = e[44]), 4096 & i[1] && (n.mapImagePointToScreenPoint = e[43]), 1048704 & i[0] && (n.toolbar = e[20] || e[7]), 2097408 & i[0] && (n.toolShapes = e[21] || e[8]), 512 & i[0] && (n.toolRetainStyles = e[9]), 4195328 & i[0] && (n.shapeControls = e[22] || e[10]), 67108864 & i[0] && (n.shapePresets = e[26]), 536870912 & i[0] && (n.enableSelectToolToAddShape = e[29]), 1073741824 & i[0] && (n.enableTapToAddText = e[30]), 1 & i[1] && (n.enableViewTool = e[31]), 2 & i[1] && (n.enableMoveTool = e[32]), 4 & i[1] && (n.enableAutoSelectMoveTool = e[33]), 8 & i[1] && (n.enableMultiSelect = e[34]), 65536 & i[0] && (n.snapThreshold = e[16]), 294912 & i[0] && (n.gridSize = zo(e[18]) ? e[18] : e[15]), 655360 & i[0] && (n.enableSnapToContext = Ix(e[19]) ? e[19] : e[17]), 8192 & i[0] && (n.enableToolShareStyles = e[13]), 16777216 & i[0] && (n.enablePresetSelectImage = e[24]), 33554432 & i[0] && (n.enablePresetDropImage = e[25]), 8388608 & i[0] && (n.enableButtonFlipVertical = e[23]), 2048 & i[0] && (n.toolSelectRadius = e[11]), 4096 & i[0] && (n.textInputMode = e[12]), 2048 & i[1] && (n.willStartInteraction = e[42]), 134234112 & i[0] && (n.willRenderPresetToolbar = e[27] || e[14]), 268435456 & i[0] && (n.willRenderShapeStyleControls = e[28]), 2032 & i[1] && (n.hooks = {
                willRenderShapeControls: e[35],
                willRenderShapeTextControls: e[36],
                beforeAddShape: e[37],
                beforeRemoveShape: e[38],
                beforeDeselectShape: e[39],
                beforeSelectShape: e[40],
                beforeUpdateShape: e[41]
            }), !o && 1 & i[0] && (o = !0, n.toolActive = e[0], xa((() => o = !1))), t.$set(n)
        }, i(e) {
            i || (Ea(t.$$.fragment, e), i = !0)
        }, o(e) {
            Aa(t.$$.fragment, e), i = !1
        }, d(e) {
            ja(t, e)
        }
    }
}

function zx(e, t, o) {
    let i, n, r, a, s;
    let {isActive: l} = t, {isActiveFraction: c} = t, {isVisible: d} = t, {stores: u} = t, {locale: h = {}} = t, {markupEditorToolbar: p} = t, {markupEditorToolStyles: m} = t, {markupEditorToolRetainStyles: g} = t, {markupEditorShapeStyleControls: $} = t, {markupEditorToolSelectRadius: f} = t, {markupEditorTextInputMode: y} = t, {markupEditorToolShareStyles: b} = t, {willRenderShapePresetToolbar: x} = t, {markupEditorGridSize: v} = t, {markupEditorSnapThreshold: w} = t, {markupEditorSnapToContext: S = !0} = t, {decorateGridSize: k} = t, {decorateSnapToContext: C} = t, {decorateTools: T} = t, {decorateToolShapes: M} = t, {decorateShapeControls: P} = t, {decorateActiveTool: R} = t, {decorateEnableButtonFlipVertical: I = !1} = t, {decorateEnableSelectImagePreset: E = !1} = t, {decorateEnableDropImagePreset: A = !0} = t, {decoratePresets: L = []} = t, {decorateWillRenderShapePresetToolbar: F} = t, {decorateWillRenderShapeStyleControls: z} = t, {enableSelectToolToAddShape: D} = t, {enableTapToAddText: B} = t, {enableViewTool: O} = t, {enableMoveTool: W} = t, {enableAutoSelectMoveTool: V} = t, {enableMultiSelect: _} = t, {willRenderShapeControls: N} = t, {willRenderShapeTextControls: H} = t, {beforeAddShape: j} = t, {beforeRemoveShape: U} = t, {beforeDeselectShape: G} = t, {beforeSelectShape: Z} = t, {beforeUpdateShape: X} = t, {markupEditorWillStartInteraction: Y} = t;
    const {imageCropRect: q, imageDecoration: K, imageSelectionRectPresentation: J, imageTransformsInterpolated: Q} = u;
    return pr(e, J, (e => o(50, a = e))), pr(e, Q, (e => o(51, s = e))), e.$$set = e => {
        "isActive" in e && o(2, l = e.isActive), "isActiveFraction" in e && o(3, c = e.isActiveFraction), "isVisible" in e && o(4, d = e.isVisible), "stores" in e && o(5, u = e.stores), "locale" in e && o(6, h = e.locale), "markupEditorToolbar" in e && o(7, p = e.markupEditorToolbar), "markupEditorToolStyles" in e && o(8, m = e.markupEditorToolStyles), "markupEditorToolRetainStyles" in e && o(9, g = e.markupEditorToolRetainStyles), "markupEditorShapeStyleControls" in e && o(10, $ = e.markupEditorShapeStyleControls), "markupEditorToolSelectRadius" in e && o(11, f = e.markupEditorToolSelectRadius), "markupEditorTextInputMode" in e && o(12, y = e.markupEditorTextInputMode), "markupEditorToolShareStyles" in e && o(13, b = e.markupEditorToolShareStyles), "willRenderShapePresetToolbar" in e && o(14, x = e.willRenderShapePresetToolbar), "markupEditorGridSize" in e && o(15, v = e.markupEditorGridSize), "markupEditorSnapThreshold" in e && o(16, w = e.markupEditorSnapThreshold), "markupEditorSnapToContext" in e && o(17, S = e.markupEditorSnapToContext), "decorateGridSize" in e && o(18, k = e.decorateGridSize), "decorateSnapToContext" in e && o(19, C = e.decorateSnapToContext), "decorateTools" in e && o(20, T = e.decorateTools), "decorateToolShapes" in e && o(21, M = e.decorateToolShapes), "decorateShapeControls" in e && o(22, P = e.decorateShapeControls), "decorateActiveTool" in e && o(0, R = e.decorateActiveTool), "decorateEnableButtonFlipVertical" in e && o(23, I = e.decorateEnableButtonFlipVertical), "decorateEnableSelectImagePreset" in e && o(24, E = e.decorateEnableSelectImagePreset), "decorateEnableDropImagePreset" in e && o(25, A = e.decorateEnableDropImagePreset), "decoratePresets" in e && o(26, L = e.decoratePresets), "decorateWillRenderShapePresetToolbar" in e && o(27, F = e.decorateWillRenderShapePresetToolbar), "decorateWillRenderShapeStyleControls" in e && o(28, z = e.decorateWillRenderShapeStyleControls), "enableSelectToolToAddShape" in e && o(29, D = e.enableSelectToolToAddShape), "enableTapToAddText" in e && o(30, B = e.enableTapToAddText), "enableViewTool" in e && o(31, O = e.enableViewTool), "enableMoveTool" in e && o(32, W = e.enableMoveTool), "enableAutoSelectMoveTool" in e && o(33, V = e.enableAutoSelectMoveTool), "enableMultiSelect" in e && o(34, _ = e.enableMultiSelect), "willRenderShapeControls" in e && o(35, N = e.willRenderShapeControls), "willRenderShapeTextControls" in e && o(36, H = e.willRenderShapeTextControls), "beforeAddShape" in e && o(37, j = e.beforeAddShape), "beforeRemoveShape" in e && o(38, U = e.beforeRemoveShape), "beforeDeselectShape" in e && o(39, G = e.beforeDeselectShape), "beforeSelectShape" in e && o(40, Z = e.beforeSelectShape), "beforeUpdateShape" in e && o(41, X = e.beforeUpdateShape), "markupEditorWillStartInteraction" in e && o(42, Y = e.markupEditorWillStartInteraction)
    }, e.$$.update = () => {
        1048576 & e.$$.dirty[1] && o(49, i = s ? s.scale : 1), 786432 & e.$$.dirty[1] && o(44, n = e => {
            const t = me(e);
            return t.x -= a.x, t.y -= a.y, t.x /= i, t.y /= i, t
        }), 786432 & e.$$.dirty[1] && o(43, r = e => {
            const t = me(e);
            return t.x *= i, t.y *= i, t.x += a.x, t.y += a.y, t
        })
    }, [R, "decorate", l, c, d, u, h, p, m, g, $, f, y, b, x, v, w, S, k, C, T, M, P, I, E, A, L, F, z, D, B, O, W, V, _, N, H, j, U, G, Z, X, Y, r, n, q, K, J, Q, i, a, s, function (e) {
        R = e, o(0, R)
    }, function (t) {
        da.call(this, e, t)
    }]
}

var Dx = {
    util: ["decorate", class extends Ga {
        constructor(e) {
            super(), Ua(this, e, zx, Fx, lr, {
                name: 1,
                isActive: 2,
                isActiveFraction: 3,
                isVisible: 4,
                stores: 5,
                locale: 6,
                markupEditorToolbar: 7,
                markupEditorToolStyles: 8,
                markupEditorToolRetainStyles: 9,
                markupEditorShapeStyleControls: 10,
                markupEditorToolSelectRadius: 11,
                markupEditorTextInputMode: 12,
                markupEditorToolShareStyles: 13,
                willRenderShapePresetToolbar: 14,
                markupEditorGridSize: 15,
                markupEditorSnapThreshold: 16,
                markupEditorSnapToContext: 17,
                decorateGridSize: 18,
                decorateSnapToContext: 19,
                decorateTools: 20,
                decorateToolShapes: 21,
                decorateShapeControls: 22,
                decorateActiveTool: 0,
                decorateEnableButtonFlipVertical: 23,
                decorateEnableSelectImagePreset: 24,
                decorateEnableDropImagePreset: 25,
                decoratePresets: 26,
                decorateWillRenderShapePresetToolbar: 27,
                decorateWillRenderShapeStyleControls: 28,
                enableSelectToolToAddShape: 29,
                enableTapToAddText: 30,
                enableViewTool: 31,
                enableMoveTool: 32,
                enableAutoSelectMoveTool: 33,
                enableMultiSelect: 34,
                willRenderShapeControls: 35,
                willRenderShapeTextControls: 36,
                beforeAddShape: 37,
                beforeRemoveShape: 38,
                beforeDeselectShape: 39,
                beforeSelectShape: 40,
                beforeUpdateShape: 41,
                markupEditorWillStartInteraction: 42
            }, null, [-1, -1])
        }

        get name() {
            return this.$$.ctx[1]
        }

        get isActive() {
            return this.$$.ctx[2]
        }

        set isActive(e) {
            this.$$set({isActive: e}), ka()
        }

        get isActiveFraction() {
            return this.$$.ctx[3]
        }

        set isActiveFraction(e) {
            this.$$set({isActiveFraction: e}), ka()
        }

        get isVisible() {
            return this.$$.ctx[4]
        }

        set isVisible(e) {
            this.$$set({isVisible: e}), ka()
        }

        get stores() {
            return this.$$.ctx[5]
        }

        set stores(e) {
            this.$$set({stores: e}), ka()
        }

        get locale() {
            return this.$$.ctx[6]
        }

        set locale(e) {
            this.$$set({locale: e}), ka()
        }

        get markupEditorToolbar() {
            return this.$$.ctx[7]
        }

        set markupEditorToolbar(e) {
            this.$$set({markupEditorToolbar: e}), ka()
        }

        get markupEditorToolStyles() {
            return this.$$.ctx[8]
        }

        set markupEditorToolStyles(e) {
            this.$$set({markupEditorToolStyles: e}), ka()
        }

        get markupEditorToolRetainStyles() {
            return this.$$.ctx[9]
        }

        set markupEditorToolRetainStyles(e) {
            this.$$set({markupEditorToolRetainStyles: e}), ka()
        }

        get markupEditorShapeStyleControls() {
            return this.$$.ctx[10]
        }

        set markupEditorShapeStyleControls(e) {
            this.$$set({markupEditorShapeStyleControls: e}), ka()
        }

        get markupEditorToolSelectRadius() {
            return this.$$.ctx[11]
        }

        set markupEditorToolSelectRadius(e) {
            this.$$set({markupEditorToolSelectRadius: e}), ka()
        }

        get markupEditorTextInputMode() {
            return this.$$.ctx[12]
        }

        set markupEditorTextInputMode(e) {
            this.$$set({markupEditorTextInputMode: e}), ka()
        }

        get markupEditorToolShareStyles() {
            return this.$$.ctx[13]
        }

        set markupEditorToolShareStyles(e) {
            this.$$set({markupEditorToolShareStyles: e}), ka()
        }

        get willRenderShapePresetToolbar() {
            return this.$$.ctx[14]
        }

        set willRenderShapePresetToolbar(e) {
            this.$$set({willRenderShapePresetToolbar: e}), ka()
        }

        get markupEditorGridSize() {
            return this.$$.ctx[15]
        }

        set markupEditorGridSize(e) {
            this.$$set({markupEditorGridSize: e}), ka()
        }

        get markupEditorSnapThreshold() {
            return this.$$.ctx[16]
        }

        set markupEditorSnapThreshold(e) {
            this.$$set({markupEditorSnapThreshold: e}), ka()
        }

        get markupEditorSnapToContext() {
            return this.$$.ctx[17]
        }

        set markupEditorSnapToContext(e) {
            this.$$set({markupEditorSnapToContext: e}), ka()
        }

        get decorateGridSize() {
            return this.$$.ctx[18]
        }

        set decorateGridSize(e) {
            this.$$set({decorateGridSize: e}), ka()
        }

        get decorateSnapToContext() {
            return this.$$.ctx[19]
        }

        set decorateSnapToContext(e) {
            this.$$set({decorateSnapToContext: e}), ka()
        }

        get decorateTools() {
            return this.$$.ctx[20]
        }

        set decorateTools(e) {
            this.$$set({decorateTools: e}), ka()
        }

        get decorateToolShapes() {
            return this.$$.ctx[21]
        }

        set decorateToolShapes(e) {
            this.$$set({decorateToolShapes: e}), ka()
        }

        get decorateShapeControls() {
            return this.$$.ctx[22]
        }

        set decorateShapeControls(e) {
            this.$$set({decorateShapeControls: e}), ka()
        }

        get decorateActiveTool() {
            return this.$$.ctx[0]
        }

        set decorateActiveTool(e) {
            this.$$set({decorateActiveTool: e}), ka()
        }

        get decorateEnableButtonFlipVertical() {
            return this.$$.ctx[23]
        }

        set decorateEnableButtonFlipVertical(e) {
            this.$$set({decorateEnableButtonFlipVertical: e}), ka()
        }

        get decorateEnableSelectImagePreset() {
            return this.$$.ctx[24]
        }

        set decorateEnableSelectImagePreset(e) {
            this.$$set({decorateEnableSelectImagePreset: e}), ka()
        }

        get decorateEnableDropImagePreset() {
            return this.$$.ctx[25]
        }

        set decorateEnableDropImagePreset(e) {
            this.$$set({decorateEnableDropImagePreset: e}), ka()
        }

        get decoratePresets() {
            return this.$$.ctx[26]
        }

        set decoratePresets(e) {
            this.$$set({decoratePresets: e}), ka()
        }

        get decorateWillRenderShapePresetToolbar() {
            return this.$$.ctx[27]
        }

        set decorateWillRenderShapePresetToolbar(e) {
            this.$$set({decorateWillRenderShapePresetToolbar: e}), ka()
        }

        get decorateWillRenderShapeStyleControls() {
            return this.$$.ctx[28]
        }

        set decorateWillRenderShapeStyleControls(e) {
            this.$$set({decorateWillRenderShapeStyleControls: e}), ka()
        }

        get enableSelectToolToAddShape() {
            return this.$$.ctx[29]
        }

        set enableSelectToolToAddShape(e) {
            this.$$set({enableSelectToolToAddShape: e}), ka()
        }

        get enableTapToAddText() {
            return this.$$.ctx[30]
        }

        set enableTapToAddText(e) {
            this.$$set({enableTapToAddText: e}), ka()
        }

        get enableViewTool() {
            return this.$$.ctx[31]
        }

        set enableViewTool(e) {
            this.$$set({enableViewTool: e}), ka()
        }

        get enableMoveTool() {
            return this.$$.ctx[32]
        }

        set enableMoveTool(e) {
            this.$$set({enableMoveTool: e}), ka()
        }

        get enableAutoSelectMoveTool() {
            return this.$$.ctx[33]
        }

        set enableAutoSelectMoveTool(e) {
            this.$$set({enableAutoSelectMoveTool: e}), ka()
        }

        get enableMultiSelect() {
            return this.$$.ctx[34]
        }

        set enableMultiSelect(e) {
            this.$$set({enableMultiSelect: e}), ka()
        }

        get willRenderShapeControls() {
            return this.$$.ctx[35]
        }

        set willRenderShapeControls(e) {
            this.$$set({willRenderShapeControls: e}), ka()
        }

        get willRenderShapeTextControls() {
            return this.$$.ctx[36]
        }

        set willRenderShapeTextControls(e) {
            this.$$set({willRenderShapeTextControls: e}), ka()
        }

        get beforeAddShape() {
            return this.$$.ctx[37]
        }

        set beforeAddShape(e) {
            this.$$set({beforeAddShape: e}), ka()
        }

        get beforeRemoveShape() {
            return this.$$.ctx[38]
        }

        set beforeRemoveShape(e) {
            this.$$set({beforeRemoveShape: e}), ka()
        }

        get beforeDeselectShape() {
            return this.$$.ctx[39]
        }

        set beforeDeselectShape(e) {
            this.$$set({beforeDeselectShape: e}), ka()
        }

        get beforeSelectShape() {
            return this.$$.ctx[40]
        }

        set beforeSelectShape(e) {
            this.$$set({beforeSelectShape: e}), ka()
        }

        get beforeUpdateShape() {
            return this.$$.ctx[41]
        }

        set beforeUpdateShape(e) {
            this.$$set({beforeUpdateShape: e}), ka()
        }

        get markupEditorWillStartInteraction() {
            return this.$$.ctx[42]
        }

        set markupEditorWillStartInteraction(e) {
            this.$$set({markupEditorWillStartInteraction: e}), ka()
        }
    }]
};

function Bx(e) {
    let t, o;
    return t = new Mx({
        props: {
            stores: e[3],
            locale: e[4],
            isActive: e[0],
            isActiveFraction: e[1],
            isVisible: e[2],
            mapScreenPointToImagePoint: e[26],
            mapImagePointToScreenPoint: e[25],
            utilKey: "sticker",
            shapePresets: e[5],
            shapes: e[6] ? e[35] : e[36],
            toolActive: "preset",
            imageFlipX: !!e[6] && e[24],
            imageFlipY: !!e[6] && e[23],
            imageRotation: e[6] ? e[31] : 0,
            parentRect: e[6] ? e[37] : e[33],
            snapThreshold: e[29],
            gridSize: e[28],
            enableMultiSelect: e[12],
            enableSnapToContext: e[27],
            enablePresetDropImage: e[7],
            enablePresetSelectImage: e[30],
            enableButtonFlipVertical: e[10] || e[8],
            toolSelectRadius: e[15],
            willStartInteraction: e[22],
            willRenderPresetToolbar: e[11] || e[9] || e[16],
            hooks: {
                willRenderShapeControls: e[13],
                willRenderShapeTextControls: e[14],
                beforeAddShape: e[17],
                beforeRemoveShape: e[18],
                beforeDeselectShape: e[19],
                beforeSelectShape: e[20],
                beforeUpdateShape: e[21]
            }
        }
    }), t.$on("measure", e[60]), {
        c() {
            Na(t.$$.fragment)
        }, m(e, i) {
            Ha(t, e, i), o = !0
        }, p(e, o) {
            const i = {};
            8 & o[0] && (i.stores = e[3]), 16 & o[0] && (i.locale = e[4]), 1 & o[0] && (i.isActive = e[0]), 2 & o[0] && (i.isActiveFraction = e[1]), 4 & o[0] && (i.isVisible = e[2]), 67108864 & o[0] && (i.mapScreenPointToImagePoint = e[26]), 33554432 & o[0] && (i.mapImagePointToScreenPoint = e[25]), 32 & o[0] && (i.shapePresets = e[5]), 64 & o[0] && (i.shapes = e[6] ? e[35] : e[36]), 16777280 & o[0] && (i.imageFlipX = !!e[6] && e[24]), 8388672 & o[0] && (i.imageFlipY = !!e[6] && e[23]), 64 & o[0] | 1 & o[1] && (i.imageRotation = e[6] ? e[31] : 0), 64 & o[0] && (i.parentRect = e[6] ? e[37] : e[33]), 536870912 & o[0] && (i.snapThreshold = e[29]), 268435456 & o[0] && (i.gridSize = e[28]), 4096 & o[0] && (i.enableMultiSelect = e[12]), 134217728 & o[0] && (i.enableSnapToContext = e[27]), 128 & o[0] && (i.enablePresetDropImage = e[7]), 1073741824 & o[0] && (i.enablePresetSelectImage = e[30]), 1280 & o[0] && (i.enableButtonFlipVertical = e[10] || e[8]), 32768 & o[0] && (i.toolSelectRadius = e[15]), 4194304 & o[0] && (i.willStartInteraction = e[22]), 68096 & o[0] && (i.willRenderPresetToolbar = e[11] || e[9] || e[16]), 4087808 & o[0] && (i.hooks = {
                willRenderShapeControls: e[13],
                willRenderShapeTextControls: e[14],
                beforeAddShape: e[17],
                beforeRemoveShape: e[18],
                beforeDeselectShape: e[19],
                beforeSelectShape: e[20],
                beforeUpdateShape: e[21]
            }), t.$set(i)
        }, i(e) {
            o || (Ea(t.$$.fragment, e), o = !0)
        }, o(e) {
            Aa(t.$$.fragment, e), o = !1
        }, d(e) {
            ja(t, e)
        }
    }
}

function Ox(e, t, o) {
    let i, n, r, a, s, l, c, d, u, h, p, m, g, $, f;
    let {isActive: y} = t, {isActiveFraction: b} = t, {isVisible: x} = t, {stores: v} = t, {locale: w = {}} = t, {stickers: S = []} = t, {stickerForceEnable: k = !1} = t, {stickerStickToImage: C = !1} = t, {stickerEnableSelectImagePreset: T = !0} = t, {stickerEnableDropImagePreset: M = !0} = t, {stickerEnableButtonFlipVertical: P = !1} = t, {stickerWillRenderShapePresetToolbar: R} = t, {stickerEnableSelectImage: I = !0} = t, {stickersEnableButtonFlipVertical: E = !1} = t, {stickersWillRenderShapePresetToolbar: A} = t, {markupEditorGridSize: L = 0} = t, {markupEditorSnapThreshold: F = 0} = t, {markupEditorSnapToContext: z = !1} = t, {enableMultiSelect: D} = t, {annotateGridSize: B} = t, {annotateSnapToContext: O} = t, {decorateGridSize: W} = t, {decorateSnapToContext: V} = t, {willRenderShapeControls: _} = t, {willRenderShapeTextControls: N} = t, {markupEditorToolSelectRadius: H} = t, {willRenderShapePresetToolbar: j} = t, {beforeAddShape: U} = t, {beforeRemoveShape: G} = t, {beforeDeselectShape: Z} = t, {beforeSelectShape: X} = t, {beforeUpdateShape: Y} = t, {markupEditorWillStartInteraction: q} = t;
    const {
        rootRect: K,
        imageCropRect: J,
        imageSelectionRectPresentation: Q,
        imageAnnotation: ee,
        imageDecoration: te,
        imageSize: oe,
        imageTransforms: ie,
        imageTransformsInterpolated: ne,
        imageRotation: re,
        imageFlipX: ae,
        imageFlipY: se
    } = v;
    return pr(e, K, (e => o(59, $ = e))), pr(e, Q, (e => o(55, d = e))), pr(e, oe, (e => o(58, g = e))), pr(e, ie, (e => o(57, m = e))), pr(e, ne, (e => o(56, p = e))), pr(e, re, (e => o(31, f = e))), pr(e, ae, (e => o(24, h = e))), pr(e, se, (e => o(23, u = e))), e.$$set = e => {
        "isActive" in e && o(0, y = e.isActive), "isActiveFraction" in e && o(1, b = e.isActiveFraction), "isVisible" in e && o(2, x = e.isVisible), "stores" in e && o(3, v = e.stores), "locale" in e && o(4, w = e.locale), "stickers" in e && o(5, S = e.stickers), "stickerForceEnable" in e && o(44, k = e.stickerForceEnable), "stickerStickToImage" in e && o(6, C = e.stickerStickToImage), "stickerEnableSelectImagePreset" in e && o(45, T = e.stickerEnableSelectImagePreset), "stickerEnableDropImagePreset" in e && o(7, M = e.stickerEnableDropImagePreset), "stickerEnableButtonFlipVertical" in e && o(8, P = e.stickerEnableButtonFlipVertical), "stickerWillRenderShapePresetToolbar" in e && o(9, R = e.stickerWillRenderShapePresetToolbar), "stickerEnableSelectImage" in e && o(46, I = e.stickerEnableSelectImage), "stickersEnableButtonFlipVertical" in e && o(10, E = e.stickersEnableButtonFlipVertical), "stickersWillRenderShapePresetToolbar" in e && o(11, A = e.stickersWillRenderShapePresetToolbar), "markupEditorGridSize" in e && o(47, L = e.markupEditorGridSize), "markupEditorSnapThreshold" in e && o(48, F = e.markupEditorSnapThreshold), "markupEditorSnapToContext" in e && o(49, z = e.markupEditorSnapToContext), "enableMultiSelect" in e && o(12, D = e.enableMultiSelect), "annotateGridSize" in e && o(50, B = e.annotateGridSize), "annotateSnapToContext" in e && o(51, O = e.annotateSnapToContext), "decorateGridSize" in e && o(52, W = e.decorateGridSize), "decorateSnapToContext" in e && o(53, V = e.decorateSnapToContext), "willRenderShapeControls" in e && o(13, _ = e.willRenderShapeControls), "willRenderShapeTextControls" in e && o(14, N = e.willRenderShapeTextControls), "markupEditorToolSelectRadius" in e && o(15, H = e.markupEditorToolSelectRadius), "willRenderShapePresetToolbar" in e && o(16, j = e.willRenderShapePresetToolbar), "beforeAddShape" in e && o(17, U = e.beforeAddShape), "beforeRemoveShape" in e && o(18, G = e.beforeRemoveShape), "beforeDeselectShape" in e && o(19, Z = e.beforeDeselectShape), "beforeSelectShape" in e && o(20, X = e.beforeSelectShape), "beforeUpdateShape" in e && o(21, Y = e.beforeUpdateShape), "markupEditorWillStartInteraction" in e && o(22, q = e.markupEditorWillStartInteraction)
    }, e.$$.update = () => {
        33554432 & e.$$.dirty[1] && o(54, i = p ? p.scale : 1), 49152 & e.$$.dirty[1] && o(30, n = !1 !== T && I), 131072 & e.$$.dirty[1] && o(29, r = F), 64 & e.$$.dirty[0] | 2686976 & e.$$.dirty[1] && o(28, a = C ? zo(B) ? B : L : zo(W) ? W : L), 64 & e.$$.dirty[0] | 5505024 & e.$$.dirty[1] && o(27, s = C ? Ix(O) ? O : z : Ix(V) ? V : z), 25165888 & e.$$.dirty[0] | 528482304 & e.$$.dirty[1] && o(26, l = C ? e => Rx(e, $, g, p.origin, p.translation, m.rotation.z, p.scale, h, u) : e => {
            const t = me(e);
            return t.x -= d.x, t.y -= d.y, t.x /= i, t.y /= i, t
        }), 25165888 & e.$$.dirty[0] | 528482304 & e.$$.dirty[1] && o(25, c = C ? e => Px(e, $, g, p.origin, p.translation, m.rotation.z, p.scale, h, u) : e => {
            const t = me(e);
            return t.x *= i, t.y *= i, t.x += d.x, t.y += d.y, t
        })
    }, [y, b, x, v, w, S, C, M, P, R, E, A, D, _, N, H, j, U, G, Z, X, Y, q, u, h, c, l, s, a, r, n, f, K, J, Q, ee, te, oe, ie, ne, re, ae, se, "sticker", k, T, I, L, F, z, B, O, W, V, i, d, p, m, g, $, function (t) {
        da.call(this, e, t)
    }]
}

var Wx = {
    util: ["sticker", class extends Ga {
        constructor(e) {
            super(), Ua(this, e, Ox, Bx, lr, {
                name: 43,
                isActive: 0,
                isActiveFraction: 1,
                isVisible: 2,
                stores: 3,
                locale: 4,
                stickers: 5,
                stickerForceEnable: 44,
                stickerStickToImage: 6,
                stickerEnableSelectImagePreset: 45,
                stickerEnableDropImagePreset: 7,
                stickerEnableButtonFlipVertical: 8,
                stickerWillRenderShapePresetToolbar: 9,
                stickerEnableSelectImage: 46,
                stickersEnableButtonFlipVertical: 10,
                stickersWillRenderShapePresetToolbar: 11,
                markupEditorGridSize: 47,
                markupEditorSnapThreshold: 48,
                markupEditorSnapToContext: 49,
                enableMultiSelect: 12,
                annotateGridSize: 50,
                annotateSnapToContext: 51,
                decorateGridSize: 52,
                decorateSnapToContext: 53,
                willRenderShapeControls: 13,
                willRenderShapeTextControls: 14,
                markupEditorToolSelectRadius: 15,
                willRenderShapePresetToolbar: 16,
                beforeAddShape: 17,
                beforeRemoveShape: 18,
                beforeDeselectShape: 19,
                beforeSelectShape: 20,
                beforeUpdateShape: 21,
                markupEditorWillStartInteraction: 22
            }, null, [-1, -1])
        }

        get name() {
            return this.$$.ctx[43]
        }

        get isActive() {
            return this.$$.ctx[0]
        }

        set isActive(e) {
            this.$$set({isActive: e}), ka()
        }

        get isActiveFraction() {
            return this.$$.ctx[1]
        }

        set isActiveFraction(e) {
            this.$$set({isActiveFraction: e}), ka()
        }

        get isVisible() {
            return this.$$.ctx[2]
        }

        set isVisible(e) {
            this.$$set({isVisible: e}), ka()
        }

        get stores() {
            return this.$$.ctx[3]
        }

        set stores(e) {
            this.$$set({stores: e}), ka()
        }

        get locale() {
            return this.$$.ctx[4]
        }

        set locale(e) {
            this.$$set({locale: e}), ka()
        }

        get stickers() {
            return this.$$.ctx[5]
        }

        set stickers(e) {
            this.$$set({stickers: e}), ka()
        }

        get stickerForceEnable() {
            return this.$$.ctx[44]
        }

        set stickerForceEnable(e) {
            this.$$set({stickerForceEnable: e}), ka()
        }

        get stickerStickToImage() {
            return this.$$.ctx[6]
        }

        set stickerStickToImage(e) {
            this.$$set({stickerStickToImage: e}), ka()
        }

        get stickerEnableSelectImagePreset() {
            return this.$$.ctx[45]
        }

        set stickerEnableSelectImagePreset(e) {
            this.$$set({stickerEnableSelectImagePreset: e}), ka()
        }

        get stickerEnableDropImagePreset() {
            return this.$$.ctx[7]
        }

        set stickerEnableDropImagePreset(e) {
            this.$$set({stickerEnableDropImagePreset: e}), ka()
        }

        get stickerEnableButtonFlipVertical() {
            return this.$$.ctx[8]
        }

        set stickerEnableButtonFlipVertical(e) {
            this.$$set({stickerEnableButtonFlipVertical: e}), ka()
        }

        get stickerWillRenderShapePresetToolbar() {
            return this.$$.ctx[9]
        }

        set stickerWillRenderShapePresetToolbar(e) {
            this.$$set({stickerWillRenderShapePresetToolbar: e}), ka()
        }

        get stickerEnableSelectImage() {
            return this.$$.ctx[46]
        }

        set stickerEnableSelectImage(e) {
            this.$$set({stickerEnableSelectImage: e}), ka()
        }

        get stickersEnableButtonFlipVertical() {
            return this.$$.ctx[10]
        }

        set stickersEnableButtonFlipVertical(e) {
            this.$$set({stickersEnableButtonFlipVertical: e}), ka()
        }

        get stickersWillRenderShapePresetToolbar() {
            return this.$$.ctx[11]
        }

        set stickersWillRenderShapePresetToolbar(e) {
            this.$$set({stickersWillRenderShapePresetToolbar: e}), ka()
        }

        get markupEditorGridSize() {
            return this.$$.ctx[47]
        }

        set markupEditorGridSize(e) {
            this.$$set({markupEditorGridSize: e}), ka()
        }

        get markupEditorSnapThreshold() {
            return this.$$.ctx[48]
        }

        set markupEditorSnapThreshold(e) {
            this.$$set({markupEditorSnapThreshold: e}), ka()
        }

        get markupEditorSnapToContext() {
            return this.$$.ctx[49]
        }

        set markupEditorSnapToContext(e) {
            this.$$set({markupEditorSnapToContext: e}), ka()
        }

        get enableMultiSelect() {
            return this.$$.ctx[12]
        }

        set enableMultiSelect(e) {
            this.$$set({enableMultiSelect: e}), ka()
        }

        get annotateGridSize() {
            return this.$$.ctx[50]
        }

        set annotateGridSize(e) {
            this.$$set({annotateGridSize: e}), ka()
        }

        get annotateSnapToContext() {
            return this.$$.ctx[51]
        }

        set annotateSnapToContext(e) {
            this.$$set({annotateSnapToContext: e}), ka()
        }

        get decorateGridSize() {
            return this.$$.ctx[52]
        }

        set decorateGridSize(e) {
            this.$$set({decorateGridSize: e}), ka()
        }

        get decorateSnapToContext() {
            return this.$$.ctx[53]
        }

        set decorateSnapToContext(e) {
            this.$$set({decorateSnapToContext: e}), ka()
        }

        get willRenderShapeControls() {
            return this.$$.ctx[13]
        }

        set willRenderShapeControls(e) {
            this.$$set({willRenderShapeControls: e}), ka()
        }

        get willRenderShapeTextControls() {
            return this.$$.ctx[14]
        }

        set willRenderShapeTextControls(e) {
            this.$$set({willRenderShapeTextControls: e}), ka()
        }

        get markupEditorToolSelectRadius() {
            return this.$$.ctx[15]
        }

        set markupEditorToolSelectRadius(e) {
            this.$$set({markupEditorToolSelectRadius: e}), ka()
        }

        get willRenderShapePresetToolbar() {
            return this.$$.ctx[16]
        }

        set willRenderShapePresetToolbar(e) {
            this.$$set({willRenderShapePresetToolbar: e}), ka()
        }

        get beforeAddShape() {
            return this.$$.ctx[17]
        }

        set beforeAddShape(e) {
            this.$$set({beforeAddShape: e}), ka()
        }

        get beforeRemoveShape() {
            return this.$$.ctx[18]
        }

        set beforeRemoveShape(e) {
            this.$$set({beforeRemoveShape: e}), ka()
        }

        get beforeDeselectShape() {
            return this.$$.ctx[19]
        }

        set beforeDeselectShape(e) {
            this.$$set({beforeDeselectShape: e}), ka()
        }

        get beforeSelectShape() {
            return this.$$.ctx[20]
        }

        set beforeSelectShape(e) {
            this.$$set({beforeSelectShape: e}), ka()
        }

        get beforeUpdateShape() {
            return this.$$.ctx[21]
        }

        set beforeUpdateShape(e) {
            this.$$set({beforeUpdateShape: e}), ka()
        }

        get markupEditorWillStartInteraction() {
            return this.$$.ctx[22]
        }

        set markupEditorWillStartInteraction(e) {
            this.$$set({markupEditorWillStartInteraction: e}), ka()
        }
    }, ({
            stickers: e,
            stickerEnableSelectImage: t,
            stickerEnableSelectImagePreset: o,
            stickerEnableDropImagePreset: i,
            stickerForceEnable: n
        }) => e && e.length || t || o || i || n]
};

function Vx(e) {
    let t, o, i = (e[14](e[36].value) || "") + "";
    return {
        c() {
            t = new Yr(!1), o = Or(), t.a = o
        }, m(e, n) {
            t.m(i, e, n), Ar(e, o, n)
        }, p(e, o) {
            32 & o[1] && i !== (i = (e[14](e[36].value) || "") + "") && t.p(i)
        }, i: tr, o: tr, d(e) {
            e && Lr(o), e && t.d()
        }
    }
}

function _x(e) {
    let t, o;
    return t = new pp({props: {items: e[16](e[36].value)}}), {
        c() {
            Na(t.$$.fragment)
        }, m(e, i) {
            Ha(t, e, i), o = !0
        }, p(e, o) {
            const i = {};
            32 & o[1] && (i.items = e[16](e[36].value)), t.$set(i)
        }, i(e) {
            o || (Ea(t.$$.fragment, e), o = !0)
        }, o(e) {
            Aa(t.$$.fragment, e), o = !1
        }, d(e) {
            ja(t, e)
        }
    }
}

function Nx(e) {
    let t, o, i, n, r, a, s, l, c = (M(e[36].label) ? e[36].label(e[1]) : e[36].label) + "";
    const d = [_x, Vx], u = [];

    function h(e, t) {
        return 32 & t[1] && (o = null), null == o && (o = !!e[15](e[36].value)), o ? 0 : 1
    }

    return i = h(e, [-1, -1]), n = u[i] = d[i](e), {
        c() {
            t = Fr("div"), n.c(), r = Br(), a = Fr("span"), s = Dr(c), Nr(t, "slot", "option")
        }, m(e, o) {
            Ar(e, t, o), u[i].m(t, null), Rr(t, r), Rr(t, a), Rr(a, s), l = !0
        }, p(e, o) {
            let a = i;
            i = h(e, o), i === a ? u[i].p(e, o) : (Ra(), Aa(u[a], 1, 1, (() => {
                u[a] = null
            })), Ia(), n = u[i], n ? n.p(e, o) : (n = u[i] = d[i](e), n.c()), Ea(n, 1), n.m(t, r)), (!l || 2 & o[0] | 32 & o[1]) && c !== (c = (M(e[36].label) ? e[36].label(e[1]) : e[36].label) + "") && Ur(s, c)
        }, i(e) {
            l || (Ea(n), l = !0)
        }, o(e) {
            Aa(n), l = !1
        }, d(e) {
            e && Lr(t), u[i].d()
        }
    }
}

function Hx(e) {
    let t, o;
    return t = new Eu({
        props: {
            locale: e[1],
            class: "PinturaControlList",
            layout: "row",
            options: e[2],
            selectedIndex: e[6],
            onchange: e[12],
            $$slots: {option: [Nx, ({option: e}) => ({36: e}), ({option: e}) => [0, e ? 32 : 0]]},
            $$scope: {ctx: e}
        }
    }), {
        c() {
            Na(t.$$.fragment)
        }, m(e, i) {
            Ha(t, e, i), o = !0
        }, p(e, o) {
            const i = {};
            2 & o[0] && (i.locale = e[1]), 4 & o[0] && (i.options = e[2]), 64 & o[0] && (i.selectedIndex = e[6]), 2 & o[0] | 96 & o[1] && (i.$$scope = {
                dirty: o,
                ctx: e
            }), t.$set(i)
        }, i(e) {
            o || (Ea(t.$$.fragment, e), o = !0)
        }, o(e) {
            Aa(t.$$.fragment, e), o = !1
        }, d(e) {
            ja(t, e)
        }
    }
}

function jx(e) {
    let t, o, i, n, r;
    return o = new Bb({
        props: {
            locale: e[1],
            class: "PinturaControlPanels",
            shapeProps: e[4],
            onchange: e[13],
            controls: e[3],
            scrollElasticity: e[7]
        }
    }), n = new Ep({props: {elasticity: e[10], $$slots: {default: [Hx]}, $$scope: {ctx: e}}}), {
        c() {
            t = Fr("div"), Na(o.$$.fragment), i = Br(), Na(n.$$.fragment), Nr(t, "slot", "footer"), Zr(t, "transform", e[5])
        }, m(e, a) {
            Ar(e, t, a), Ha(o, t, null), Rr(t, i), Ha(n, t, null), r = !0
        }, p(e, i) {
            const r = {};
            2 & i[0] && (r.locale = e[1]), 16 & i[0] && (r.shapeProps = e[4]), 8 & i[0] && (r.controls = e[3]), 128 & i[0] && (r.scrollElasticity = e[7]), o.$set(r);
            const a = {};
            70 & i[0] | 64 & i[1] && (a.$$scope = {dirty: i, ctx: e}), n.$set(a), 32 & i[0] && Zr(t, "transform", e[5])
        }, i(e) {
            r || (Ea(o.$$.fragment, e), Ea(n.$$.fragment, e), r = !0)
        }, o(e) {
            Aa(o.$$.fragment, e), Aa(n.$$.fragment, e), r = !1
        }, d(e) {
            e && Lr(t), ja(o), ja(n)
        }
    }
}

function Ux(e) {
    let t, o;
    return t = new Wf({props: {$$slots: {footer: [jx]}, $$scope: {ctx: e}}}), t.$on("measure", e[25]), {
        c() {
            Na(t.$$.fragment)
        }, m(e, i) {
            Ha(t, e, i), o = !0
        }, p(e, o) {
            const i = {};
            254 & o[0] | 64 & o[1] && (i.$$scope = {dirty: o, ctx: e}), t.$set(i)
        }, i(e) {
            o || (Ea(t.$$.fragment, e), o = !0)
        }, o(e) {
            Aa(t.$$.fragment, e), o = !1
        }, d(e) {
            ja(t, e)
        }
    }
}

function Gx(e, t, o) {
    let i, n, r, a, s, l, c, d, u = tr, h = () => (u(), u = ur(p, (e => o(22, s = e))), p);
    e.$$.on_destroy.push((() => u()));
    let {isActive: p} = t;
    h();
    let {stores: m} = t, {locale: g = {}} = t, {frameStyles: $ = {}} = t, {frameOptions: f = []} = t, {markupEditorShapeStyleControls: y} = t;
    const b = ca("elasticityMultiplier");
    pr(e, b, (e => o(24, d = e)));
    const {
        history: x,
        animation: v,
        scrollElasticity: w,
        imageFrame: S,
        allowPan: k,
        allowZoom: C,
        allowZoomControls: T,
        allowPlayPause: M
    } = m;
    pr(e, v, (e => o(23, l = e))), pr(e, S, (e => o(4, c = e)));
    let P = {};
    let R;
    const I = bc(l ? 20 : 0);
    return pr(e, I, (e => o(21, a = e))), e.$$set = e => {
        "isActive" in e && h(o(0, p = e.isActive)), "stores" in e && o(19, m = e.stores), "locale" in e && o(1, g = e.locale), "frameStyles" in e && o(20, $ = e.frameStyles), "frameOptions" in e && o(2, f = e.frameOptions), "markupEditorShapeStyleControls" in e && o(3, y = e.markupEditorShapeStyleControls)
    }, e.$$.update = () => {
        4194304 & e.$$.dirty[0] && k.set(s), 4194304 & e.$$.dirty[0] && C.set(s), 4194304 & e.$$.dirty[0] && T.set(s), 4194304 & e.$$.dirty[0] && s && M.set(!0), 16777216 & e.$$.dirty[0] && o(7, i = d * w), 20 & e.$$.dirty[0] && o(6, n = c ? f.findIndex((([e]) => e === c.id)) : 0), 12582912 & e.$$.dirty[0] && l && I.set(s ? 0 : 20), 2097152 & e.$$.dirty[0] && o(5, r = a ? `translateY(${a}px)` : "none")
    }, [p, g, f, y, c, r, n, i, b, v, w, S, ({value: e}) => {
        const t = $[e];
        if (!t || !t.shape) return S.set(void 0), void x.write();
        const {shape: o} = t,
            i = {id: e, ...yi(o), ...Object.keys(P).reduce(((e, t) => o[t] ? (e[t] = P[t], e) : e), {})};
        S.set(i), x.write()
    }, function (e) {
        Bo(e, "frameColor") && (P.frameColor = e.frameColor), c && (kn(c, e), S.set(c), clearTimeout(R), R = setTimeout((() => {
            x.write()
        }), 200))
    }, e => {
        const t = $[e];
        var o;
        if (t && t.thumb) return o = t.thumb, /div/i.test(o) || Ob(o) ? o : /rect|path|circle|line|<g>/i.test(o) ? `<svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" stroke-width="1" stroke="currentColor" fill="none" aria-hidden="true" focusable="false" stroke-linecap="round" stroke-linejoin="round">${o}</svg>` : `<img src="${o}" alt=""/>`
    }, e => {
        const t = $[e];
        return !(!t || !t.thumb) && Oo(t.thumb)
    }, e => $[e].thumb, I, "frame", m, $, a, s, l, d, function (t) {
        da.call(this, e, t)
    }]
}

var Zx = {
    util: ["frame", class extends Ga {
        constructor(e) {
            super(), Ua(this, e, Gx, Ux, lr, {
                name: 18,
                isActive: 0,
                stores: 19,
                locale: 1,
                frameStyles: 20,
                frameOptions: 2,
                markupEditorShapeStyleControls: 3
            }, null, [-1, -1])
        }

        get name() {
            return this.$$.ctx[18]
        }

        get isActive() {
            return this.$$.ctx[0]
        }

        set isActive(e) {
            this.$$set({isActive: e}), ka()
        }

        get stores() {
            return this.$$.ctx[19]
        }

        set stores(e) {
            this.$$set({stores: e}), ka()
        }

        get locale() {
            return this.$$.ctx[1]
        }

        set locale(e) {
            this.$$set({locale: e}), ka()
        }

        get frameStyles() {
            return this.$$.ctx[20]
        }

        set frameStyles(e) {
            this.$$set({frameStyles: e}), ka()
        }

        get frameOptions() {
            return this.$$.ctx[2]
        }

        set frameOptions(e) {
            this.$$set({frameOptions: e}), ka()
        }

        get markupEditorShapeStyleControls() {
            return this.$$.ctx[3]
        }

        set markupEditorShapeStyleControls(e) {
            this.$$set({markupEditorShapeStyleControls: e}), ka()
        }
    }, ({src: e}) => e && !Us(e)]
};

function Xx(e) {
    let t, o, i, n, r, a, s, l;
    return {
        c() {
            t = Fr("div"), o = Fr("input"), n = Br(), r = Fr("label"), a = Dr(e[1]), Nr(o, "id", e[0]), Nr(o, "type", "number"), Nr(o, "min", "1"), Nr(o, "inputmode", "numeric"), Nr(o, "pattern", "[0-9]*"), Nr(o, "data-state", e[3]), Nr(o, "autocomplete", "off"), Nr(o, "placeholder", e[4]), o.value = i = void 0 === e[5] ? "" : e[7](e[5] + ""), Nr(r, "for", e[0]), Nr(r, "title", e[2]), Nr(r, "aria-label", e[2]), Nr(t, "class", "PinturaInputDimension")
        }, m(i, c) {
            Ar(i, t, c), Rr(t, o), Rr(t, n), Rr(t, r), Rr(r, a), s || (l = Wr(o, "input", e[8]), s = !0)
        }, p(e, [t]) {
            1 & t && Nr(o, "id", e[0]), 8 & t && Nr(o, "data-state", e[3]), 16 & t && Nr(o, "placeholder", e[4]), 160 & t && i !== (i = void 0 === e[5] ? "" : e[7](e[5] + "")) && o.value !== i && (o.value = i), 2 & t && Ur(a, e[1]), 1 & t && Nr(r, "for", e[0]), 4 & t && Nr(r, "title", e[2]), 4 & t && Nr(r, "aria-label", e[2])
        }, i: tr, o: tr, d(e) {
            e && Lr(t), s = !1, l()
        }
    }
}

function Yx(e, t, o) {
    let {id: i} = t, {label: n} = t, {title: r} = t, {state: a} = t, {placeholder: s} = t, {value: l} = t, {onchange: c} = t, {format: d = (e => e.replace(/\D/g, ""))} = t;
    return e.$$set = e => {
        "id" in e && o(0, i = e.id), "label" in e && o(1, n = e.label), "title" in e && o(2, r = e.title), "state" in e && o(3, a = e.state), "placeholder" in e && o(4, s = e.placeholder), "value" in e && o(5, l = e.value), "onchange" in e && o(6, c = e.onchange), "format" in e && o(7, d = e.format)
    }, [i, n, r, a, s, l, c, d, e => c(d(e.currentTarget.value))]
}

class qx extends Ga {
    constructor(e) {
        super(), Ua(this, e, Yx, Xx, lr, {
            id: 0,
            label: 1,
            title: 2,
            state: 3,
            placeholder: 4,
            value: 5,
            onchange: 6,
            format: 7
        })
    }
}

function Kx(e) {
    let t;
    return {
        c() {
            t = zr("g")
        }, m(o, i) {
            Ar(o, t, i), t.innerHTML = e[2]
        }, p(e, o) {
            4 & o && (t.innerHTML = e[2])
        }, d(e) {
            e && Lr(t)
        }
    }
}

function Jx(e) {
    let t, o, i, n, r, a, s, l;
    return r = new wd({props: {$$slots: {default: [Kx]}, $$scope: {ctx: e}}}), {
        c() {
            t = Fr("div"), o = Fr("input"), i = Br(), n = Fr("label"), Na(r.$$.fragment), Nr(o, "id", e[0]), Nr(o, "class", "implicit"), Nr(o, "type", "checkbox"), o.checked = e[1], Nr(n, "for", e[0]), Nr(n, "title", e[3])
        }, m(c, d) {
            Ar(c, t, d), Rr(t, o), Rr(t, i), Rr(t, n), Ha(r, n, null), a = !0, s || (l = Wr(o, "change", e[5]), s = !0)
        }, p(e, [t]) {
            (!a || 1 & t) && Nr(o, "id", e[0]), (!a || 2 & t) && (o.checked = e[1]);
            const i = {};
            68 & t && (i.$$scope = {
                dirty: t,
                ctx: e
            }), r.$set(i), (!a || 1 & t) && Nr(n, "for", e[0]), (!a || 8 & t) && Nr(n, "title", e[3])
        }, i(e) {
            a || (Ea(r.$$.fragment, e), a = !0)
        }, o(e) {
            Aa(r.$$.fragment, e), a = !1
        }, d(e) {
            e && Lr(t), ja(r), s = !1, l()
        }
    }
}

function Qx(e, t, o) {
    let {id: i} = t, {locked: n} = t, {icon: r} = t, {title: a} = t, {onchange: s} = t;
    return e.$$set = e => {
        "id" in e && o(0, i = e.id), "locked" in e && o(1, n = e.locked), "icon" in e && o(2, r = e.icon), "title" in e && o(3, a = e.title), "onchange" in e && o(4, s = e.onchange)
    }, [i, n, r, a, s, e => s(e.currentTarget.checked)]
}

class ev extends Ga {
    constructor(e) {
        super(), Ua(this, e, Qx, Jx, lr, {id: 0, locked: 1, icon: 2, title: 3, onchange: 4})
    }
}

function tv(e) {
    let t;
    return {
        c() {
            t = Dr("Save")
        }, m(e, o) {
            Ar(e, t, o)
        }, d(e) {
            e && Lr(t)
        }
    }
}

function ov(e) {
    let t, o, i, n, r, a, s, l, c, d, u, h, p, m = e[1].resizeLabelFormCaption + "";
    return l = new pp({props: {items: e[4]}}), d = new xp({
        props: {
            type: "submit",
            class: "implicit",
            $$slots: {default: [tv]},
            $$scope: {ctx: e}
        }
    }), {
        c() {
            t = Fr("form"), o = Fr("div"), i = Fr("fieldset"), n = Fr("legend"), r = Dr(m), a = Br(), s = Fr("div"), Na(l.$$.fragment), c = Br(), Na(d.$$.fragment), Nr(n, "class", "implicit"), Nr(s, "class", "PinturaFieldsetInner"), Nr(o, "class", "PinturaFormInner"), Nr(t, "slot", "footer"), Zr(t, "transform", e[3])
        }, m(m, g) {
            Ar(m, t, g), Rr(t, o), Rr(o, i), Rr(i, n), Rr(n, r), Rr(i, a), Rr(i, s), Ha(l, s, null), e[66](s), Rr(o, c), Ha(d, o, null), u = !0, h || (p = [Wr(s, "focusin", e[15]), Wr(s, "focusout", e[16]), Wr(t, "submit", Vr(e[17]))], h = !0)
        }, p(e, o) {
            (!u || 2 & o[0]) && m !== (m = e[1].resizeLabelFormCaption + "") && Ur(r, m);
            const i = {};
            16 & o[0] && (i.items = e[4]), l.$set(i);
            const n = {};
            32 & o[3] && (n.$$scope = {dirty: o, ctx: e}), d.$set(n), 8 & o[0] && Zr(t, "transform", e[3])
        }, i(e) {
            u || (Ea(l.$$.fragment, e), Ea(d.$$.fragment, e), u = !0)
        }, o(e) {
            Aa(l.$$.fragment, e), Aa(d.$$.fragment, e), u = !1
        }, d(o) {
            o && Lr(t), ja(l), e[66](null), ja(d), h = !1, ar(p)
        }
    }
}

function iv(e) {
    let t, o;
    return t = new Wf({props: {$$slots: {footer: [ov]}, $$scope: {ctx: e}}}), t.$on("measure", e[67]), {
        c() {
            Na(t.$$.fragment)
        }, m(e, i) {
            Ha(t, e, i), o = !0
        }, p(e, o) {
            const i = {};
            30 & o[0] | 32 & o[3] && (i.$$scope = {dirty: o, ctx: e}), t.$set(i)
        }, i(e) {
            o || (Ea(t.$$.fragment, e), o = !0)
        }, o(e) {
            Aa(t.$$.fragment, e), o = !1
        }, d(e) {
            ja(t, e)
        }
    }
}

function nv(e, t, o) {
    let i, n, r, a, s, l, c, d, u, p, m, g, $, f, y, b, x, v, w, S, k, C, T, P, R, I, A, L, F, z, D = tr,
        B = () => (D(), D = ur(W, (e => o(50, m = e))), W);
    e.$$.on_destroy.push((() => D()));
    const O = (e, t = 0, o = 9999) => {
        if (h(e) && !(e = e.replace(/\D/g, "")).length) return;
        const i = Math.round(e);
        return Number.isNaN(i) ? void 0 : gs(i, t, o)
    };
    let {isActive: W} = t;
    B();
    let {stores: V} = t, {locale: _ = {}} = t, {resizeMinSize: N = Ve(1, 1)} = t, {resizeMaxSize: H = Ve(9999, 9999)} = t, {resizeAspectRatioLocked: j = !1} = t, {resizeEnableButtonLockAspectRatio: U = !0} = t, {resizeSizePresetOptions: X} = t, {resizeWidthPresetOptions: Y} = t, {resizeHeightPresetOptions: q} = t, {resizeWillRenderFooter: K = Z} = t, {
        resizeFormatIconButtonMaintainAspectRatio: J = function (e) {
            const {active: t, activeFraction: o} = e;
            return {active: t, activeFraction: 3 * (o - 1)}
        }
    } = t;
    const Q = bc(0, {stiffness: .15, damping: .3});
    pr(e, Q, (e => o(55, b = e)));
    const {
        animation: ee,
        imageSize: te,
        imageCropRect: oe,
        imageCropRectAspectRatio: ie,
        imageCropAspectRatio: ne,
        imageOutputSize: re,
        imageSelectionZoom: ae,
        imageSelectionPan: se,
        history: le,
        env: ce,
        allowPan: de,
        allowZoom: he,
        allowZoomControls: pe,
        allowPlayPause: me
    } = V;
    pr(e, ee, (e => o(51, g = e))), pr(e, te, (e => o(74, L = e))), pr(e, oe, (e => o(53, f = e))), pr(e, ie, (e => o(54, y = e))), pr(e, ne, (e => o(73, P = e))), pr(e, re, (e => o(62, T = e))), pr(e, ae, (e => o(75, F = e))), pr(e, se, (e => o(76, z = e))), pr(e, ce, (e => o(52, $ = e)));
    const ge = E();
    let $e, fe, ye, be, xe, ve, we = ue();
    const Se = (e, t, o, i, n) => null != e && o !== t ? e >= i[t] && e <= n[t] ? "valid" : "invalid" : "undetermined",
        ke = (e, t, o) => Math.round(null != e ? e / t : o.height), Ce = () => {
            j && fe && ye && ("width" === be ? o(40, ye = Math.round(fe / y)) : "height" === be ? o(39, fe = Math.round(ye * y)) : ("width" === xe ? o(40, ye = Math.round(fe / y)) : "height" === xe && o(39, fe = Math.round(ye * y)), Te()))
        }, Te = e => {
            let t = O(fe), i = O(ye), n = t, r = i, a = n && r, s = e || y;
            if (!n && !r) return;
            n && !r ? r = Math.round(n / s) : r && !n && (n = Math.round(r * s)), s = e || a ? G(n, r) : y;
            let l = Ve(n, r);
            Ue(H, l) || (l = vt(H, s)), Ue(l, N) || (l = xt(N, s)), o(39, fe = null != t ? Math.round(l.width) : void 0), o(40, ye = null != i ? Math.round(l.height) : void 0)
        }, Me = () => {
            Te();
            const {width: e, height: t} = T || {};
            e === fe && t === ye || (fe || ye ? (fe && ye && vr(ne, P = fe / ye, P), vr(re, T = Ve(fe, ye), T)) : (vr(ne, P = L.width / L.height, P), vr(ne, P = void 0, P), vr(re, T = void 0, T)), le.write())
        }, Pe = re.subscribe((e => {
            if (!e) return o(39, fe = void 0), void o(40, ye = void 0);
            o(39, fe = e.width), o(40, ye = e.height), Te()
        })), Re = ne.subscribe((e => {
            (fe || ye) && e && (fe && ye && G(fe, ye) !== e ? (o(40, ye = fe / e), Te(e)) : Te())
        })), Ie = e => h(e[0]) ? (e[1] = e[1].map(Ie), e) : zo(e) ? [e, "" + e] : e, Ee = e => {
            if (h(e[0])) return e[1] = e[1].map(Ee), e;
            let [t, o] = e;
            if (zo(t) && zo(o)) {
                const [e, i] = [t, o];
                o = `${e} &times; ${i}`, t = [e, i]
            }
            return [t, o]
        }, Ae = Ya();
    pr(e, Ae, (e => o(61, C = e)));
    const Le = Ya();
    pr(e, Le, (e => o(65, A = e)));
    const Fe = Ya();
    pr(e, Fe, (e => o(59, S = e)));
    const ze = Ya();
    pr(e, ze, (e => o(64, I = e)));
    const De = Ya();
    pr(e, De, (e => o(57, v = e)));
    const Be = Ya();
    pr(e, Be, (e => o(63, R = e)));
    const We = qa([re, Le], (([e, t], o) => {
        if (!t) return o(-1);
        const i = t.findIndex((([t]) => {
            if (!t && !e) return !0;
            if (!t) return !1;
            const [o, i] = t;
            return e.width === o && e.height === i
        }));
        o(i < 0 ? 0 : i)
    }));
    pr(e, We, (e => o(60, k = e)));
    const _e = qa([re, ze], (([e, t], o) => {
        if (!t) return o(-1);
        const i = t.findIndex((([t]) => !t && !e || !!t && e.width === t));
        o(i < 0 ? 0 : i)
    }));
    pr(e, _e, (e => o(58, w = e)));
    const Ne = qa([re, Be], (([e, t], o) => {
        if (!t) return o(-1);
        const i = t.findIndex((([t]) => !t && !e || !!t && e.height === t));
        o(i < 0 ? 0 : i)
    }));
    pr(e, Ne, (e => o(56, x = e)));
    let He = void 0, je = void 0;
    const Ge = ca("redrawTrigger"), Ze = bc(g ? 20 : 0);
    return pr(e, Ze, (e => o(49, p = e))), aa((() => {
        Pe(), Re()
    })), e.$$set = e => {
        "isActive" in e && B(o(0, W = e.isActive)), "stores" in e && o(30, V = e.stores), "locale" in e && o(1, _ = e.locale), "resizeMinSize" in e && o(31, N = e.resizeMinSize), "resizeMaxSize" in e && o(32, H = e.resizeMaxSize), "resizeAspectRatioLocked" in e && o(28, j = e.resizeAspectRatioLocked), "resizeEnableButtonLockAspectRatio" in e && o(33, U = e.resizeEnableButtonLockAspectRatio), "resizeSizePresetOptions" in e && o(34, X = e.resizeSizePresetOptions), "resizeWidthPresetOptions" in e && o(35, Y = e.resizeWidthPresetOptions), "resizeHeightPresetOptions" in e && o(36, q = e.resizeHeightPresetOptions), "resizeWillRenderFooter" in e && o(37, K = e.resizeWillRenderFooter), "resizeFormatIconButtonMaintainAspectRatio" in e && o(38, J = e.resizeFormatIconButtonMaintainAspectRatio)
    }, e.$$.update = () => {
        524288 & e.$$.dirty[1] && de.set(!m), 524288 & e.$$.dirty[1] && he.set(!m), 524288 & e.$$.dirty[1] && pe.set(!m), 524288 & e.$$.dirty[1] && m && me.set(!0), 1073741832 & e.$$.dirty[1] && X && (vr(Ae, C = X.map(Ee), C), vr(Le, A = tu(C), A)), 1073741824 & e.$$.dirty[1] && o(48, a = !!C), 536870912 & e.$$.dirty[1] | 8 & e.$$.dirty[2] && o(47, i = k > -1 && A[k][1]), 268435472 & e.$$.dirty[1] && Y && (vr(Fe, S = Y.map(Ie), S), vr(ze, I = tu(S), I)), 268566528 & e.$$.dirty[1] && o(45, s = !a && S), 134217728 & e.$$.dirty[1] | 4 & e.$$.dirty[2] && o(46, n = w > -1 && I[w][1]), 67108896 & e.$$.dirty[1] && q && (vr(De, v = q.map(Ie), v), vr(Be, R = tu(v), R)), 67239936 & e.$$.dirty[1] && o(44, l = !a && v), 33554432 & e.$$.dirty[1] | 2 & e.$$.dirty[2] && o(43, r = x > -1 && R[x][1]), 155648 & e.$$.dirty[1] && o(42, c = !a && !s && !l), 268435458 & e.$$.dirty[0] | 2145648583 & e.$$.dirty[1] && o(4, d = Ge && lm((() => {
            return K([a && ["Dropdown", "size-presets", {
                label: i, options: C, onchange: e => {
                    return (t = e.value) && !He && (He = {...f}, je = P), t ? (vr(ne, P = G(t[0], t[1]), P), vr(re, T = Oe(t), T)) : (vr(oe, f = He, f), vr(ne, P = je, P), vr(re, T = void 0, T), He = void 0, je = void 0), void le.write();
                    var t
                }, selectedIndex: k
            }], s && ["Dropdown", "width-presets", {
                label: n, options: S, onchange: e => {
                    o(39, fe = e.value), Me()
                }, selectedIndex: w
            }], s && l && ["span", "times", {
                class: "PinturaResizeLabel",
                innerHTML: "&times;"
            }], l && ["Dropdown", "height-presets", {
                label: r, options: v, onchange: e => {
                    o(40, ye = e.value), Me()
                }, selectedIndex: x
            }], c && [qx, "width-input", {
                id: "width-" + ge,
                title: _.resizeTitleInputWidth,
                label: _.resizeLabelInputWidth,
                placeholder: (e = O(ye), t = y, d = f, Math.round(null != e ? e * t : d.width)),
                value: fe,
                state: Se(O(fe), "width", be, N, H),
                onchange: e => {
                    o(39, fe = e), Ce()
                }
            }], c && U && [ev, "aspect-ratio-lock", {
                id: "aspect-ratio-lock-" + ge,
                title: _.resizeTitleButtonMaintainAspectRatio,
                icon: M(_.resizeIconButtonMaintainAspectRatio) ? _.resizeIconButtonMaintainAspectRatio(j, b) : Pl(_.resizeIconButtonMaintainAspectRatio, J({
                    active: j,
                    activeFraction: b
                }), "{", "}"),
                locked: j,
                onchange: e => {
                    o(28, j = e), Ce()
                }
            }], c && [qx, "height-input", {
                id: "height-" + ge,
                title: _.resizeTitleInputHeight,
                label: _.resizeLabelInputHeight,
                placeholder: ke(O(fe), y, f),
                value: ye,
                state: Se(O(ye), "height", be, N, H),
                onchange: e => {
                    o(40, ye = e), Ce()
                }
            }]].filter(Boolean), {...$}, (() => Ge.set({})));
            var e, t, d
        })).filter(Boolean)), 268435456 & e.$$.dirty[0] && Q.set(j ? 1 : 0), 1024 & e.$$.dirty[1] && be && (xe = be), 524288 & e.$$.dirty[1] && m && (we = z, ve = F), 524288 & e.$$.dirty[1] | 1 & e.$$.dirty[2] && (m ? setTimeout((() => {
            return e = T, vr(se, z = ue(), z), void vr(ae, F = e && f ? e.width / f.width || e.height / f.height : 1, F);
            var e
        }), 0) : (vr(se, z = we, z), vr(ae, F = ve, F))), 1572864 & e.$$.dirty[1] && g && Ze.set(m ? 0 : 20), 262144 & e.$$.dirty[1] && o(3, u = p ? `translateY(${p}px)` : "none")
    }, [W, _, $e, u, d, Q, ee, te, oe, ie, ne, re, ae, se, ce, e => {
        const t = e.target.id;
        /width/.test(t) ? o(41, be = "width") : /height/.test(t) ? o(41, be = "height") : /aspectRatio/i.test(t) ? o(41, be = "lock") : o(41, be = void 0)
    }, e => {
        $e.contains(e.relatedTarget) || Me(), o(41, be = void 0)
    }, Me, Ae, Le, Fe, ze, De, Be, We, _e, Ne, Ze, j, "resize", V, N, H, U, X, Y, q, K, J, fe, ye, be, c, r, l, s, n, i, a, p, m, g, $, f, y, b, x, v, w, S, k, C, T, R, I, A, function (e) {
        ha[e ? "unshift" : "push"]((() => {
            $e = e, o(2, $e)
        }))
    }, function (t) {
        da.call(this, e, t)
    }]
}

var rv = {
    util: ["resize", class extends Ga {
        constructor(e) {
            super(), Ua(this, e, nv, iv, lr, {
                name: 29,
                isActive: 0,
                stores: 30,
                locale: 1,
                resizeMinSize: 31,
                resizeMaxSize: 32,
                resizeAspectRatioLocked: 28,
                resizeEnableButtonLockAspectRatio: 33,
                resizeSizePresetOptions: 34,
                resizeWidthPresetOptions: 35,
                resizeHeightPresetOptions: 36,
                resizeWillRenderFooter: 37,
                resizeFormatIconButtonMaintainAspectRatio: 38
            }, null, [-1, -1, -1, -1])
        }

        get name() {
            return this.$$.ctx[29]
        }

        get isActive() {
            return this.$$.ctx[0]
        }

        set isActive(e) {
            this.$$set({isActive: e}), ka()
        }

        get stores() {
            return this.$$.ctx[30]
        }

        set stores(e) {
            this.$$set({stores: e}), ka()
        }

        get locale() {
            return this.$$.ctx[1]
        }

        set locale(e) {
            this.$$set({locale: e}), ka()
        }

        get resizeMinSize() {
            return this.$$.ctx[31]
        }

        set resizeMinSize(e) {
            this.$$set({resizeMinSize: e}), ka()
        }

        get resizeMaxSize() {
            return this.$$.ctx[32]
        }

        set resizeMaxSize(e) {
            this.$$set({resizeMaxSize: e}), ka()
        }

        get resizeAspectRatioLocked() {
            return this.$$.ctx[28]
        }

        set resizeAspectRatioLocked(e) {
            this.$$set({resizeAspectRatioLocked: e}), ka()
        }

        get resizeEnableButtonLockAspectRatio() {
            return this.$$.ctx[33]
        }

        set resizeEnableButtonLockAspectRatio(e) {
            this.$$set({resizeEnableButtonLockAspectRatio: e}), ka()
        }

        get resizeSizePresetOptions() {
            return this.$$.ctx[34]
        }

        set resizeSizePresetOptions(e) {
            this.$$set({resizeSizePresetOptions: e}), ka()
        }

        get resizeWidthPresetOptions() {
            return this.$$.ctx[35]
        }

        set resizeWidthPresetOptions(e) {
            this.$$set({resizeWidthPresetOptions: e}), ka()
        }

        get resizeHeightPresetOptions() {
            return this.$$.ctx[36]
        }

        set resizeHeightPresetOptions(e) {
            this.$$set({resizeHeightPresetOptions: e}), ka()
        }

        get resizeWillRenderFooter() {
            return this.$$.ctx[37]
        }

        set resizeWillRenderFooter(e) {
            this.$$set({resizeWillRenderFooter: e}), ka()
        }

        get resizeFormatIconButtonMaintainAspectRatio() {
            return this.$$.ctx[38]
        }

        set resizeFormatIconButtonMaintainAspectRatio(e) {
            this.$$set({resizeFormatIconButtonMaintainAspectRatio: e}), ka()
        }
    }]
};

function av(e) {
    let t, o;
    return t = new Mx({
        props: {
            stores: e[3],
            locale: e[4],
            isActive: e[0],
            isActiveFraction: e[1],
            isVisible: e[2],
            mapScreenPointToImagePoint: e[10],
            mapImagePointToScreenPoint: e[9],
            enableMultiSelect: e[6],
            utilKey: "redact",
            imageRotation: e[11],
            imageFlipX: e[8],
            imageFlipY: e[7],
            shapes: e[12],
            toolbar: ["rect"],
            toolShapes: {rectangle: [{x: 0, y: 0, width: 0, height: 0}]},
            toolActive: "rectangle",
            parentRect: e[14],
            enablePresetDropImage: !1,
            enablePresetSelectImage: !1,
            willStartInteraction: e[5],
            hooks: {willRenderShapeControls: e[25]}
        }
    }), t.$on("measure", e[26]), {
        c() {
            Na(t.$$.fragment)
        }, m(e, i) {
            Ha(t, e, i), o = !0
        }, p(e, [o]) {
            const i = {};
            8 & o && (i.stores = e[3]), 16 & o && (i.locale = e[4]), 1 & o && (i.isActive = e[0]), 2 & o && (i.isActiveFraction = e[1]), 4 & o && (i.isVisible = e[2]), 1024 & o && (i.mapScreenPointToImagePoint = e[10]), 512 & o && (i.mapImagePointToScreenPoint = e[9]), 64 & o && (i.enableMultiSelect = e[6]), 2048 & o && (i.imageRotation = e[11]), 256 & o && (i.imageFlipX = e[8]), 128 & o && (i.imageFlipY = e[7]), 32 & o && (i.willStartInteraction = e[5]), t.$set(i)
        }, i(e) {
            o || (Ea(t.$$.fragment, e), o = !0)
        }, o(e) {
            Aa(t.$$.fragment, e), o = !1
        }, d(e) {
            ja(t, e)
        }
    }
}

function sv(e, t, o) {
    let i, n, r, a, s, l, c, d, u;
    let {isActive: h} = t, {isActiveFraction: p} = t, {isVisible: m} = t, {stores: g} = t, {locale: $ = {}} = t, {markupEditorWillStartInteraction: f} = t, {enableMultiSelect: y} = t;
    const {
        imageRedaction: b,
        rootRect: x,
        imageSize: v,
        imageRotation: w,
        imageFlipX: S,
        imageFlipY: k,
        imageTransforms: C,
        imageTransformsInterpolated: T
    } = g;
    pr(e, x, (e => o(24, d = e))), pr(e, v, (e => o(23, c = e))), pr(e, w, (e => o(11, u = e))), pr(e, S, (e => o(8, a = e))), pr(e, k, (e => o(7, r = e))), pr(e, C, (e => o(22, l = e))), pr(e, T, (e => o(21, s = e)));
    return e.$$set = e => {
        "isActive" in e && o(0, h = e.isActive), "isActiveFraction" in e && o(1, p = e.isActiveFraction), "isVisible" in e && o(2, m = e.isVisible), "stores" in e && o(3, g = e.stores), "locale" in e && o(4, $ = e.locale), "markupEditorWillStartInteraction" in e && o(5, f = e.markupEditorWillStartInteraction), "enableMultiSelect" in e && o(6, y = e.enableMultiSelect)
    }, e.$$.update = () => {
        31457664 & e.$$.dirty && o(10, i = e => Rx(e, d, c, s.origin, s.translation, l.rotation.z, s.scale, a, r)), 31457664 & e.$$.dirty && o(9, n = e => Px(e, d, c, s.origin, s.translation, l.rotation.z, s.scale, a, r))
    }, [h, p, m, g, $, f, y, r, a, n, i, u, b, x, v, w, S, k, C, T, "redact", s, l, c, d, e => {
        const t = rg(e[0]);
        return ug("to-front", t), e
    }, function (t) {
        da.call(this, e, t)
    }]
}

var lv = {
    util: ["redact", class extends Ga {
        constructor(e) {
            super(), Ua(this, e, sv, av, lr, {
                name: 20,
                isActive: 0,
                isActiveFraction: 1,
                isVisible: 2,
                stores: 3,
                locale: 4,
                markupEditorWillStartInteraction: 5,
                enableMultiSelect: 6
            })
        }

        get name() {
            return this.$$.ctx[20]
        }

        get isActive() {
            return this.$$.ctx[0]
        }

        set isActive(e) {
            this.$$set({isActive: e}), ka()
        }

        get isActiveFraction() {
            return this.$$.ctx[1]
        }

        set isActiveFraction(e) {
            this.$$set({isActiveFraction: e}), ka()
        }

        get isVisible() {
            return this.$$.ctx[2]
        }

        set isVisible(e) {
            this.$$set({isVisible: e}), ka()
        }

        get stores() {
            return this.$$.ctx[3]
        }

        set stores(e) {
            this.$$set({stores: e}), ka()
        }

        get locale() {
            return this.$$.ctx[4]
        }

        set locale(e) {
            this.$$set({locale: e}), ka()
        }

        get markupEditorWillStartInteraction() {
            return this.$$.ctx[5]
        }

        set markupEditorWillStartInteraction(e) {
            this.$$set({markupEditorWillStartInteraction: e}), ka()
        }

        get enableMultiSelect() {
            return this.$$.ctx[6]
        }

        set enableMultiSelect(e) {
            this.$$set({enableMultiSelect: e}), ka()
        }
    }, ({src: e}) => e && !Us(e)]
};

function cv(e) {
    let t;
    return {
        c() {
            t = Fr("div")
        }, m(e, o) {
            Ar(e, t, o)
        }, p: tr, d(e) {
            e && Lr(t)
        }
    }
}

function dv(e) {
    let t, o, i, n;
    return {
        c() {
            t = Fr("div"), Nr(t, "class", "PinturaFillTile")
        }, m(r, a) {
            Ar(r, t, a), i || (n = wr(o = fv.call(null, t, e[31].value)), i = !0)
        }, p(e, t) {
            o && sr(o.update) && 1 & t[1] && o.update.call(null, e[31].value)
        }, d(e) {
            e && Lr(t), i = !1, n()
        }
    }
}

function uv(e) {
    let t, o, i;
    return {
        c() {
            t = Fr("div"), o = Fr("img"), dr(o.src, i = e[31].value) || Nr(o, "src", i), Nr(o, "alt", ""), Nr(o, "width", "48"), Nr(o, "height", "64"), Nr(t, "class", "PinturaFillTile")
        }, m(e, i) {
            Ar(e, t, i), Rr(t, o)
        }, p(e, t) {
            1 & t[1] && !dr(o.src, i = e[31].value) && Nr(o, "src", i)
        }, d(e) {
            e && Lr(t)
        }
    }
}

function hv(e) {
    let t, o, i = (M(e[31].label) ? e[31].label(e[1]) : e[31].label) + "";
    return {
        c() {
            t = Fr("span"), o = Dr(i)
        }, m(e, i) {
            Ar(e, t, i), Rr(t, o)
        }, p(e, t) {
            2 & t[0] | 1 & t[1] && i !== (i = (M(e[31].label) ? e[31].label(e[1]) : e[31].label) + "") && Ur(o, i)
        }, d(e) {
            e && Lr(t)
        }
    }
}

function pv(e) {
    let t, o, i, n;

    function r(e, t) {
        return 1 & t[1] && (o = null), 1 & t[1] && (i = null), null == o && (o = !!h(e[31].value)), o ? uv : (null == i && (i = !!Oo(e[31].value)), i ? dv : cv)
    }

    let a = r(e, [-1, -1]), s = a(e), l = e[31].label && hv(e);
    return {
        c() {
            t = Fr("div"), s.c(), n = Br(), l && l.c(), Nr(t, "slot", "option")
        }, m(e, o) {
            Ar(e, t, o), s.m(t, null), Rr(t, n), l && l.m(t, null)
        }, p(e, o) {
            a === (a = r(e, o)) && s ? s.p(e, o) : (s.d(1), s = a(e), s && (s.c(), s.m(t, n))), e[31].label ? l ? l.p(e, o) : (l = hv(e), l.c(), l.m(t, null)) : l && (l.d(1), l = null)
        }, d(e) {
            e && Lr(t), s.d(), l && l.d()
        }
    }
}

function mv(e) {
    let t, o;
    return t = new Eu({
        props: {
            locale: e[1],
            class: "PinturaControlList",
            layout: "row",
            options: e[2],
            selectedIndex: e[4],
            onchange: e[10],
            $$slots: {option: [pv, ({option: e}) => ({31: e}), ({option: e}) => [0, e ? 1 : 0]]},
            $$scope: {ctx: e}
        }
    }), {
        c() {
            Na(t.$$.fragment)
        }, m(e, i) {
            Ha(t, e, i), o = !0
        }, p(e, o) {
            const i = {};
            2 & o[0] && (i.locale = e[1]), 4 & o[0] && (i.options = e[2]), 16 & o[0] && (i.selectedIndex = e[4]), 2 & o[0] | 3 & o[1] && (i.$$scope = {
                dirty: o,
                ctx: e
            }), t.$set(i)
        }, i(e) {
            o || (Ea(t.$$.fragment, e), o = !0)
        }, o(e) {
            Aa(t.$$.fragment, e), o = !1
        }, d(e) {
            ja(t, e)
        }
    }
}

function gv(e) {
    let t, o, i;
    return o = new Ep({props: {elasticity: e[5], $$slots: {default: [mv]}, $$scope: {ctx: e}}}), {
        c() {
            t = Fr("div"), Na(o.$$.fragment), Nr(t, "slot", "footer"), Zr(t, "transform", e[3])
        }, m(e, n) {
            Ar(e, t, n), Ha(o, t, null), i = !0
        }, p(e, i) {
            const n = {};
            32 & i[0] && (n.elasticity = e[5]), 22 & i[0] | 2 & i[1] && (n.$$scope = {
                dirty: i,
                ctx: e
            }), o.$set(n), 8 & i[0] && Zr(t, "transform", e[3])
        }, i(e) {
            i || (Ea(o.$$.fragment, e), i = !0)
        }, o(e) {
            Aa(o.$$.fragment, e), i = !1
        }, d(e) {
            e && Lr(t), ja(o)
        }
    }
}

function $v(e) {
    let t, o;
    return t = new Wf({props: {$$slots: {footer: [gv]}, $$scope: {ctx: e}}}), t.$on("measure", e[21]), {
        c() {
            Na(t.$$.fragment)
        }, m(e, i) {
            Ha(t, e, i), o = !0
        }, p(e, o) {
            const i = {};
            62 & o[0] | 2 & o[1] && (i.$$scope = {dirty: o, ctx: e}), t.$set(i)
        }, i(e) {
            o || (Ea(t.$$.fragment, e), o = !0)
        }, o(e) {
            Aa(t.$$.fragment, e), o = !1
        }, d(e) {
            ja(t, e)
        }
    }
}

function fv(e) {
    const t = document.createElement("div");
    return e.append(t), {
        update(o) {
            const [i, n, r, a] = o.map(((e, t) => t < 3 ? Math.round(255 * e) : e));
            e.dataset.transparent = a < 1, t.style.backgroundColor = `rgba(${i},${n},${r},${a})`
        }
    }
}

function yv(e, t, o) {
    let i, n, r, a, s, l, c, d, u, p, m = tr, g = () => (m(), m = ur($, (e => o(16, l = e))), $);
    e.$$.on_destroy.push((() => m()));
    let {isActive: $} = t;
    g();
    let {stores: f} = t, {locale: y = {}} = t, {fillOptions: b = []} = t;
    const x = e => e.map((e => (e => Oo(e) && h(e[0]) && Oo(e[1]))(e) ? [e[0], x(e[1]), e[2]] : (e => [Array.isArray(e) && 3 === e.length ? [...e, 1] : e, void 0, {disabled: !1}])(e))),
        v = ca("elasticityMultiplier");
    pr(e, v, (e => o(20, p = e)));
    const {
        history: w,
        animation: S,
        scrollElasticity: k,
        imageBackgroundColor: C,
        imageBackgroundImage: T,
        allowPan: M,
        allowZoom: P,
        allowZoomControls: R,
        allowPlayPause: I
    } = f;
    pr(e, S, (e => o(17, c = e))), pr(e, C, (e => o(19, u = e))), pr(e, T, (e => o(18, d = e)));
    const E = bc(c ? 20 : 0);
    return pr(e, E, (e => o(15, s = e))), e.$$set = e => {
        "isActive" in e && g(o(0, $ = e.isActive)), "stores" in e && o(13, f = e.stores), "locale" in e && o(1, y = e.locale), "fillOptions" in e && o(14, b = e.fillOptions)
    }, e.$$.update = () => {
        16384 & e.$$.dirty[0] && o(2, i = x(b)), 65536 & e.$$.dirty[0] && M.set(l), 65536 & e.$$.dirty[0] && P.set(l), 65536 & e.$$.dirty[0] && R.set(l), 65536 & e.$$.dirty[0] && l && I.set(!0), 1048576 & e.$$.dirty[0] && o(5, n = p * k), 786436 & e.$$.dirty[0] && o(4, r = i.findIndex((([e]) => d ? e === d : Array.isArray(e) ? xs(e, u) : void 0)) || 0), 196608 & e.$$.dirty[0] && c && E.set(l ? 0 : 20), 32768 & e.$$.dirty[0] && o(3, a = s ? `translateY(${s}px)` : "none")
    }, [$, y, i, a, r, n, v, S, C, T, ({value: e}) => {
        h(e) && (vr(C, u = void 0, u), vr(T, d = e, d)), Oo(e) && (vr(C, u = e, u), vr(T, d = void 0, d)), w.write()
    }, E, "fill", f, b, s, l, c, d, u, p, function (t) {
        da.call(this, e, t)
    }]
}

var bv = {
    util: ["fill", class extends Ga {
        constructor(e) {
            super(), Ua(this, e, yv, $v, lr, {
                name: 12,
                isActive: 0,
                stores: 13,
                locale: 1,
                fillOptions: 14
            }, null, [-1, -1])
        }

        get name() {
            return this.$$.ctx[12]
        }

        get isActive() {
            return this.$$.ctx[0]
        }

        set isActive(e) {
            this.$$set({isActive: e}), ka()
        }

        get stores() {
            return this.$$.ctx[13]
        }

        set stores(e) {
            this.$$set({stores: e}), ka()
        }

        get locale() {
            return this.$$.ctx[1]
        }

        set locale(e) {
            this.$$set({locale: e}), ka()
        }

        get fillOptions() {
            return this.$$.ctx[14]
        }

        set fillOptions(e) {
            this.$$set({fillOptions: e}), ka()
        }
    }, ({src: e, fillOptions: t}) => e && !Us(e) && t && t.length]
};

function xv(e) {
    let t, o, i;

    function n(t) {
        e[42](t)
    }

    let r = {
        utilKey: "retouch",
        stores: e[4],
        locale: e[5],
        isActive: e[1],
        isActiveFraction: e[2],
        isVisible: e[3],
        mapScreenPointToImagePoint: e[27],
        mapImagePointToScreenPoint: e[26],
        imageRotation: e[28],
        imageFlipX: e[25],
        imageFlipY: e[24],
        toolbar: e[6],
        toolbarLayout: "stack",
        shapes: e[30],
        toolShapes: e[7],
        enableMultiSelect: e[23],
        enableViewTool: e[14],
        enableMoveTool: e[13],
        enableToolShareStyles: !1,
        shapeControls: e[8],
        enablePresetSelectImage: !1,
        enablePresetDropImage: !1,
        parentRect: e[31],
        willStartInteraction: e[12],
        willRenderHeaderTools: e[10] || e[17],
        willRenderShapeStyleControls: e[9],
        hooks: {
            willRenderShapeControls: e[11] || e[15],
            willRenderShapeTextControls: e[16],
            beforeAddShape: e[18],
            beforeRemoveShape: e[19],
            beforeDeselectShape: e[20],
            beforeSelectShape: e[21],
            beforeUpdateShape: e[22]
        }
    };
    return void 0 !== e[0] && (r.toolActive = e[0]), t = new Mx({props: r}), ha.push((() => _a(t, "toolActive", n))), t.$on("measure", e[43]), {
        c() {
            Na(t.$$.fragment)
        }, m(e, o) {
            Ha(t, e, o), i = !0
        }, p(e, i) {
            const n = {};
            16 & i[0] && (n.stores = e[4]), 32 & i[0] && (n.locale = e[5]), 2 & i[0] && (n.isActive = e[1]), 4 & i[0] && (n.isActiveFraction = e[2]), 8 & i[0] && (n.isVisible = e[3]), 134217728 & i[0] && (n.mapScreenPointToImagePoint = e[27]), 67108864 & i[0] && (n.mapImagePointToScreenPoint = e[26]), 268435456 & i[0] && (n.imageRotation = e[28]), 33554432 & i[0] && (n.imageFlipX = e[25]), 16777216 & i[0] && (n.imageFlipY = e[24]), 64 & i[0] && (n.toolbar = e[6]), 128 & i[0] && (n.toolShapes = e[7]), 8388608 & i[0] && (n.enableMultiSelect = e[23]), 16384 & i[0] && (n.enableViewTool = e[14]), 8192 & i[0] && (n.enableMoveTool = e[13]), 256 & i[0] && (n.shapeControls = e[8]), 4096 & i[0] && (n.willStartInteraction = e[12]), 132096 & i[0] && (n.willRenderHeaderTools = e[10] || e[17]), 512 & i[0] && (n.willRenderShapeStyleControls = e[9]), 8226816 & i[0] && (n.hooks = {
                willRenderShapeControls: e[11] || e[15],
                willRenderShapeTextControls: e[16],
                beforeAddShape: e[18],
                beforeRemoveShape: e[19],
                beforeDeselectShape: e[20],
                beforeSelectShape: e[21],
                beforeUpdateShape: e[22]
            }), !o && 1 & i[0] && (o = !0, n.toolActive = e[0], xa((() => o = !1))), t.$set(n)
        }, i(e) {
            i || (Ea(t.$$.fragment, e), i = !0)
        }, o(e) {
            Aa(t.$$.fragment, e), i = !1
        }, d(e) {
            ja(t, e)
        }
    }
}

function vv(e, t, o) {
    let i, n, r, a, s, l, c, d, u;
    let {isActive: h} = t, {isActiveFraction: p} = t, {isVisible: m} = t, {stores: g} = t, {locale: $ = {}} = t, {retouchTools: f} = t, {retouchToolShapes: y} = t, {retouchShapeControls: b} = t, {retouchActiveTool: x} = t, {retouchWillRenderShapeStyleControls: v} = t, {retouchWillRenderHeaderTools: w} = t, {retouchWillRenderShapeControls: S} = t, {markupEditorWillStartInteraction: k} = t, {retouchEnableMoveTool: C} = t, {retouchEnableViewTool: T} = t, {willRenderShapeControls: M} = t, {willRenderShapeTextControls: P} = t, {willRenderHeaderTools: R} = t, {beforeAddShape: I} = t, {beforeRemoveShape: E} = t, {beforeDeselectShape: A} = t, {beforeSelectShape: L} = t, {beforeUpdateShape: F} = t, {enableMultiSelect: z} = t;
    const {
        rootRect: D,
        imageManipulation: B,
        imageSize: O,
        imageRotation: W,
        imageFlipX: V,
        imageFlipY: _,
        imageTransforms: N,
        imageTransformsInterpolated: H
    } = g;
    return pr(e, D, (e => o(41, d = e))), pr(e, O, (e => o(40, c = e))), pr(e, W, (e => o(28, u = e))), pr(e, V, (e => o(25, a = e))), pr(e, _, (e => o(24, r = e))), pr(e, N, (e => o(39, l = e))), pr(e, H, (e => o(38, s = e))), e.$$set = e => {
        "isActive" in e && o(1, h = e.isActive), "isActiveFraction" in e && o(2, p = e.isActiveFraction), "isVisible" in e && o(3, m = e.isVisible), "stores" in e && o(4, g = e.stores), "locale" in e && o(5, $ = e.locale), "retouchTools" in e && o(6, f = e.retouchTools), "retouchToolShapes" in e && o(7, y = e.retouchToolShapes), "retouchShapeControls" in e && o(8, b = e.retouchShapeControls), "retouchActiveTool" in e && o(0, x = e.retouchActiveTool), "retouchWillRenderShapeStyleControls" in e && o(9, v = e.retouchWillRenderShapeStyleControls), "retouchWillRenderHeaderTools" in e && o(10, w = e.retouchWillRenderHeaderTools), "retouchWillRenderShapeControls" in e && o(11, S = e.retouchWillRenderShapeControls), "markupEditorWillStartInteraction" in e && o(12, k = e.markupEditorWillStartInteraction), "retouchEnableMoveTool" in e && o(13, C = e.retouchEnableMoveTool), "retouchEnableViewTool" in e && o(14, T = e.retouchEnableViewTool), "willRenderShapeControls" in e && o(15, M = e.willRenderShapeControls), "willRenderShapeTextControls" in e && o(16, P = e.willRenderShapeTextControls), "willRenderHeaderTools" in e && o(17, R = e.willRenderHeaderTools), "beforeAddShape" in e && o(18, I = e.beforeAddShape), "beforeRemoveShape" in e && o(19, E = e.beforeRemoveShape), "beforeDeselectShape" in e && o(20, A = e.beforeDeselectShape), "beforeSelectShape" in e && o(21, L = e.beforeSelectShape), "beforeUpdateShape" in e && o(22, F = e.beforeUpdateShape), "enableMultiSelect" in e && o(23, z = e.enableMultiSelect)
    }, e.$$.update = () => {
        50331648 & e.$$.dirty[0] | 1920 & e.$$.dirty[1] && o(27, i = e => Rx(e, d, c, s.origin, s.translation, l.rotation.z, s.scale, a, r)), 50331648 & e.$$.dirty[0] | 1920 & e.$$.dirty[1] && o(26, n = e => Px(e, d, c, s.origin, s.translation, l.rotation.z, s.scale, a, r))
    }, [x, h, p, m, g, $, f, y, b, v, w, S, k, C, T, M, P, R, I, E, A, L, F, z, r, a, n, i, u, D, B, O, W, V, _, N, H, "retouch", s, l, c, d, function (e) {
        x = e, o(0, x)
    }, function (t) {
        da.call(this, e, t)
    }]
}

var wv = {
    util: ["retouch", class extends Ga {
        constructor(e) {
            super(), Ua(this, e, vv, xv, lr, {
                name: 37,
                isActive: 1,
                isActiveFraction: 2,
                isVisible: 3,
                stores: 4,
                locale: 5,
                retouchTools: 6,
                retouchToolShapes: 7,
                retouchShapeControls: 8,
                retouchActiveTool: 0,
                retouchWillRenderShapeStyleControls: 9,
                retouchWillRenderHeaderTools: 10,
                retouchWillRenderShapeControls: 11,
                markupEditorWillStartInteraction: 12,
                retouchEnableMoveTool: 13,
                retouchEnableViewTool: 14,
                willRenderShapeControls: 15,
                willRenderShapeTextControls: 16,
                willRenderHeaderTools: 17,
                beforeAddShape: 18,
                beforeRemoveShape: 19,
                beforeDeselectShape: 20,
                beforeSelectShape: 21,
                beforeUpdateShape: 22,
                enableMultiSelect: 23
            }, null, [-1, -1])
        }

        get name() {
            return this.$$.ctx[37]
        }

        get isActive() {
            return this.$$.ctx[1]
        }

        set isActive(e) {
            this.$$set({isActive: e}), ka()
        }

        get isActiveFraction() {
            return this.$$.ctx[2]
        }

        set isActiveFraction(e) {
            this.$$set({isActiveFraction: e}), ka()
        }

        get isVisible() {
            return this.$$.ctx[3]
        }

        set isVisible(e) {
            this.$$set({isVisible: e}), ka()
        }

        get stores() {
            return this.$$.ctx[4]
        }

        set stores(e) {
            this.$$set({stores: e}), ka()
        }

        get locale() {
            return this.$$.ctx[5]
        }

        set locale(e) {
            this.$$set({locale: e}), ka()
        }

        get retouchTools() {
            return this.$$.ctx[6]
        }

        set retouchTools(e) {
            this.$$set({retouchTools: e}), ka()
        }

        get retouchToolShapes() {
            return this.$$.ctx[7]
        }

        set retouchToolShapes(e) {
            this.$$set({retouchToolShapes: e}), ka()
        }

        get retouchShapeControls() {
            return this.$$.ctx[8]
        }

        set retouchShapeControls(e) {
            this.$$set({retouchShapeControls: e}), ka()
        }

        get retouchActiveTool() {
            return this.$$.ctx[0]
        }

        set retouchActiveTool(e) {
            this.$$set({retouchActiveTool: e}), ka()
        }

        get retouchWillRenderShapeStyleControls() {
            return this.$$.ctx[9]
        }

        set retouchWillRenderShapeStyleControls(e) {
            this.$$set({retouchWillRenderShapeStyleControls: e}), ka()
        }

        get retouchWillRenderHeaderTools() {
            return this.$$.ctx[10]
        }

        set retouchWillRenderHeaderTools(e) {
            this.$$set({retouchWillRenderHeaderTools: e}), ka()
        }

        get retouchWillRenderShapeControls() {
            return this.$$.ctx[11]
        }

        set retouchWillRenderShapeControls(e) {
            this.$$set({retouchWillRenderShapeControls: e}), ka()
        }

        get markupEditorWillStartInteraction() {
            return this.$$.ctx[12]
        }

        set markupEditorWillStartInteraction(e) {
            this.$$set({markupEditorWillStartInteraction: e}), ka()
        }

        get retouchEnableMoveTool() {
            return this.$$.ctx[13]
        }

        set retouchEnableMoveTool(e) {
            this.$$set({retouchEnableMoveTool: e}), ka()
        }

        get retouchEnableViewTool() {
            return this.$$.ctx[14]
        }

        set retouchEnableViewTool(e) {
            this.$$set({retouchEnableViewTool: e}), ka()
        }

        get willRenderShapeControls() {
            return this.$$.ctx[15]
        }

        set willRenderShapeControls(e) {
            this.$$set({willRenderShapeControls: e}), ka()
        }

        get willRenderShapeTextControls() {
            return this.$$.ctx[16]
        }

        set willRenderShapeTextControls(e) {
            this.$$set({willRenderShapeTextControls: e}), ka()
        }

        get willRenderHeaderTools() {
            return this.$$.ctx[17]
        }

        set willRenderHeaderTools(e) {
            this.$$set({willRenderHeaderTools: e}), ka()
        }

        get beforeAddShape() {
            return this.$$.ctx[18]
        }

        set beforeAddShape(e) {
            this.$$set({beforeAddShape: e}), ka()
        }

        get beforeRemoveShape() {
            return this.$$.ctx[19]
        }

        set beforeRemoveShape(e) {
            this.$$set({beforeRemoveShape: e}), ka()
        }

        get beforeDeselectShape() {
            return this.$$.ctx[20]
        }

        set beforeDeselectShape(e) {
            this.$$set({beforeDeselectShape: e}), ka()
        }

        get beforeSelectShape() {
            return this.$$.ctx[21]
        }

        set beforeSelectShape(e) {
            this.$$set({beforeSelectShape: e}), ka()
        }

        get beforeUpdateShape() {
            return this.$$.ctx[22]
        }

        set beforeUpdateShape(e) {
            this.$$set({beforeUpdateShape: e}), ka()
        }

        get enableMultiSelect() {
            return this.$$.ctx[23]
        }

        set enableMultiSelect(e) {
            this.$$set({enableMultiSelect: e}), ka()
        }
    }, ({src: e}) => e && !Us(e)]
};
const Sv = '<g fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round" stroke="currentColor" stroke-width=".125em"><path d="M18 6L6 18M6 6l12 12"></path></path></g>',
    kv = '<path fill="none" d="M9 15 L12 9 L15 15 M10 13.5 h3" stroke="currentColor" stroke-width=".125em"/>';
var Cv = {
    labelReset: "Reset",
    labelDefault: "Default",
    labelAuto: "Auto",
    labelNone: "None",
    labelEdit: "Edit",
    labelClose: "Close",
    labelSupportError: "{features} not supported on this browser",
    labelColor: "Color",
    labelWidth: "Width",
    labelSize: "Size",
    labelOffset: "Offset",
    labelAmount: "Amount",
    labelInset: "Inset",
    labelRadius: "Radius",
    labelColorPalette: "Color palette",
    labelSizeExtraSmall: "Extra small",
    labelSizeSmall: "Small",
    labelSizeMediumSmall: "Medium small",
    labelSizeMedium: "Medium",
    labelSizeMediumLarge: "Medium large",
    labelSizeLarge: "Large",
    labelSizeExtraLarge: "Extra large",
    labelButtonCancel: "Cancel",
    labelButtonUndo: "Undo",
    labelButtonRedo: "Redo",
    labelButtonRevert: "Revert",
    labelButtonExport: "Done",
    labelZoom: "Zoom",
    labelZoomIn: "Zoom in",
    labelZoomOut: "Zoom out",
    labelZoomFit: "Fit to view",
    labelZoomActual: "Actual size",
    iconZoomIn: '<path stroke="currentColor" stroke-width=".125em" d="M8 12 h8 M12 8 v8" />',
    iconZoomOut: '<path stroke="currentColor" stroke-width=".125em" d="M9 12 h6" />',
    iconSupportError: '<g fill="none" stroke="currentColor" stroke-width="2"><path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"/><g><line x1="12" y1="9" x2="12" y2="13"/><line x1="12" y1="17" x2="12.01" y2="17"/></g>',
    iconButtonClose: Sv,
    iconButtonRevert: '<g fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round" stroke="currentColor" stroke-width=".125em"><path d="M7.388 18.538a8 8 0 10-2.992-9.03"/><path fill="currentColor" d="M2.794 11.696L2.37 6.714l5.088 3.18z"/><path d="M12 8v4M12 12l4 2"/></g>',
    iconButtonUndo: '<g fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round" stroke="currentColor" stroke-width=".125em"><path d="M10 8h4c2.485 0 5 2 5 5s-2.515 5-5 5h-4"/><path fill="currentColor" d="M5 8l4-3v6z"/></g>',
    iconButtonRedo: '<g fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round" stroke="currentColor" stroke-width=".125em"><path d="M14 8h-4c-2.485 0-5 2-5 5s2.515 5 5 5h4"/><path fill="currentColor" d="M19 8l-4-3v6z"/></g>',
    iconButtonExport: '<polyline points="20 6 9 17 4 12" fill="none" stroke="currentColor" stroke-width=".125em"></polyline>',
    statusLabelButtonClose: "Close",
    statusIconButtonClose: Sv,
    statusImageLoadNone: "Waiting for image",
    statusImageLoadMinSize: "Minimum image size is {minWidth} &times; {minHeight}",
    statusImageLoadPrepare: "Preparing image&hellip;",
    statusImageLoadBusy: "Loading image&hellip;",
    statusImageLoadError: "Error loading image",
    statusImageProcessBusy: "Processing image&hellip;",
    statusImageProcessError: "Error processing image",
    statusImageUploadBusy: "Uploading image&hellip;",
    statusImageUploadError: "Error uploading image"
};
const Tv = {
    shapeLabelButtonSelectSticker: "Select image",
    shapeIconButtonSelectSticker: '<g fill="none" stroke="currentColor" stroke-width="0.0625em"><path d="M8 21 L15 11 L19 15"/><path d="M15 2 v5 h5"/><path d="M8 2 h8 l4 4 v12 q0 4 -4 4 h-8 q-4 0 -4 -4 v-12 q0 -4 4 -4z"/></g><circle fill="currentColor" cx="10" cy="8" r="1.5"/>',
    shapeIconButtonFlipHorizontal: '<g stroke="currentColor" stroke-width=".125em"><path fill="none" d="M6 6.5h5v11H6z"/><path fill="currentColor" d="M15 6.5h3v11h-3z"/><path d="M11 4v16" fill="currentColor"/></g>',
    shapeIconButtonFlipVertical: '<g stroke="currentColor" stroke-width=".125em"><rect x="7" y="8" width="11" height="5" fill="none"/><rect x="7" y="17" width="11" height="2" fill="currentColor"/><line x1="5" y1="13" x2="20" y2="13"/></g>',
    shapeIconButtonRemove: '<g fill="none" fill-rule="evenodd"><path stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" d="M7.5 7h9z"/><path d="M7.916 9h8.168a1 1 0 01.99 1.14l-.972 6.862a2 2 0 01-1.473 1.653c-.877.23-1.753.345-2.629.345-.876 0-1.752-.115-2.628-.345a2 2 0 01-1.473-1.653l-.973-6.862A1 1 0 017.916 9z" fill="currentColor"/><rect fill="currentColor" x="10" y="5" width="4" height="3" rx="1"/></g>',
    shapeIconButtonDuplicate: '<g fill="none" fill-rule="evenodd"><path d="M15 13.994V16a2 2 0 01-2 2H8a2 2 0 01-2-2v-5a2 2 0 012-2h2.142" stroke="currentColor" stroke-width=".125em"/><path d="M15 9V8a1 1 0 00-2 0v1h-1a1 1 0 000 2h1v1a1 1 0 002 0v-1h1a1 1 0 000-2h-1zm-4-4h6a2 2 0 012 2v6a2 2 0 01-2 2h-6a2 2 0 01-2-2V7a2 2 0 012-2z" fill="currentColor"/></g>',
    shapeIconButtonMoveToFront: '<g fill="none" fill-rule="evenodd"><rect fill="currentColor" x="11" y="13" width="8" height="2" rx="1"/><rect fill="currentColor" x="9" y="17" width="10" height="2" rx="1"/><path d="M11.364 8H10a5 5 0 000 10M12 6.5L14.5 8 12 9.5z" stroke="currentColor" stroke-width=".125em" stroke-linecap="round"/></g>',
    shapeIconButtonTextLayoutAutoWidth: "" + kv,
    shapeIconButtonTextLayoutAutoHeight: '<g fill="currentColor"><circle cx="4" cy="12" r="1.5"/><circle cx="20" cy="12" r="1.5"/></g>' + kv,
    shapeIconButtonTextLayoutFixedSize: '<g fill="currentColor"><circle cx="5" cy="6" r="1.5"/><circle cx="19" cy="6" r="1.5"/><circle cx="19" cy="19" r="1.5"/><circle cx="5" cy="19" r="1.5"/></g>' + kv,
    shapeTitleButtonTextLayoutAutoWidth: "Auto width",
    shapeTitleButtonTextLayoutAutoHeight: "Auto height",
    shapeTitleButtonTextLayoutFixedSize: "Fixed size",
    shapeTitleButtonFlipHorizontal: "Flip Horizontal",
    shapeTitleButtonFlipVertical: "Flip Vertical",
    shapeTitleButtonRemove: "Remove",
    shapeTitleButtonDuplicate: "Duplicate",
    shapeTitleButtonMoveToFront: "Move to front",
    shapeLabelInputText: "Edit text",
    shapeIconInputCancel: '<g fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round" stroke="currentColor" stroke-width=".125em"><path d="M18 6L6 18M6 6l12 12"/></g>',
    shapeIconInputConfirm: '<g fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round" stroke="currentColor" stroke-width=".125em"><polyline points="20 6 9 17 4 12"/></g>',
    shapeLabelInputCancel: "Cancel",
    shapeLabelInputConfirm: "Confirm",
    shapeLabelStrokeNone: "No outline",
    shapeLabelFontStyleNormal: "Normal",
    shapeLabelFontStyleBold: "Bold",
    shapeLabelFontStyleItalic: "Italic",
    shapeLabelFontStyleItalicBold: "Bold Italic",
    shapeTitleBackgroundColor: "Fill color",
    shapeTitleCornerRadius: "Corner radius",
    shapeTitleFontFamily: "Font",
    shapeTitleFontSize: "Font size",
    shapeTitleFontStyle: "Font style",
    shapeTitleLineHeight: "Line height",
    shapeTitleLineStart: "Start",
    shapeTitleLineEnd: "End",
    shapeTitleStrokeWidth: "Line width",
    shapeTitleStrokeColor: "Line color",
    shapeTitleLineDecorationBar: "Bar",
    shapeTitleLineDecorationCircle: "Circle",
    shapeTitleLineDecorationSquare: "Square",
    shapeTitleLineDecorationArrow: "Arrow",
    shapeTitleLineDecorationCircleSolid: "Circle solid",
    shapeTitleLineDecorationSquareSolid: "Square solid",
    shapeTitleLineDecorationArrowSolid: "Arrow solid",
    shapeIconLineDecorationBar: '<g stroke="currentColor" stroke-linecap="round" stroke-width=".125em"><path d="M5,12 H16"/><path d="M16,8 V16"/></g>',
    shapeIconLineDecorationCircle: '<g stroke="currentColor" stroke-linecap="round"><path stroke-width=".125em" d="M5,12 H12"/><circle fill="none" stroke-width=".125em" cx="16" cy="12" r="4"/></g>',
    shapeIconLineDecorationSquare: '<g stroke="currentColor" stroke-linecap="round"><path stroke-width=".125em" d="M5,12 H12"/><rect fill="none" stroke-width=".125em" x="12" y="8" width="8" height="8"/></g>',
    shapeIconLineDecorationArrow: '<g stroke="currentColor" stroke-linecap="round" stroke-width=".125em"><path d="M5,12 H16 M13,7 l6,5 l-6,5" fill="none"/></g>',
    shapeIconLineDecorationCircleSolid: '<g stroke="currentColor" stroke-linecap="round"><path stroke-width=".125em" d="M5,12 H12"/><circle fill="currentColor" cx="16" cy="12" r="4"/></g>',
    shapeIconLineDecorationSquareSolid: '<g stroke="currentColor" stroke-linecap="round"><path stroke-width=".125em" d="M5,12 H12"/><rect fill="currentColor" x="12" y="8" width="8" height="8"/></g>',
    shapeIconLineDecorationArrowSolid: '<g stroke="currentColor" stroke-linecap="round" stroke-width=".125em"><path d="M5,12 H16"/><path d="M13,7 l6,5 l-6,5z" fill="currentColor"/></g>',
    shapeTitleColorTransparent: "Transparent",
    shapeTitleColorWhite: "White",
    shapeTitleColorSilver: "Silver",
    shapeTitleColorGray: "Gray",
    shapeTitleColorBlack: "Black",
    shapeTitleColorNavy: "Navy",
    shapeTitleColorBlue: "Blue",
    shapeTitleColorAqua: "Aqua",
    shapeTitleColorTeal: "Teal",
    shapeTitleColorOlive: "Olive",
    shapeTitleColorGreen: "Green",
    shapeTitleColorYellow: "Yellow",
    shapeTitleColorOrange: "Orange",
    shapeTitleColorRed: "Red",
    shapeTitleColorMaroon: "Maroon",
    shapeTitleColorFuchsia: "Fuchsia",
    shapeTitleColorPurple: "Purple",
    shapeTitleTextOutline: "Text outline",
    shapeTitleTextOutlineWidth: "Width",
    shapeTitleTextShadow: "Text shadow",
    shapeTitleTextShadowBlur: "Blur",
    shapeTitleTextColor: "Font color",
    shapeTitleTextAlign: "Text align",
    shapeTitleTextAlignLeft: "Left align text",
    shapeTitleTextAlignCenter: "Center align text",
    shapeTitleTextAlignRight: "Right align text",
    shapeIconTextAlignLeft: '<g stroke-width=".125em" stroke="currentColor"><line x1="5" y1="8" x2="15" y2="8"/><line x1="5" y1="12" x2="19" y2="12"/><line x1="5" y1="16" x2="14" y2="16"/></g>',
    shapeIconTextAlignCenter: '<g stroke-width=".125em" stroke="currentColor"><line x1="7" y1="8" x2="17" y2="8"/><line x1="5" y1="12" x2="19" y2="12"/><line x1="8" y1="16" x2="16" y2="16"/></g>',
    shapeIconTextAlignRight: '<g stroke-width=".125em" stroke="currentColor"><line x1="9" y1="8" x2="19" y2="8"/><line x1="5" y1="12" x2="19" y2="12"/><line x1="11" y1="16" x2="19" y2="16"/></g>',
    shapeLabelToolMove: "Move",
    shapeLabelToolView: "View",
    shapeLabelToolSharpie: "Sharpie",
    shapeLabelToolEraser: "Eraser",
    shapeLabelToolPath: "Path",
    shapeLabelToolRectangle: "Rectangle",
    shapeLabelToolEllipse: "Ellipse",
    shapeLabelToolArrow: "Arrow",
    shapeLabelToolLine: "Line",
    shapeLabelToolText: "Text",
    shapeLabelToolPreset: "Stickers",
    shapeIconToolView: '<g stroke-width=".125em" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path d="M10.98 9.703V2.567c0-1.19 1.19-1.785 1.784-1.785.595 0 1.784.595 1.784 1.785v3.568"/><path d="M14.548 9.703V4.35c0-1.19 1.19-1.784 1.784-1.784.595 0 1.784.594 1.784 1.784v2.973"/><path d="M18.116 10.244V7.271c0-1.19 1.19-1.784 1.784-1.784.595 0 1.785.595 1.785 1.784 0 1.19 0 8.92-1.19 12.488-1.19 3.569-10.704 4.758-13.678 0-2.973-4.757-2.973-4.757-4.163-6.541-1.189-1.784-1.153-2.974-.594-3.568.558-.595 1.784-1.19 2.973.594 1.277 1.916 2.07 2.907 2.379 2.974V5.487c0-1.19 1.19-1.784 1.784-1.784.595 0 1.784.595 1.784 1.784V8.46"/></g>',
    shapeIconToolMove: '<g stroke-width=".125em" stroke="currentColor" fill="none"><path d="M6 2 L6 19 L18 13 Z M13 18 L16 24" stroke="currentColor" stroke-width=".125em" fill="none" fill-rule="evenodd" stroke-linejoin="round"/></g>',
    shapeIconToolSharpie: '<g stroke-width=".125em" stroke="currentColor" fill="none"><path d="M2.025 5c5.616-2.732 8.833-3.857 9.65-3.374C12.903 2.351.518 12.666 2.026 14 3.534 15.334 16.536.566 17.73 2.566 18.924 4.566 3.98 17.187 4.831 18c.851.813 9.848-6 11.643-6 1.087 0-2.53 5.11-2.92 7-.086.41 3.323-1.498 4.773-1 .494.17.64 2.317 1.319 3 .439.443 1.332.776 2.679 1" stroke="currentColor" stroke-width=".125em" fill="none" fill-rule="evenodd" stroke-linejoin="round"/></g>',
    shapeIconToolEraser: '<g stroke-width=".125em" stroke="currentColor" stroke-linecap="round" fill="none"><g transform="translate(3, 15) rotate(-45)"><rect x="0" y="0" width="18" height="10" rx="3"/></g><line x1="11" y1="21" x2="18" y2="21"/><line x1="20" y1="21" x2="22" y2="21"/></g>',
    shapeIconToolPath: '<g stroke-width=".125em" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" fill="none"><circle cx="21" cy="3" r="2"/><circle cx="9" cy="9" r="2"/><circle cx="3" cy="21" r="2"/><path d="M19 4 11 8 M8 11 4 19"/></g>',
    shapeIconToolRectangle: '<g stroke-width=".125em" stroke="currentColor" fill="none"><rect x="1" y="1" width="22" height="22" rx="4"/></g>',
    shapeIconToolEllipse: '<g stroke-width=".125em" stroke="currentColor" fill="none"><circle cx="12" cy="12" r="11"/></g>',
    shapeIconToolArrow: '<g stroke-width=".125em" stroke="currentColor" fill="none"><line x1="20" y1="3" x2="6" y2="21"/><path d="m10 6 L21.5 1 L20 13.5" fill="currentColor" stroke="none"/></g>',
    shapeIconToolLine: '<g stroke-width=".125em" stroke="currentColor" fill="none"><line x1="20" y1="3" x2="6" y2="21"/></g>',
    shapeIconToolText: '<g stroke="none" fill="currentColor" transform="translate(6,0)"><path d="M8.14 20.085c.459 0 .901-.034 1.329-.102a8.597 8.597 0 001.015-.21v1.984c-.281.135-.695.247-1.242.336a9.328 9.328 0 01-1.477.133c-3.312 0-4.968-1.745-4.968-5.235V6.804H.344v-1.25l2.453-1.078L3.89.819h1.5v3.97h4.97v2.015H5.39v10.078c0 1.031.245 1.823.735 2.375s1.161.828 2.015.828z"/>',
    shapeIconToolPreset: '<g fill="none" stroke-linecap="round" stroke-linejoin="round" stroke="currentColor" stroke-width=".125em"><path d="M12 22c2.773 0 1.189-5.177 3-7 1.796-1.808 7-.25 7-3 0-5.523-4.477-10-10-10S2 6.477 2 12s4.477 10 10 10z"></path><path d="M20 17c-3 3-5 5-8 5"></path></g>',
    shapeTitleSelectionMode: "Selection mode",
    shapeTitleBrushSize: "Brush size",
    shapeLabelSelectionModeNew: "New",
    shapeLabelSelectionModeAdd: "Add",
    shapeLabelSelectionModeSubtract: "Remove",
    shapeLabelToolSelectionBrush: "Brush",
    shapeLabelToolSelectionLassoo: "Lassoo",
    shapeLabelToolSelectionRectangle: "Rectangle marquee",
    shapeLabelToolSelectionEllipse: "Ellipse marquee",
    shapeIconSelectionModeNew: '<g fill="none" fill-rule="evenodd" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"><path d="M6.5 17H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2v1.5"/><rect width="12" height="12" x="9" y="9" fill="currentColor" fill-opacity=".25" rx="2"/></g>',
    shapeIconSelectionModeAdd: '<g fill="none" fill-rule="evenodd" stroke="currentColor"><path fill="currentColor" fill-opacity=".25" stroke-linecap="round" stroke-linejoin="round" d="M15 3a2 2 0 0 1 2 2v4h2a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2h-8a2 2 0 0 1-2-2v-2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h10Z"/><path d="M13 15h4M15 13v4"/></g>',
    shapeIconSelectionModeSubtract: '<g fill="none" fill-rule="evenodd" stroke="currentColor"><path fill="currentColor" fill-opacity=".25" stroke-linecap="round" stroke-linejoin="round" d="M15 3a2 2 0 0 1 2 2v4h-6a2 2 0 0 0-1.995 1.85L9 11v6H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h10Z"/><rect width="12" height="12" x="9" y="9" stroke-linecap="round" stroke-linejoin="round" rx="2"/><path d="M13 15h4"/></g>',
    shapeIconToolSelectionBrush: '<g stroke-width=".125em" stroke="currentColor" fill="none"><path d="M2.025 5c5.616-2.732 8.833-3.857 9.65-3.374C12.903 2.351.518 12.666 2.026 14 3.534 15.334 16.536.566 17.73 2.566 18.924 4.566 3.98 17.187 4.831 18c.851.813 9.848-6 11.643-6 1.087 0-2.53 5.11-2.92 7-.086.41 3.323-1.498 4.773-1 .494.17.64 2.317 1.319 3 .439.443 1.332.776 2.679 1" stroke="currentColor" fill-rule="evenodd" stroke-linejoin="round"/></g>',
    shapeIconToolSelectionLassoo: '<g fill="none" fill-rule="evenodd" stroke-width=".125em" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M11.428 17.702a18.46 18.46 0 0 0 4.085-1.595c5.851-3.112 9.019-8.599 7.074-12.256-1.945-3.657-8.265-4.1-14.116-.988C2.619 5.974-.55 11.46 1.396 15.118c.63 1.186 1.72 2.033 3.105 2.532"/><ellipse cx="8" cy="18.5" rx="3.5" ry="2.833" transform="rotate(-15 8 18.5)"/><path stroke-linecap="round" d="M5 18c3.347 1.048 5.514 1.881 6.5 2.5.859.54 1.517.994 1.5 2.364"/></g>',
    shapeIconToolSelectionRectangle: '<g stroke-width=".125em" stroke="currentColor"><path d="M9 1 h6 m4 0 h4v4 m0 4 v6 m0 4 v4h-4 m-4 0 h-6 m-4 0 h-4v-4 m0 -4 v-6 m0 -4 v-4h4" fill="none" /></g>',
    shapeIconToolSelectionEllipse: '<path stroke-width=".125em" stroke="currentColor" d="M1.21 9.853a11.054 11.054 0 0 0 0 4.294m1.643 3.965a11.054 11.054 0 0 0 3.035 3.035m3.965 1.644a11.054 11.054 0 0 0 4.294 0m3.965-1.644a11.054 11.054 0 0 0 3.035-3.035m1.644-3.965a11.054 11.054 0 0 0 0-4.294m-1.644-3.965a11.054 11.054 0 0 0-3.035-3.035m-3.965-1.644a11.054 11.054 0 0 0-4.294 0M5.888 2.853a11.054 11.054 0 0 0-3.035 3.035"/>'
};
var Mv = {
    cropLabel: "Crop",
    cropIcon: '<g stroke-width=".125em" stroke="currentColor" fill="none"><path d="M23 17H9a2 2 0 0 1-2-2v-5m0-3V1 M1 7h14a2 2 0 0 1 2 2v7m0 4v3"/></g>',
    cropIconButtonRecenter: '<path stroke="currentColor" fill="none" stroke-width="2" stroke-linejoin="bevel" d="M1.5 7.5v-6h6M1.5 16.5v6h6M22.5 16.5v6h-6M22.5 7.5v-6h-6"/><circle cx="12" cy="12" r="3.5" fill="currentColor" stroke="none"/>',
    cropIconButtonRotateLeft: '<g stroke="none" fill="currentColor"><path fill="none" d="M-1-1h582v402H-1z"/><rect x="3" rx="1" height="12" width="12" y="9"/><path d="M15 5h-1a5 5 0 015 5 1 1 0 002 0 7 7 0 00-7-7h-1.374l.747-.747A1 1 0 0011.958.84L9.603 3.194a1 1 0 000 1.415l2.355 2.355a1 1 0 001.415-1.414l-.55-.55H15z"/></g>',
    cropIconButtonRotateRight: '<g stroke="none" fill="currentColor"><path fill="none" d="M-1-1h582v402H-1z"/><path d="M11.177 5H10a5 5 0 00-5 5 1 1 0 01-2 0 7 7 0 017-7h1.374l-.747-.747A1 1 0 0112.042.84l2.355 2.355a1 1 0 010 1.415l-2.355 2.354a1 1 0 01-1.415-1.414l.55-.55z"/><rect rx="1" height="12" width="12" y="9" x="9"/></g>',
    cropIconButtonFlipVertical: '<g stroke="none" fill="currentColor"><path d="M19.993 12.143H7a1 1 0 0 1-1-1V5.994a1 1 0 0 1 1.368-.93l12.993 5.15a1 1 0 0 1-.368 1.93z"/><path d="M19.993 14a1 1 0 0 1 .368 1.93L7.368 21.078A1 1 0 0 1 6 20.148V15a1 1 0 0 1 1-1h12.993z" opacity=".6"/></g>',
    cropIconButtonFlipHorizontal: '<g stroke="none" fill="currentColor"><path d="M11.93 7.007V20a1 1 0 0 1-1 1H5.78a1 1 0 0 1-.93-1.368l5.15-12.993a1 1 0 0 1 1.929.368z"/><path d="M14 7.007V20a1 1 0 0 0 1 1h5.149a1 1 0 0 0 .93-1.368l-5.15-12.993A1 1 0 0 0 14 7.007z" opacity=".6"/></g>',
    cropIconSelectPreset: '<g fill="currentColor">\n        <rect opacity="{a}" x="2" y="4" width="10" height="18" rx="1"/>\n        <rect opacity="{b}" x="4" y="8" width="14" height="14" rx="1"/>\n        <rect opacity="{c}" x="6" y="12" width="17" height="10" rx="1"/>\n    </g>',
    cropIconCropBoundary: '<g fill="currentColor">\n        <rect opacity="{a}" x="2" y="3" width="20" height="20" rx="1"/>\n        <rect opacity="{b}" x="7" y="8" width="10" height="10" rx="1"/>\n        <rect opacity="{c}" x="4" y="8" width="14" height="14" rx="1"/>\n        <rect opacity="{d}" x="12" y="4" width="10" height="10" rx="1"/>\n    </g>',
    cropLabelButtonRecenter: "Recenter",
    cropLabelButtonRotateLeft: "Rotate left",
    cropLabelButtonRotateRight: "Rotate right",
    cropLabelButtonFlipHorizontal: "Flip horizontal",
    cropLabelButtonFlipVertical: "Flip vertical",
    cropLabelSelectPreset: "Crop shape",
    cropLabelCropBoundary: "Crop boundary",
    cropLabelCropBoundaryEdge: "Edge of image",
    cropLabelCropBoundaryNone: "None",
    cropLabelTabRotation: "Rotation",
    cropLabelTabZoom: "Scale"
}, Pv = {
    fillLabel: "Fill",
    fillIcon: '\n    <g fill="none" stroke-linecap="round" stroke-linejoin="round" stroke="currentColor" stroke-width=".125em">\n        <g transform="rotate(60, 12, 12)">\n            <rect x="4" y="4" width="14" height="16" rx="3"/>\n        </g>\n        <path d="M21 13 L21 21"></path>\n        <path d="M4.5 12.5 L19 12.5"></path>\n    </g>\n    '
}, Rv = {
    resizeLabel: "Resize",
    resizeIcon: '<g stroke-width=".125em" stroke="currentColor" fill="none"><rect x="2" y="12" width="10" height="10" rx="2"/><path d="M4 11.5V4a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-5.5"/><path d="M14 10l3.365-3.365M14 6h4v4"/></g>',
    resizeLabelFormCaption: "Image output size",
    resizeLabelInputWidth: "w",
    resizeTitleInputWidth: "Width",
    resizeLabelInputHeight: "h",
    resizeTitleInputHeight: "Height",
    resizeTitleButtonMaintainAspectRatio: "Maintain aspectratio",
    resizeIconButtonMaintainAspectRatio: '<defs><mask id="mask1" x="-2" y="-2" width="24" height="24"><rect x="0" y="0" width="24" height="10" fill="#fff" stroke="none"/></mask></defs><g fill="none" fill-rule="evenodd"><g mask="url(#mask1)"><path transform="translate(0 {activeFraction})" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" d="M9.401 10.205v-.804a2.599 2.599 0 0 1 5.198 0V17"/></g><rect fill="currentColor" x="7" y="10" width="10" height="7" rx="1.5"/></g>'
}, Iv = {
    frameLabel: "Frame",
    frameIcon: '<g fill="none" stroke-linecap="round" stroke-linejoin="round" stroke="currentColor" stroke-width=".125em">\n            <rect x="2" y="2" width="20" height="20" rx="4"/>\n            <rect x="6" y="6" width="12" height="12" rx="1"/>\n        </g>',
    frameLabelMatSharp: "Mat",
    frameLabelMatRound: "Bevel",
    frameLabelLineSingle: "Line",
    frameLabelLineMultiple: "Zebra",
    frameLabelEdgeSeparate: "Inset",
    frameLabelEdgeOverlap: "Plus",
    frameLabelEdgeCross: "Lumber",
    frameLabelCornerHooks: "Hook",
    frameLabelPolaroid: "Polaroid"
}, Ev = {
    redactLabel: "Redact",
    redactIcon: '<g fill="none" stroke-linecap="round" stroke-linejoin="round" stroke="currentColor" stroke-width=".125em"><path d="M 4 5 l 1 -1"/><path d="M 4 10 l 6 -6"/><path d="M 4 15 l 11 -11"/><path d="M 4 20 l 16 -16"/><path d="M 9 20 l 11 -11"/><path d="M 14 20 l 6 -6"/><path d="M 19 20 l 1 -1"/></g>'
}, Av = {
    retouchLabel: "Retouch",
    retouchIcon: '\n    <g fill="none" fill-rule="evenodd"><path fill="currentColor" d="m17 6-2-1-2 1 1-2-1-2 2 1 2-1-1 2zM5.5 5.5 3 4 .5 5.5 2 3 .5.5 3 2 5.5.5 4 3zM9 21l-3-1.5L3 21l1.5-3L3 15l3 1.5L9 15l-1.5 3z"/><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="m9.266 6.705 13.529 13.529c-.071.78-.34 1.371-.765 1.796-.425.425-1.015.694-1.796.765h0L6.705 9.266c.071-.78.34-1.371.765-1.796.425-.425 1.015-.694 1.796-.765h0Z"/><path stroke="currentColor" stroke-width="1.5" d="M12 9.5c-.657.323-1.157.657-1.5 1-.343.343-.677.843-1 1.5"/></g>\n    '
}, Lv = (e, t) => {
    const o = Object.getOwnPropertyDescriptors(e);
    Object.keys(o).forEach((i => {
        o[i].get ? Object.defineProperty(t, i, {get: () => e[i], set: t => e[i] = t}) : t[i] = e[i]
    }))
}, Fv = e => {
    const t = {}, {sub: o, pub: n} = Ko();
    l() && null !== document.doctype || console.warn("Browser is in quirks mode, add <!DOCTYPE html> to page to fix render issues");
    const r = Fs();
    Lv(r, t);
    const a = ((e, t) => {
        const o = {}, i = new Map, n = new jm({target: e, props: {stores: t, pluginComponents: Array.from(Km)}});
        let r = !1;
        const a = () => {
            r || (l() && window.removeEventListener("pagehide", a), n && (r = !0, n.$destroy()))
        };

        function s(e, t) {
            return i.get(e) === t || (i.set(e, t), !1)
        }

        Xm || (Xm = new Set(gd(jm).filter((e => !Gm.includes(e))))), Xm.forEach((e => {
            Object.defineProperty(o, e, {
                get: () => n[e], set: Zm.includes(e) ? t => {
                    s(e, t) || (n[e] = {...n[e], ...t})
                } : t => {
                    s(e, t) || (n[e] = t)
                }
            })
        })), Object.defineProperty(o, "previewImageData", {get: () => n.imagePreviewCurrent}), Ym.forEach((e => {
            const t = qm[e], i = t[0];
            Object.defineProperty(o, e, {
                get: () => n.pluginInterface[i][e], set: o => {
                    if (s(e, o)) return;
                    const i = t.reduce(((t, i) => (t[i] = {...n.pluginOptions[i], [e]: o}, t)), {});
                    n.pluginOptions = {...n.pluginOptions, ...i}
                }
            })
        })), Object.defineProperty(o, "element", {
            get: () => n.root, set: () => {
            }
        });
        const c = n.history;
        return ss(o, {
            on: (e, t) => {
                if (r) return () => {
                };
                if (/undo|redo|revert|writehistory/.test(e)) return c.on(e, t);
                const o = [n.sub(e, t), n.$on(e, (e => t(e instanceof CustomEvent && !e.detail ? void 0 : e)))].filter(Boolean);
                return () => o.forEach((e => e()))
            }, updateImagePreview: e => {
                n.imagePreviewSrc = e
            }, close: () => !r && n.pub("close"), destroy: a
        }), Object.defineProperty(o, "history", {
            get: () => ({
                undo: () => c.undo(),
                redo: () => c.redo(),
                revert: () => c.revert(),
                get: () => c.get(),
                getCollapsed: () => c.get().splice(0, c.index + 1),
                set: e => c.set(e),
                write: e => c.write(e),
                get length() {
                    return c.length()
                },
                get index() {
                    return c.index
                },
                set index(e) {
                    c.index = e
                }
            })
        }), l() && window.addEventListener("pagehide", a), o
    })(e, r.stores);
    Lv(a, t);
    const s = ["loadImage", "processImage", "abortProcessImage", "abortLoadImage"].map((e => a.on(e, (t => {
        const o = r[e](t && t.detail);
        o instanceof Promise && o.catch(i)
    })))), c = (e, t) => {
        const i = o(e, t), n = r.on(e, t), s = a.on(e, t);
        return () => {
            i(), n(), s()
        }
    };
    t.handleEvent = i;
    const d = Qm.map((e => c(e, (o => t.handleEvent(e, o)))));
    return ss(t, {
        on: c, updateImage: e => new Promise(((o, i) => {
            const n = t.history.get(), a = t.history.index, s = t.imageState;
            r.loadImage(e).then((e => {
                t.history.set(n), t.history.index = a, t.imageState = s, o(e)
            })).catch(i)
        })), close: () => {
            n("close")
        }, destroy: () => {
            [...s, ...d].forEach((e => e())), a.destroy(), r.destroy(), n("destroy")
        }
    }), setTimeout((() => n("init", t)), 0), t
};
const zv = "pintura-editor";
var Dv = () => new Promise((e => {
    if (!Bv) return e([]);
    var t;
    t = zv, document.createElement(t).constructor === HTMLElement && customElements.define(zv, Bv), customElements.whenDefined(zv).then((() => e(document.querySelectorAll(zv))))
}));
const Bv = l() && class extends HTMLElement {
    constructor() {
        super(), this._editor = void 0, this._unsubs = void 0
    }

    static get observedAttributes() {
        return ["src"]
    }

    attributeChangedCallback(e, t, o) {
        this[e] = o
    }

    connectedCallback() {
        this._editor = Fv(this), Lv(this._editor, this), this._editor.src = this.getAttribute("src"), this._unsubs = eg(this._editor, this)
    }

    disconnectedCallback() {
        this._editor.destroy(), this._unsubs.forEach((e => e()))
    }
};
var Ov = (e, t = {}) => {
    const o = h(e) ? document.querySelector(e) : e;
    if (!Nt(o)) return;
    t.class = t.class ? "pintura-editor " + t.class : "pintura-editor";
    const i = Fv(o);
    return Object.assign(i, t)
};
const {document: Wv, window: Vv} = za;

function _v(e) {
    let t, o, i, n;
    return ba(e[30]), {
        c() {
            t = Br(), o = Fr("div"), Nr(o, "class", e[4]), Nr(o, "aria-modal", "true"), Nr(o, "aria-label", "Pintura"), Nr(o, "role", "dialog"), Nr(o, "tabindex", "-1"), Zr(o, "--editor-modal", 1), Zr(o, "--viewport-pad-footer", e[5]), Zr(o, "opacity", e[7]), Zr(o, "height", e[6])
        }, m(r, a) {
            Ar(r, t, a), Ar(r, o, a), e[31](o), i || (n = [Wr(Vv, "keydown", e[13]), Wr(Vv, "orientationchange", e[14]), Wr(Vv, "resize", e[30]), Wr(Wv.body, "focusin", (function () {
                sr(!e[1] && e[10]) && (!e[1] && e[10]).apply(this, arguments)
            })), Wr(Wv.body, "focusout", (function () {
                sr(e[2] && e[11]) && (e[2] && e[11]).apply(this, arguments)
            })), Wr(Wv.body, "keydown", e[9]), Wr(o, "wheel", e[12], {passive: !1})], i = !0)
        }, p(t, i) {
            e = t, 16 & i[0] && Nr(o, "class", e[4]), 32 & i[0] && Zr(o, "--viewport-pad-footer", e[5]), 128 & i[0] && Zr(o, "opacity", e[7]), 64 & i[0] && Zr(o, "height", e[6])
        }, i: tr, o: tr, d(r) {
            r && Lr(t), r && Lr(o), e[31](null), i = !1, ar(n)
        }
    }
}

function Nv(e, t, o) {
    let i, n, r, a, s, c, d, u, h;
    const p = sa();
    let {root: g} = t, {preventZoomViewport: $ = !0} = t, {preventScrollBodyIfNeeded: f = !0} = t, {preventFooterOverlapIfNeeded: y = !0} = t, {preventModalAutoFocus: b = !1} = t, {class: x} = t,
        v = !0, w = !1, S = !1, k = l() && document.documentElement, C = l() && document.body, T = l() && document.head;
    const M = bc(0, {precision: .001, damping: .5});
    pr(e, M, (e => o(29, h = e)));
    const P = M.subscribe((e => {
        S && e >= 1 ? (o(23, S = !1), o(1, v = !1), p("show")) : w && e <= 0 && (o(22, w = !1), o(1, v = !0), p("hide"))
    }));
    let R = !1, I = void 0, E = void 0, A = void 0;
    const L = () => document.querySelector("meta[name=viewport]"),
        F = () => Array.from(document.querySelectorAll("meta[name=theme-color]")),
        z = e => "radio" === e.type ? Array.from(g.querySelectorAll(`input[name="${e.name}"]`)) : [e];
    let D;
    const B = (e, t) => {
        const o = () => {
            e() ? t() : requestAnimationFrame(o)
        };
        requestAnimationFrame(o)
    };
    let O, W, V = 0, _ = void 0;
    const N = () => {
        W || (W = m("div", {style: "position:fixed;height:100vh;top:0"}), C.append(W))
    };
    na((() => {
        b || g.focus(), y && bo() && N()
    })), ra((() => {
        W && (o(25, _ = W.offsetHeight), W.remove(), W = void 0)
    }));
    let H = void 0;
    const j = () => k.style.setProperty("--pintura-document-height", window.innerHeight + "px");
    return aa((() => {
        k.classList.remove("PinturaModalBodyLock"), P()
    })), e.$$set = e => {
        "root" in e && o(0, g = e.root), "preventZoomViewport" in e && o(15, $ = e.preventZoomViewport), "preventScrollBodyIfNeeded" in e && o(16, f = e.preventScrollBodyIfNeeded), "preventFooterOverlapIfNeeded" in e && o(17, y = e.preventFooterOverlapIfNeeded), "preventModalAutoFocus" in e && o(18, b = e.preventModalAutoFocus), "class" in e && o(19, x = e.class)
    }, e.$$.update = () => {
        549453826 & e.$$.dirty[0] && o(28, i = S || w ? h : v ? 0 : 1), 32768 & e.$$.dirty[0] && (n = "width=device-width,height=device-height,initial-scale=1" + ($ ? ",maximum-scale=1,user-scalable=0" : "")), 12582914 & e.$$.dirty[0] && o(26, r = !S && !v && !w), 12 & e.$$.dirty[0] && (R || o(24, O = V)), 268435456 & e.$$.dirty[0] && o(7, a = i), 16777216 & e.$$.dirty[0] && o(6, s = O + "px"), 33554440 & e.$$.dirty[0] && o(5, c = zo(_) ? "--viewport-pad-footer:" + (_ > V ? 0 : 1) : void 0), 524288 & e.$$.dirty[0] && o(4, d = Zc(["pintura-editor", "PinturaModal", x])), 65536 & e.$$.dirty[0] && o(27, u = f && bo() && /15_/.test(navigator.userAgent)), 201326592 & e.$$.dirty[0] && u && (e => {
            e ? (H = window.scrollY, k.classList.add("PinturaDocumentLock"), j(), window.addEventListener("resize", j)) : (window.removeEventListener("resize", j), k.classList.remove("PinturaDocumentLock"), zo(H) && window.scrollTo(0, H), H = void 0)
        })(r)
    }, [g, v, R, V, d, c, s, a, M, e => {
        if ("Tab" !== e.key) return;
        const t = document.activeElement,
            o = g.querySelectorAll('button:not([disabled]),textarea:not([disabled]),input:not([disabled]),select:not([disabled]),[tabindex="0"]'),
            i = z(o[0]), n = z(o[o.length - 1]);
        let r;
        e.shiftKey && i.includes(t) ? r = n[0] : !e.shiftKey && n.includes(t) && (r = i[0]), r && (r.focus(), e.preventDefault())
    }, e => {
        Wd(e.target) && (o(2, R = !0), D = V)
    }, e => {
        if (Wd(e.target)) if (clearTimeout(undefined), D === V) o(2, R = !1); else {
            const e = V;
            B((() => V !== e), (() => o(2, R = !1)))
        }
    }, e => {
        e.target && /PinturaStage/.test(e.target.className) && e.preventDefault()
    }, e => {
        const {key: t} = e;
        if (!/escape/i.test(t)) return;
        const o = e.target;
        if (o && /input|textarea/i.test(o.nodeName)) return;
        const i = document.querySelectorAll(".PinturaModal");
        i[i.length - 1] === g && p("close")
    }, N, $, f, y, b, x, () => {
        if (S || !v) return;
        o(23, S = !0);
        const e = L() || m("meta", {name: "viewport"});
        I = !I && e.getAttribute("content"), e.setAttribute("content", n + (/cover/.test(I) ? ",viewport-fit=cover" : "")), e.parentNode || T.append(e);
        const t = getComputedStyle(g).getPropertyValue("--color-background"), i = F();
        if (i.length) E = i.map((e => e.getAttribute("content"))); else {
            const e = m("meta", {name: "theme-color"});
            T.append(e), i.push(e)
        }
        i.forEach((e => e.setAttribute("content", `rgb(${t})`))), clearTimeout(A), A = setTimeout((() => M.set(1)), 250)
    }, () => {
        if (w || v) return;
        clearTimeout(A), o(22, w = !0);
        const e = L();
        I ? e.setAttribute("content", I) : e.remove();
        const t = F();
        E ? t.forEach(((e, t) => {
            e.setAttribute("content", E[t])
        })) : t.forEach((e => e.remove())), M.set(0)
    }, w, S, O, _, r, u, i, h, function () {
        o(3, V = Vv.innerHeight)
    }, function (e) {
        ha[e ? "unshift" : "push"]((() => {
            g = e, o(0, g)
        }))
    }]
}

class Hv extends Ga {
    constructor(e) {
        super(), Ua(this, e, Nv, _v, lr, {
            root: 0,
            preventZoomViewport: 15,
            preventScrollBodyIfNeeded: 16,
            preventFooterOverlapIfNeeded: 17,
            preventModalAutoFocus: 18,
            class: 19,
            show: 20,
            hide: 21
        }, null, [-1, -1])
    }

    get root() {
        return this.$$.ctx[0]
    }

    set root(e) {
        this.$$set({root: e}), ka()
    }

    get preventZoomViewport() {
        return this.$$.ctx[15]
    }

    set preventZoomViewport(e) {
        this.$$set({preventZoomViewport: e}), ka()
    }

    get preventScrollBodyIfNeeded() {
        return this.$$.ctx[16]
    }

    set preventScrollBodyIfNeeded(e) {
        this.$$set({preventScrollBodyIfNeeded: e}), ka()
    }

    get preventFooterOverlapIfNeeded() {
        return this.$$.ctx[17]
    }

    set preventFooterOverlapIfNeeded(e) {
        this.$$set({preventFooterOverlapIfNeeded: e}), ka()
    }

    get preventModalAutoFocus() {
        return this.$$.ctx[18]
    }

    set preventModalAutoFocus(e) {
        this.$$set({preventModalAutoFocus: e}), ka()
    }

    get class() {
        return this.$$.ctx[19]
    }

    set class(e) {
        this.$$set({class: e}), ka()
    }

    get show() {
        return this.$$.ctx[20]
    }

    get hide() {
        return this.$$.ctx[21]
    }
}

const jv = (e, t, o, i) => {
    const n = he(t.x - e.x, t.y - e.y), r = ye(n), a = 5 * o;
    let s;
    s = i ? .5 * a : Math.ceil(.5 * (a - 1));
    const l = Ce(me(r), s);
    return {anchor: me(e), offset: l, normal: r, solid: i, size: a, sizeHalf: s}
}, Uv = (e, t, o) => {
    const {strokeWidth: i, strokeColor: n, strokeJoin: r, strokeCap: a, ...s} = e, {
        anchor: l,
        offset: c,
        normal: d,
        solid: u,
        size: h,
        sizeHalf: p
    } = t, m = l.x, g = l.y, $ = Ce(me(d), h), f = he(m + $.x, g + $.y);
    if (Ce($, .55), u) {
        we(o, c);
        const e = Ce(me(d), .5 * p);
        return [{
            ...s,
            points: [he(m - e.x, g - e.y), he(f.x - $.y, f.y + $.x), he(f.x + $.y, f.y - $.x)],
            pathClose: !0,
            backgroundColor: n
        }]
    }
    {
        const e = Ce((e => {
            const t = e.x;
            return e.x = -e.y, e.y = t, e
        })(me(d)), .5), t = he(m - e.x, g - e.y), o = he(m + e.x, g + e.y);
        return [{
            ...s,
            points: [he(f.x + $.y, f.y - $.x), t, he(m, g), o, he(f.x - $.y, f.y + $.x)],
            pathClose: !1,
            strokeWidth: i,
            strokeColor: n,
            strokeJoin: r,
            strokeCap: a
        }]
    }
}, Gv = (e, t, o) => {
    const {strokeWidth: i, strokeColor: n, ...r} = e, {anchor: a, solid: s, offset: l, normal: c, sizeHalf: d} = t;
    return we(o, l), s && we(o, ge(me(c))), [{
        ...r,
        x: a.x,
        y: a.y,
        rx: d,
        ry: d,
        backgroundColor: s ? n : void 0,
        strokeWidth: s ? void 0 : i,
        strokeColor: s ? void 0 : n
    }]
}, Zv = (e, t) => {
    const {strokeWidth: o, strokeColor: i, strokeJoin: n, strokeCap: r, ...a} = e, {anchor: s, offset: l} = t;
    return [{
        ...a,
        points: [he(s.x - l.y, s.y + l.x), he(s.x + l.y, s.y - l.x)],
        strokeWidth: o,
        strokeColor: i,
        strokeJoin: n,
        strokeCap: r
    }]
}, Xv = (e, t, o) => {
    const {strokeWidth: i, strokeColor: n, ...r} = e, {anchor: a, solid: s, offset: l, normal: c, sizeHalf: d} = t;
    return we(o, l), [{
        ...r,
        x: a.x - d,
        y: a.y - d,
        width: 2 * d,
        height: 2 * d,
        rotation: (u = c, Math.atan2(u.y, u.x)),
        backgroundColor: s ? n : void 0,
        strokeWidth: s ? void 0 : i,
        strokeColor: s ? void 0 : n
    }];
    var u
}, Yv = (e = {}) => t => {
    if (!t.lineStart && !t.lineEnd) return;
    const o = [], {
            x1: i,
            y1: n,
            x2: r,
            y2: a,
            lineStart: s,
            lineEnd: l,
            strokeWidth: c,
            strokeColor: d,
            strokeJoin: u,
            strokeCap: h,
            strokeDash: p,
            bitmap: m,
            aboveFrame: g,
            opacity: $
        } = t, f = he(i, n), y = he(r, a), b = [f, y],
        x = {bitmap: m, aboveFrame: g, opacity: $, strokeColor: d, strokeWidth: c, strokeJoin: u, strokeCap: h};
    if (s) {
        const [t, i] = s.split("-"), n = e[t];
        if (n) {
            const e = jv(f, y, c, !!i);
            o.push(...n(x, e, f))
        }
    }
    if (l) {
        const [t, i] = l.split("-"), n = e[t];
        if (n) {
            const e = jv(y, f, c, !!i);
            o.push(...n(x, e, y))
        }
    }
    return [{...x, strokeDash: p, points: b}, ...o]
}, qv = () => ({arrow: Uv, circle: Gv, square: Xv, bar: Zv}), Kv = (e, t) => {
    const o = parseFloat(e) * t;
    return h(e) ? o + "%" : o
}, Jv = (e, t) => h(e) ? pn(e, t) : e, Qv = e => [{
    ...e,
    frameStyle: "line",
    frameInset: 0,
    frameOffset: 0,
    frameSize: e.frameSize ? Kv(e.frameSize, 2) : "2.5%",
    frameRadius: e.frameRound ? Kv(e.frameSize, 2) : 0
}], ew = ({
              width: e,
              height: t,
              frameImage: o,
              frameSize: i = "15%",
              frameOutset: n = 0,
              frameSlices: r = {x1: .15, y1: .15, x2: .85, y2: .85}
          }, {isPreview: a}) => {
    if (!o) return [];
    const s = Math.sqrt(e * t), l = Jv(i, s), c = a ? l : Math.round(l), d = c, u = Jv(n, s), h = 2 * u, {
        x1: p,
        x2: m,
        y1: g,
        y2: $
    } = r, f = {
        x0: 0,
        y0: 0,
        x1: c,
        y1: d,
        x2: e - c,
        y2: t - d,
        x3: e,
        y3: t,
        cw: c,
        ch: d,
        ew: e - c - c,
        eh: t - d - d
    }, y = a ? 1 : 0, b = 2 * y, x = u > 0, v = {expandsCanvas: x, width: f.cw, height: f.ch, backgroundImage: o};
    return [{
        expandsCanvas: x,
        x: f.x1 - y - u,
        y: f.y0 - u,
        width: f.ew + b + h,
        height: f.ch,
        backgroundCorners: [{x: p, y: 0}, {x: m, y: 0}, {x: m, y: g}, {x: p, y: g}],
        backgroundImage: o
    }, {
        expandsCanvas: x,
        x: f.x1 - y - u,
        y: f.y2 + u,
        width: f.ew + b + h,
        height: f.ch,
        backgroundCorners: [{x: p, y: $}, {x: m, y: $}, {x: m, y: 1}, {x: p, y: 1}],
        backgroundImage: o
    }, {
        expandsCanvas: x,
        x: f.x0 - u,
        y: f.y1 - y - u,
        width: f.cw,
        height: f.eh + b + h,
        backgroundCorners: [{x: 0, y: g}, {x: p, y: g}, {x: p, y: $}, {x: 0, y: $}],
        backgroundImage: o
    }, {
        expandsCanvas: x,
        x: f.x2 + u,
        y: f.y1 - y - u,
        width: f.cw,
        height: f.eh + b + h,
        backgroundCorners: [{x: m, y: g}, {x: 1, y: g}, {x: 1, y: $}, {x: m, y: $}],
        backgroundImage: o
    }, {
        ...v,
        x: f.x0 - u,
        y: f.y0 - u,
        backgroundCorners: [{x: 0, y: 0}, {x: p, y: 0}, {x: p, y: g}, {x: 0, y: g}]
    }, {
        ...v,
        x: f.x2 + u,
        y: f.y0 - u,
        backgroundCorners: [{x: m, y: 0}, {x: 1, y: 0}, {x: 1, y: g}, {x: m, y: g}]
    }, {
        ...v,
        x: f.x2 + u,
        y: f.y2 + u,
        backgroundCorners: [{x: m, y: $}, {x: 1, y: $}, {x: 1, y: 1}, {x: m, y: 1}]
    }, {...v, x: f.x0 - u, y: f.y2 + u, backgroundCorners: [{x: 0, y: $}, {x: p, y: $}, {x: p, y: 1}, {x: 0, y: 1}]}]
}, tw = ({
             x: e,
             y: t,
             width: o,
             height: i,
             frameInset: n = "3.5%",
             frameSize: r = ".25%",
             frameColor: a = [1, 1, 1],
             frameOffset: s = "5%",
             frameAmount: l = 1,
             frameRadius: c = 0,
             expandsCanvas: d = !1
         }, {isPreview: u}) => {
    const h = Math.sqrt(o * i);
    let p = Jv(r, h);
    const m = Jv(n, h), g = Jv(s, h);
    let $ = 0;
    u || (p = Math.max(1, Math.round(p)), $ = p % 2 == 0 ? 0 : .5);
    const f = Jv(Kv(c, l), h);
    return new Array(l).fill(void 0).map(((n, r) => {
        const s = g * r;
        let l = e + m + s, c = t + m + s, h = e + o - m - s, y = t + i - m - s;
        u || (l = Math.round(l), c = Math.round(c), h = Math.round(h), y = Math.round(y));
        return {
            x: l + $,
            y: c + $,
            width: h - l,
            height: y - c,
            cornerRadius: f > 0 ? f - s : 0,
            strokeWidth: p,
            strokeColor: a,
            expandsCanvas: d
        }
    }))
}, ow = ({
             x: e,
             y: t,
             width: o,
             height: i,
             frameSize: n = ".25%",
             frameOffset: r = 0,
             frameInset: a = "2.5%",
             frameColor: s = [1, 1, 1]
         }, {isPreview: l}) => {
    const c = Math.sqrt(o * i);
    let d = Jv(n, c), u = Jv(a, c), h = Jv(r, c), p = 0;
    l || (d = Math.max(1, Math.round(d)), u = Math.round(u), h = Math.round(h), p = d % 2 == 0 ? 0 : .5);
    const m = h - u, g = e + u + p, $ = t + u + p, f = e + o - u - p, y = t + i - u - p;
    return [{points: [he(g + m, $), he(f - m, $)]}, {points: [he(f, $ + m), he(f, y - m)]}, {points: [he(f - m, y), he(g + m, y)]}, {points: [he(g, y - m), he(g, $ + m)]}].map((e => (e.strokeWidth = d, e.strokeColor = s, e)))
}, iw = ({
             x: e,
             y: t,
             width: o,
             height: i,
             frameSize: n = ".25%",
             frameInset: r = "2.5%",
             frameLength: a = "2.5%",
             frameColor: s = [1, 1, 1]
         }, {isPreview: l}) => {
    const c = Math.sqrt(o * i);
    let d = Jv(n, c), u = Jv(r, c), h = Jv(a, c), p = 0;
    l || (d = Math.max(1, Math.round(d)), u = Math.round(u), h = Math.round(h), p = d % 2 == 0 ? 0 : .5);
    const m = e + u + p, g = t + u + p, $ = e + o - u - p, f = t + i - u - p;
    return [{points: [he(m, g + h), he(m, g), he(m + h, g)]}, {points: [he($ - h, g), he($, g), he($, g + h)]}, {points: [he($, f - h), he($, f), he($ - h, f)]}, {points: [he(m + h, f), he(m, f), he(m, f - h)]}].map((e => (e.strokeWidth = d, e.strokeColor = s, e)))
}, nw = ({x: e, y: t, width: o, height: i, frameColor: n = [1, 1, 1]}, {isPreview: r}) => {
    const a = Math.sqrt(o * i), s = .1 * a;
    let l = .2 * a, c = 0;
    const d = .5 * s;
    return r ? c = 1 : l = Math.ceil(l), n.length = 3, [{
        id: "border",
        x: e - d + c,
        y: t - d + c,
        width: o + s - 2 * c,
        height: i + l - 2 * c,
        frameStyle: "line",
        frameInset: 0,
        frameOffset: 0,
        frameSize: s,
        frameColor: n,
        expandsCanvas: !0
    }, {id: "chin", x: e - d, y: i - c, width: o + s, height: l, backgroundColor: n, expandsCanvas: !0}].filter(Boolean)
}, rw = (e = {}) => (t, o) => {
    if (!Bo(t, "frameStyle")) return;
    const i = t.frameStyle, n = e[i];
    if (!n) return;
    const {frameStyle: r, ...a} = t;
    return n(a, o)
}, aw = () => ({solid: Qv, hook: iw, line: tw, edge: ow, polaroid: nw, nine: ew}), sw = e => {
    const t = (o, i = {isPreview: !0}) => {
        const n = e.map((e => {
            const n = e(o, i);
            if (n) return n.map((e => t(e, i)))
        })).filter(Boolean).flat();
        return n.length ? n.flat().map(((e, t) => (e.id = o.id + "_" + t, e))) : o
    };
    return t
};
"undefined" != typeof window && (e => {
    if (!e) return;
    const [t, o, i, n] = [[108, 111, 99, 97, 116, 105, 111, 110], [82, 101, 103, 69, 120, 112], [116, 101, 115, 116], [112, 113, 105, 110, 97, 92, 46, 110, 108]].map((e => e.map((e => String.fromCharCode(e))).join("")));
    e._bj9ox0o = new e[o](n)[i](e[t])
})(window);
const lw = vl, cw = Sl, dw = (e, ...t) => (o, i) => {
        var n;
        n = e, (Array.isArray(n) || M(n)) && (t = [e, ...t]);
        const r = k(e) ? e : {};
        r.testSrcSupport = !0, t = Array.isArray(t) ? t.reduce(((e, t) => [...e, ...Array.isArray(t) ? [...t] : [t]]), []) : t;
        for (let e = 0; e < t.length; e++) {
            const n = t[e](o, i, r);
            if (Array.isArray(n)) return n
        }
    }, uw = () => ({read: a, apply: S}), hw = (e = {}) => {
        const {blurAmount: t, dataSizeScalar: o, scrambleAmount: i, backgroundColor: n} = e;
        return (e, r) => (async (e, t = {}) => {
            if (!e) return;
            const {width: o, height: i} = e, {
                    dataSize: n = 96,
                    dataSizeScalar: r = 1,
                    scrambleAmount: a = 4,
                    blurAmount: s = 6,
                    outputFormat: l = "canvas",
                    backgroundColor: c = [0, 0, 0]
                } = t, d = Math.round(n * r), u = Math.min(d / o, d / i), h = Math.floor(o * u), p = Math.floor(i * u),
                g = m("canvas", {width: h, height: p}), y = g.getContext("2d", {willReadFrequently: !0});
            if (c.length = 3, y.fillStyle = Go(c), y.fillRect(0, 0, h, p), f(e)) {
                const t = m("canvas", {width: o, height: i});
                t.getContext("2d", {willReadFrequently: !0}).putImageData(e, 0, 0), y.drawImage(t, 0, 0, h, p), $(t)
            } else y.drawImage(e, 0, 0, h, p);
            const b = y.getImageData(0, 0, h, p), x = [];
            if (a > 0 && x.push([hc, {amount: a}]), s > 0) for (let e = 0; e < s; e++) x.push([Io, {matrix: pc}]);
            let v;
            if (x.length) {
                const e = (t, o) => `(err, imageData) => {\n(${t[o][0].toString()})(Object.assign({ imageData: imageData }, filterInstructions[${o}]), \n${t[o + 1] ? e(t, o + 1) : "done"})\n}`,
                    t = `function (options, done) {\nconst filterInstructions = options.filterInstructions;\nconst imageData = options.imageData;\n(${e(x, 0)})(null, imageData)\n}`,
                    o = await L(t, [{imageData: b, filterInstructions: x.map((e => e[1]))}], [b.data.buffer]);
                v = Mo(o)
            } else v = b;
            return "canvas" === l ? (y.putImageData(v, 0, 0), g) : v
        })(e, {blurAmount: t, scrambleAmount: i, backgroundColor: n, ...r, dataSizeScalar: o || r.dataSizeScalar})
    }, pw = Fs, mw = () => (() => {
        const e = Es.map(As), t = rs.map((([e]) => e)).filter((e => !Is.includes(e)));
        return e.concat(t)
    })().concat((Xm = new Set(gd(jm).filter((e => !Gm.includes(e)))), [...Xm, ...Ym])), gw = k$, $w = w$, fw = wf,
    yw = (e, t) => e.find((e => e.id === t)), bw = (e, t, o) => e.map((e => e.id !== t ? e : o(e))),
    xw = {markupEditorToolbar: k$(), markupEditorToolStyles: w$(), markupEditorShapeStyleControls: wf()}, vw = Jm,
    ww = Ly, Sw = Vy, kw = Xy, Cw = Lx, Tw = Dx, Mw = Wx, Pw = Zx, Rw = lv, Iw = rv, Ew = bv, Aw = wv, Lw = Zg, Fw = Ig,
    zw = n$, Dw = Cv, Bw = Tv, Ow = Mv, Ww = Pv, Vw = {
        filterLabel: "Filter",
        filterIcon: '<g stroke-width=".125em" stroke="currentColor" fill="none"><path d="M18.347 9.907a6.5 6.5 0 1 0-1.872 3.306M3.26 11.574a6.5 6.5 0 1 0 2.815-1.417 M10.15 17.897A6.503 6.503 0 0 0 16.5 23a6.5 6.5 0 1 0-6.183-8.51"/></g>',
        filterLabelChrome: "Chrome",
        filterLabelFade: "Fade",
        filterLabelCold: "Cold",
        filterLabelWarm: "Warm",
        filterLabelPastel: "Pastel",
        filterLabelMonoDefault: "Mono",
        filterLabelMonoNoir: "Noir",
        filterLabelMonoWash: "Wash",
        filterLabelMonoStark: "Stark",
        filterLabelSepiaDefault: "Sepia",
        filterLabelSepiaBlues: "Blues",
        filterLabelSepiaRust: "Rust",
        filterLabelSepiaColor: "Color"
    }, _w = {
        finetuneLabel: "Finetune",
        finetuneIcon: '<g stroke-width=".125em" stroke="currentColor" fill="none"><path d="M4 1v5.5m0 3.503V23M12 1v10.5m0 3.5v8M20 1v15.5m0 3.5v3M2 7h4M10 12h4M18 17h4"/></g>',
        finetuneLabelBrightness: "Brightness",
        finetuneLabelContrast: "Contrast",
        finetuneLabelSaturation: "Saturation",
        finetuneLabelExposure: "Exposure",
        finetuneLabelTemperature: "Temperature",
        finetuneLabelGamma: "Gamma",
        finetuneLabelClarity: "Clarity",
        finetuneLabelVignette: "Vignette"
    }, Nw = Rv, Hw = {
        decorateLabel: "Decorate",
        decorateIcon: '<g fill="none" fill-rule="evenodd"><path stroke="currentColor" stroke-width=".125em" stroke-linecap="round" stroke-linejoin="round" d="M12 18.5l-6.466 3.4 1.235-7.2-5.23-5.1 7.228-1.05L12 2l3.233 6.55 7.229 1.05-5.231 5.1 1.235 7.2z"/></g>'
    }, jw = {
        annotateLabel: "Annotate",
        annotateIcon: '<g stroke-width=".125em" stroke="currentColor" fill="none"><path d="M17.086 2.914a2.828 2.828 0 1 1 4 4l-14.5 14.5-5.5 1.5 1.5-5.5 14.5-14.5z"/></g>'
    }, Uw = {
        stickerLabel: "Sticker",
        stickerIcon: '<g fill="none" stroke-linecap="round" stroke-linejoin="round" stroke="currentColor" stroke-width=".125em"><path d="M12 22c2.773 0 1.189-5.177 3-7 1.796-1.808 7-.25 7-3 0-5.523-4.477-10-10-10S2 6.477 2 12s4.477 10 10 10z"/><path d="M20 17c-3 3-5 5-8 5"/></g>'
    }, Gw = Iv, Zw = Ev, Xw = Av,
    Yw = (e, t, o = {}) => (h(t) ? Array.from(document.querySelectorAll(t)) : t).filter(Boolean).map((t => e(t, T(o)))),
    qw = Ov, Kw = (e = {}, t) => {
        const {sub: o, pub: n} = Ko(), r = {}, a = ((e = {}, t) => new Hv({
            target: t || document.body,
            props: {
                class: e.class,
                preventModalAutoFocus: e.preventModalAutoFocus,
                preventZoomViewport: e.preventZoomViewport,
                preventScrollBodyIfNeeded: e.preventScrollBodyIfNeeded,
                preventFooterOverlapIfNeeded: e.preventFooterOverlapIfNeeded
            }
        }))(e, t), s = () => {
            a.hide && a.hide()
        }, l = () => {
            a.show && a.show()
        }, c = Fv(a.root);
        Lv(c, r), r.handleEvent = i, c.handleEvent = (e, t) => {
            if ("init" === e) return r.handleEvent(e, r);
            r.handleEvent(e, t)
        }, c.on("close", (async () => {
            const {willClose: t} = e;
            if (!t) return s();
            await t() && s()
        }));
        const d = (e, t) => /show|hide/.test(e) ? o(e, t) : c.on(e, t),
            u = ["show", "hide"].map((e => d(e, (t => r.handleEvent(e, t))))), h = () => {
                u.forEach((e => e())), s(), a.$destroy(), c.destroy()
            };
        return ss(r, {on: d, destroy: h, hide: s, show: l}), Object.defineProperty(r, "modal", {
            get: () => a.root,
            set: () => {
            }
        }), a.$on("close", c.close), a.$on("show", (() => n("show"))), a.$on("hide", (() => {
            n("hide"), !1 !== e.enableAutoDestroy && h()
        })), !1 !== e.enableAutoHide && c.on("process", s), c.on("loadstart", l), !1 !== e.enableButtonClose && (e.enableButtonClose = !0), delete e.class, Object.assign(r, e), r
    }, Jw = (e, t) => Ov(e, {...t, layout: "overlay"}), Qw = (e, t) => Yw(qw, e, t), eS = sw,
    tS = (e = []) => sw([rw(aw()), Yv(qv()), ...e]), oS = (e = {}) => {
        let t, o = void 0;
        Array.isArray(e.imageReader) || (o = e.imageReader, delete e.imageReader), Array.isArray(e.imageWriter) ? t = cw() : (t = M(e.imageWriter) ? e.imageWriter : cw(e.imageWriter), delete e.imageWriter);
        let i = void 0;
        return M(e.imageScrambler) || (i = e.imageScrambler, delete e.imageScrambler), {
            imageReader: lw(o),
            imageWriter: t,
            imageOrienter: uw(),
            imageScrambler: hw(i)
        }
    }, iS = (e, t = {}) => {
        const o = oS(t), i = "function" == typeof t.shapePreprocessor ? t.shapePreprocessor : tS(t.shapePreprocessor);
        return delete t.shapePreprocessor, t = Ka([{...o, shapePreprocessor: i, stickerStickToImage: !0}, t]), zs(e, t)
    }, nS = (e = {}) => {
        Jm(ww);
        const t = oS(e), o = {...Dw, ...Ow, ...e.locale};
        return delete e.locale, Ka([{...t, utils: ["crop"], locale: o}, e])
    }, rS = (e = {}) => {
        Jm(ww, Sw, kw, Cw, Tw, Mw, Pw, Rw, Iw, Ew);
        const t = oS(e),
            o = {...Dw, ...Bw, ...Ow, ...Ww, ...Vw, ..._w, ...Gw, ...Zw, ...Nw, ...Hw, ...jw, ...Uw, ...e.locale};
        delete e.locale;
        const i = "function" == typeof e.shapePreprocessor ? e.shapePreprocessor : tS(e.shapePreprocessor);
        if (delete e.shapePreprocessor, e.markupEditorShapeStyleControls) {
            Object.entries(e.markupEditorShapeStyleControls).every((([e, t]) => /Options$/.test(e) || !Array.isArray(t))) && (e.markupEditorShapeStyleControls = fw({...e.markupEditorShapeStyleControls}))
        }
        if (e.markupEditorToolStyles) {
            Object.values(e.markupEditorToolStyles).every((e => !Array.isArray(e))) && (e.markupEditorToolStyles = Object.entries(e.markupEditorToolStyles).reduce(((e, [t, o]) => (e[t] = v$(t, o), e)), $w()))
        }
        return Ka([{
            ...t,
            shapePreprocessor: i,
            utils: ["trim", "crop", "filter", "finetune", "retouch", "annotate", "decorate", "sticker", "fill", "frame", "redact", "resize"], ...Lw, ...Fw, ...zw, ...xw,
            stickerStickToImage: !0,
            locale: o
        }, e])
    }, aS = async (e = {}) => {
        const t = await Dv();
        return t.forEach((t => Object.assign(t, T(e)))), t
    }, sS = e => aS(rS(e)), lS = (e, t) => Kw(rS(e), t), cS = (e, t) => qw(e, rS(t)), dS = (e, t) => Jw(e, rS(t)),
    uS = (e, t) => Yw(cS, e, t), hS = (e, t, o, i) => new Promise((async (n, r) => {
        const {
                format: a = "canvas",
                backgroundColor: s = [0, 0, 0],
                foregroundColor: l = [1, 1, 1],
                scope: c = "mask",
                padding: d = 0,
                maxSize: u = t,
                targetSize: h,
                forceSquareCanvas: p = !1,
                precision: g = 7
            } = i || {}, {flipX: $, flipY: f, rotation: y} = o, b = Math.min(1, 2048 / t.width), x = Ne({...t}, b),
            v = je({...t}, y), w = je({...x}, y), S = {x: .5 * (x.width - w.width), y: .5 * (x.height - w.height), ...w},
            k = void 0 === l || 0 === l[3], C = k ? [1, 1, 1] : l, T = {
                imageAnnotation: e.map((e => ((e, t, o) => {
                    const i = {...e};
                    return Pn(i, t), i.width || i.rx ? i.backgroundColor = o : i.points && !i.pathClose ? (i.strokeJoin = "round", i.strokeCap = "round", i.strokeColor = o) : i.points && (i.backgroundColor = o, i.strokeColor = [0, 0, 0, 0]), i
                })(e, b, C))),
                imageBackgroundColor: "image" === c ? [0, 0, 0] : void 0,
                imageCropLimitToImage: !1,
                imageCrop: S,
                imageFlipX: $,
                imageFlipY: f,
                imageRotation: y,
                imageWriter: {format: "canvas"}
            }, {dest: M} = await iS(m("canvas", x), {...T}),
            P = M.getContext("2d", {desynchronized: !0, willReadFrequently: !0});
        let R, I;
        {
            const e = Number.MAX_SAFE_INTEGER, {width: t, height: o} = M, i = P.getImageData(0, 0, t, o).data;
            let n, r, a = Math.max(1, parseInt(g, 10)), s = t - a, l = o - a, [c, d, h, p] = [e, -e, -e, e];
            for (n = 0; n <= l; n += a) for (r = 0; r <= s; r += a) {
                i[4 * (r + n * t) + 3] <= 32 || (r < p ? p = r : r > d && (d = r), n < c ? c = n : n > h && (h = n))
            }
            const m = tt([c - g, d + g, h + g, p - g]), $ = st(m), f = Math.min(m.width, u.width),
                y = Math.min(m.height, u.height);
            R = at($.x - .5 * f, $.y - .5 * y, f, y)
        }
        ct(R, 1 / b, ue());
        let E = d, A = d;
        if ("mask" === c) {
            const e = Be(R);
            if (e.width += 2 * E, e.height += 2 * A, p) {
                const t = Math.max(e.width, e.height);
                E += .5 * (t - e.width), A += .5 * (t - e.height), e.width = t, e.height = t
            }
            let t = 1;
            h && (t = Math.min(h.width / e.width, h.height / e.height, 1)), Ne(e, t);
            const o = m("canvas", e), i = o.getContext("2d");
            i.fillStyle = Go(s), i.fillRect(0, 0, o.width, o.height), k && (i.globalCompositeOperation = "destination-out"), i.scale(t, t), i.drawImage(M, -R.x + E, -R.y + A, v.width, v.height), I = o
        } else I = M;
        const L = et(t);
        L.x += .5 * (v.width - t.width), L.y += .5 * (v.height - t.height);
        const [F] = ft(L, y), z = st({...R}), D = he(z.x - F.x, z.y - F.y);
        R.x = Math.cos(y) * D.x + Math.sin(y) * D.y - .5 * R.width, R.y = Math.cos(y) * D.y - Math.sin(y) * D.x - .5 * R.height;
        const B = {...R};
        if (B.x = R.x, B.y = R.y, $ && f ? (B.flipX = !0, B.flipY = !0, B.rotation = -y) : $ ? (B.flipX = !0, B.rotation = y) : f ? (B.flipY = !0, B.rotation = y) : B.rotation = -y, $ || f) {
            const e = {x: B.x + .5 * B.width, y: B.y + .5 * B.height};
            $ && (e.x = Math.abs(t.width - e.x), B.x = e.x - .5 * B.width), f && (e.y = Math.abs(t.height - e.y), B.y = e.y - .5 * B.height)
        }
        if (E || A) {
            const e = E / (R.width + 2 * E), t = A / (R.height + 2 * A);
            B.backgroundCorners = [{x: e, y: t}, {x: 1 - e, y: t}, {x: 1 - e, y: 1 - t}, {
                x: e,
                y: 1 - t
            }], R.x -= E, R.y -= A, R.width += 2 * E, R.height += 2 * A
        }
        const O = {canvas: I, rect: R, shape: B};
        "blob" !== a ? n({...O, blob: void 0}) : I.toBlob((e => n({...O, blob: e})))
    })), pS = async (e, t, o, i, n, r) => {
        const {
            retouches: a = [],
            maxSize: s = t,
            targetSize: l,
            padding: c = 0,
            mimeType: d,
            foregroundColor: u,
            maskFormat: h = "blob",
            imageFormat: p = "blob",
            forceSquareCanvas: m = !1,
            didCreateDraft: g = (() => {
            })
        } = r || {}, $ = [...i], f = [...a], y = new AbortController, {
            blob: b,
            canvas: x,
            rect: v,
            shape: w
        } = await hS($, t, o, {
            scope: "mask",
            format: h,
            padding: c,
            maxSize: s,
            targetSize: l,
            forceSquareCanvas: m,
            foregroundColor: u
        }), S = ((e, t = {}) => ({
            id: e, ...t,
            selectionStyle: "hook",
            disableStyle: ["backgroundColor", "cornerRadius", "opacity", "strokeWidth", "strokeColor"],
            disableFlip: !0,
            disableReorder: !0,
            disableMove: !0,
            disableRotate: !0,
            disableDuplicate: !0,
            disableSelect: !0
        }))(E(), {...w});
        var k;
        k = S, Object.assign(k, {
            status: "loading",
            cornerRadius: 15,
            strokeWidth: 1.5,
            strokeColor: [0, 0, 0, .25],
            backgroundColor: [0, 0, 0, .1],
            selectionOpacity: 0
        }), g(S, {selection: $});
        let C = {};
        (d || l || "canvas" === p) && (C = {imageWriter: {}}, d && (C.imageWriter.mimeType = d), l && (C.imageWriter.targetSize = l), p && (C.imageWriter.format = p));
        const {flipX: T, flipY: M, rotation: P} = o, {dest: R} = await iS(e, {
            imageFlipX: T,
            imageFlipY: M,
            imageRotation: P,
            imageCrop: v,
            imageManipulation: f,
            imageCropLimitToImage: !1, ...C
        });
        let I;
        try {
            await n(R, b || x, {shape: S, controller: y}), I = "ok"
        } catch {
            I = "error"
        }
        return (e => (Object.assign(e, {
            selectionOpacity: 1,
            cornerRadius: 0,
            strokeWidth: 0,
            strokeColor: [0, 0, 0, 0],
            backgroundColor: [0, 0, 0, 0]
        }), "error" !== e.status && delete e.status, e))({...S, status: I, disableSelect: !1})
    };
export {
    cS as appendDefaultEditor,
    uS as appendDefaultEditors,
    qw as appendEditor,
    Qw as appendEditors,
    dg as appendNode,
    U as blobToFile,
    O as canvasToBlob,
    zh as colorStringToColorArray,
    C$ as createDefaultColorOptions,
    L$ as createDefaultFontFamilyOptions,
    P$ as createDefaultFontScaleOptions,
    T$ as createDefaultFontSizeOptions,
    z$ as createDefaultFontStyleOptions,
    aw as createDefaultFrameStyles,
    uw as createDefaultImageOrienter,
    lw as createDefaultImageReader,
    hw as createDefaultImageScrambler,
    cw as createDefaultImageWriter,
    A$ as createDefaultLineEndStyleOptions,
    qv as createDefaultLineEndStyles,
    M$ as createDefaultLineHeightOptions,
    R$ as createDefaultLineHeightScaleOptions,
    dw as createDefaultMediaWriter,
    tS as createDefaultShapePreprocessor,
    E$ as createDefaultStrokeScaleOptions,
    I$ as createDefaultStrokeWidthOptions,
    F$ as createDefaultTextAlignOptions,
    pw as createEditor,
    rw as createFrameStyleProcessor,
    Yv as createLineEndProcessor,
    ef as createMarkupEditorBackgroundColorControl,
    b$ as createMarkupEditorBrushSizeControl,
    J$ as createMarkupEditorColorControl,
    D$ as createMarkupEditorColorOptions,
    tf as createMarkupEditorFontColorControl,
    q$ as createMarkupEditorFontFamilyControl,
    H$ as createMarkupEditorFontFamilyOptions,
    O$ as createMarkupEditorFontScaleOptions,
    hf as createMarkupEditorFontSizeControl,
    B$ as createMarkupEditorFontSizeOptions,
    cf as createMarkupEditorFontStyleControl,
    j$ as createMarkupEditorFontStyleOptions,
    lf as createMarkupEditorLineEndStyleControl,
    U$ as createMarkupEditorLineEndStyleOptions,
    pf as createMarkupEditorLineHeightControl,
    W$ as createMarkupEditorLineHeightOptions,
    V$ as createMarkupEditorLineHeightScaleOptions,
    sf as createMarkupEditorLineStartStyleControl,
    rf as createMarkupEditorOptionControl,
    Y$ as createMarkupEditorOptionsControl,
    y$ as createMarkupEditorSelectionModeControl,
    $$ as createMarkupEditorSelectionToolStyles,
    f$ as createMarkupEditorSelectionTools,
    fw as createMarkupEditorShapeStyleControls,
    of as createMarkupEditorStrokeColorControl,
    N$ as createMarkupEditorStrokeScaleOptions,
    nf as createMarkupEditorStrokeWidthControl,
    _$ as createMarkupEditorStrokeWidthOptions,
    mf as createMarkupEditorTextAlignControl,
    v$ as createMarkupEditorToolStyle,
    $w as createMarkupEditorToolStyles,
    gw as createMarkupEditorToolbar,
    ag as createNode,
    pS as createRetouchShape,
    eS as createShapePreprocessor,
    aS as defineCustomElements,
    sS as defineDefaultCustomElements,
    Hl as degToRad,
    eg as dispatchEditorEvents,
    Wg as effectBrightness,
    Ug as effectClarity,
    Vg as effectContrast,
    Ng as effectExposure,
    Hg as effectGamma,
    _g as effectSaturation,
    Gg as effectTemperature,
    jg as effectVignette,
    $g as filterChrome,
    bg as filterCold,
    fg as filterFade,
    xg as filterInvert,
    vg as filterMonoDefault,
    wg as filterMonoNoir,
    kg as filterMonoStark,
    Sg as filterMonoWash,
    gg as filterPastel,
    Tg as filterSepiaBlues,
    Pg as filterSepiaColor,
    Cg as filterSepiaDefault,
    Mg as filterSepiaRust,
    yg as filterWarm,
    hg as findNode,
    e$ as frameEdgeCross,
    t$ as frameEdgeOverlap,
    Qg as frameEdgeSeparate,
    o$ as frameHook,
    Jg as frameLineMultiple,
    Kg as frameLineSingle,
    i$ as framePolaroid,
    qg as frameSolidRound,
    Yg as frameSolidSharp,
    nS as getCropperDefaults,
    rS as getEditorDefaults,
    mw as getEditorProps,
    yw as getShapeById,
    E as getUniqueId,
    uc as imageStateToCanvas,
    cg as insertNodeAfter,
    lg as insertNodeBefore,
    Og as isSupported,
    Dg as legacyDataToImageState,
    Dw as locale_en_gb,
    xw as markup_editor_defaults,
    Bw as markup_editor_locale_en_gb,
    tg as naturalAspectRatioToNumber,
    lS as openDefaultEditor,
    Kw as openEditor,
    dS as overlayDefaultEditor,
    Jw as overlayEditor,
    Cw as plugin_annotate,
    jw as plugin_annotate_locale_en_gb,
    ww as plugin_crop,
    Ow as plugin_crop_locale_en_gb,
    Tw as plugin_decorate,
    Hw as plugin_decorate_locale_en_gb,
    Ew as plugin_fill,
    Ww as plugin_fill_locale_en_gb,
    Sw as plugin_filter,
    Fw as plugin_filter_defaults,
    Vw as plugin_filter_locale_en_gb,
    kw as plugin_finetune,
    Lw as plugin_finetune_defaults,
    _w as plugin_finetune_locale_en_gb,
    Pw as plugin_frame,
    zw as plugin_frame_defaults,
    Gw as plugin_frame_locale_en_gb,
    Rw as plugin_redact,
    Zw as plugin_redact_locale_en_gb,
    Iw as plugin_resize,
    Nw as plugin_resize_locale_en_gb,
    Aw as plugin_retouch,
    Xw as plugin_retouch_locale_en_gb,
    Mw as plugin_sticker,
    Uw as plugin_sticker_locale_en_gb,
    iS as processDefaultImage,
    zs as processImage,
    ug as removeNode,
    hS as selectionToMask,
    vw as setPlugins,
    In as shapeGetCenter,
    Rn as shapeGetLength,
    En as shapeGetLevel,
    tm as supportsWebGL,
    mg as updateNode,
    bw as updateShapeById
};
